<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Kotlin language specification</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./assets/css/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="./assets/js/tests-integration.js"></script>
</head>
<body>
<header>
<h1 class="title">Kotlin language specification</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#glossary">Glossary</a></li>
<li><a href="#kotlincore">Kotlin/Core</a><ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#syntax">Syntax</a><ul>
<li><a href="#grammar">Grammar</a><ul>
<li><a href="#lexical-grammar">Lexical grammar</a><ul>
<li><a href="#character-classes">Character classes</a></li>
<li><a href="#keywords-and-operators">Keywords and operators</a></li>
<li><a href="#whitespace-and-comments">Whitespace and comments</a></li>
<li><a href="#number-literals">Number literals</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#string-literals">String literals</a></li>
<li><a href="#misc">Misc</a></li>
</ul></li>
<li><a href="#syntax-grammar">Syntax grammar</a></li>
</ul></li>
</ul></li>
<li><a href="#type-system">Type system</a><ul>
<li><a href="#glossary-1">Glossary</a></li>
<li><a href="#introduction-1">Introduction</a></li>
<li><a href="#type-kinds">Type kinds</a><ul>
<li><a href="#built-in-types">Built-in types</a><ul>
<li><a href="#kotlin.any"><code>kotlin.Any</code></a></li>
<li><a href="#kotlin.nothing"><code>kotlin.Nothing</code></a></li>
<li><a href="#kotlin.unit"><code>kotlin.Unit</code></a></li>
<li><a href="#kotlin.function"><code>kotlin.Function</code></a></li>
</ul></li>
<li><a href="#classifier-types">Classifier types</a><ul>
<li><a href="#simple-classifier-types">Simple classifier types</a></li>
<li><a href="#parameterized-classifier-types">Parameterized classifier types</a></li>
</ul></li>
<li><a href="#type-parameters">Type parameters</a><ul>
<li><a href="#mixed-site-variance">Mixed-site variance</a></li>
<li><a href="#declaration-site-variance">Declaration-site variance</a></li>
<li><a href="#use-site-variance">Use-site variance</a></li>
</ul></li>
<li><a href="#type-capturing">Type capturing</a></li>
<li><a href="#function-types">Function types</a></li>
<li><a href="#array-types">Array types</a></li>
<li><a href="#flexible-types">Flexible types</a><ul>
<li><a href="#dynamic-type">Dynamic type</a></li>
<li><a href="#platform-types">Platform types</a></li>
</ul></li>
<li><a href="#nullable-types">Nullable types</a></li>
<li><a href="#intersection-types">Intersection types</a></li>
<li><a href="#integer-literal-types">Integer literal types</a></li>
<li><a href="#union-types">Union types</a></li>
</ul></li>
<li><a href="#type-context">Type context</a></li>
<li><a href="#subtyping">Subtyping</a><ul>
<li><a href="#subtyping-rules">Subtyping rules</a></li>
<li><a href="#subtyping-for-flexible-types">Subtyping for flexible types</a></li>
<li><a href="#subtyping-for-intersection-types">Subtyping for intersection types</a></li>
<li><a href="#subtyping-for-integer-literal-types">Subtyping for integer literal types</a></li>
<li><a href="#subtyping-for-nullable-types">Subtyping for nullable types</a></li>
</ul></li>
<li><a href="#generics">Generics</a></li>
<li><a href="#upper-and-lower-bounds">Upper and lower bounds</a><ul>
<li><a href="#least-upper-bound">Least upper bound</a></li>
<li><a href="#greatest-lower-bound">Greatest lower bound</a></li>
</ul></li>
<li><a href="#type-approximation">Type approximation</a></li>
<li><a href="#references">References</a></li>
</ul></li>
<li><a href="#built-in-classifier-types">Built-in classifier types</a><ul>
<li><a href="#kotlin.boolean"><code>kotlin.Boolean</code></a></li>
<li><a href="#built-in-integer-types">Built-in integer types</a></li>
<li><a href="#built-in-floating-point-arithmetic-types">Built-in floating point arithmetic types</a></li>
<li><a href="#kotlin.char"><code>kotlin.Char</code></a></li>
<li><a href="#kotlin.string"><code>kotlin.String</code></a></li>
</ul></li>
<li><a href="#runtime-type-information">Runtime type information</a><ul>
<li><a href="#runtime-available-types">Runtime-available types</a></li>
</ul></li>
<li><a href="#scopes-and-identifiers">Scopes and identifiers</a></li>
<li><a href="#packages-and-imports">Packages and imports</a><ul>
<li><a href="#importing">Importing</a></li>
<li><a href="#modules">Modules</a></li>
</ul></li>
<li><a href="#overloadable-operators">Overloadable operators</a></li>
<li><a href="#declarations">Declarations</a><ul>
<li><a href="#glossary-2">Glossary</a></li>
<li><a href="#identifiers-names-and-paths">Identifiers, names and paths</a></li>
<li><a href="#introduction-2">Introduction</a></li>
<li><a href="#classifier-declaration">Classifier declaration</a><ul>
<li><a href="#class-declaration">Class declaration</a><ul>
<li><a href="#constructor-declaration">Constructor declaration</a></li>
<li><a href="#nested-and-inner-classifiers">Nested and inner classifiers</a></li>
<li><a href="#inheritance-delegation">Inheritance delegation</a></li>
</ul></li>
<li><a href="#data-class-declaration">Data class declaration</a><ul>
<li><a href="#data-class-generation">Data class generation</a></li>
</ul></li>
<li><a href="#enum-class-declaration">Enum class declaration</a></li>
<li><a href="#annotation-class-declaration">Annotation class declaration</a></li>
<li><a href="#interface-declaration">Interface declaration</a></li>
<li><a href="#object-declaration">Object declaration</a></li>
<li><a href="#classifier-initialization">Classifier initialization</a></li>
</ul></li>
<li><a href="#function-declaration">Function declaration</a><ul>
<li><a href="#named-positional-and-default-parameters">Named, positional and default parameters</a></li>
<li><a href="#variable-length-parameters">Variable length parameters</a></li>
<li><a href="#extension-function-declaration">Extension function declaration</a></li>
</ul></li>
<li><a href="#property-declaration">Property declaration</a><ul>
<li><a href="#read-only-property-declaration">Read-only property declaration</a></li>
<li><a href="#mutable-property-declaration">Mutable property declaration</a></li>
<li><a href="#delegated-property-declaration">Delegated property declaration</a></li>
<li><a href="#local-property-declaration">Local property declaration</a></li>
<li><a href="#getters-and-setters">Getters and setters</a></li>
<li><a href="#extension-property-declaration">Extension property declaration</a></li>
<li><a href="#property-initialization">Property initialization</a></li>
<li><a href="#constant-properties">Constant properties</a></li>
</ul></li>
<li><a href="#type-alias">Type alias</a></li>
<li><a href="#declarations-with-type-parameters">Declarations with type parameters</a></li>
<li><a href="#declaration-modifiers">Declaration modifiers</a></li>
</ul></li>
<li><a href="#statements">Statements</a><ul>
<li><a href="#assignments">Assignments</a><ul>
<li><a href="#simple-assignments">Simple assignments</a></li>
<li><a href="#operator-assignments">Operator assignments</a></li>
</ul></li>
<li><a href="#loop-statements">Loop statements</a><ul>
<li><a href="#while-loop-statement">While-loop statement</a></li>
<li><a href="#do-while-loop-statement">Do-while-loop statement</a></li>
<li><a href="#for-loop-statement">For-loop statement</a></li>
</ul></li>
<li><a href="#code-blocks">Code blocks</a></li>
<li><a href="#todo">TODO</a></li>
</ul></li>
<li><a href="#expressions">Expressions</a><ul>
<li><a href="#glossary-3">Glossary</a></li>
<li><a href="#introduction-3">Introduction</a></li>
<li><a href="#constant-literals">Constant literals</a><ul>
<li><a href="#boolean-literals">Boolean literals</a></li>
<li><a href="#integer-literals">Integer literals</a><ul>
<li><a href="#decimal-integer-literals">Decimal integer literals</a></li>
<li><a href="#hexadecimal-integer-literals">Hexadecimal integer literals</a></li>
<li><a href="#binary-integer-literals">Binary integer literals</a></li>
</ul></li>
<li><a href="#the-types-for-integer-literals">The types for integer literals</a></li>
<li><a href="#real-literals">Real literals</a></li>
<li><a href="#character-literals">Character literals</a></li>
<li><a href="#string-literals-1">String literals</a></li>
<li><a href="#null-literal">Null literal</a></li>
</ul></li>
<li><a href="#try-expression">Try-expression</a></li>
<li><a href="#conditional-expression">Conditional expression</a></li>
<li><a href="#when-expression">When expression</a><ul>
<li><a href="#exhaustive-when-expressions">Exhaustive when expressions</a></li>
</ul></li>
<li><a href="#logical-disjunction-expression">Logical disjunction expression</a></li>
<li><a href="#logical-conjunction-expression">Logical conjunction expression</a></li>
<li><a href="#equality-expressions">Equality expressions</a><ul>
<li><a href="#reference-equality-expressions">Reference equality expressions</a></li>
<li><a href="#value-equality-expressions">Value equality expressions</a></li>
</ul></li>
<li><a href="#comparison-expressions">Comparison expressions</a></li>
<li><a href="#type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</a><ul>
<li><a href="#type-checking-expression">Type-checking expression</a></li>
<li><a href="#containment-checking-expression">Containment-checking expression</a></li>
</ul></li>
<li><a href="#elvis-operator-expression">Elvis operator expression</a></li>
<li><a href="#range-expression">Range expression</a></li>
<li><a href="#additive-expression">Additive expression</a></li>
<li><a href="#multiplicative-expression">Multiplicative expression</a></li>
<li><a href="#cast-expression">Cast expression</a></li>
<li><a href="#prefix-expressions">Prefix expressions</a><ul>
<li><a href="#annotated-and-labeled-expression">Annotated and labeled expression</a></li>
<li><a href="#prefix-increment-expression">Prefix increment expression</a></li>
<li><a href="#prefix-decrement-expression">Prefix decrement expression</a></li>
<li><a href="#unary-minus-expression">Unary minus expression</a></li>
<li><a href="#unary-plus-expression">Unary plus expression</a></li>
<li><a href="#logical-not-expression">Logical not expression</a></li>
</ul></li>
<li><a href="#postfix-operator-expressions">Postfix operator expressions</a><ul>
<li><a href="#postfix-increment-expression">Postfix increment expression</a></li>
<li><a href="#postfix-decrement-expression">Postfix decrement expression</a></li>
</ul></li>
<li><a href="#not-null-assertion-expression">Not-null assertion expression</a></li>
<li><a href="#indexing-expressions">Indexing expressions</a></li>
<li><a href="#call-and-property-access-expressions">Call and property access expressions</a><ul>
<li><a href="#navigation-operators">Navigation operators</a></li>
<li><a href="#callable-references">Callable references</a></li>
<li><a href="#class-literals">Class literals</a></li>
</ul></li>
<li><a href="#function-literals">Function literals</a><ul>
<li><a href="#anonymous-function-declarations">Anonymous function declarations</a></li>
<li><a href="#lambda-literals">Lambda literals</a></li>
</ul></li>
<li><a href="#object-literals">Object literals</a></li>
<li><a href="#this-expressions">This-expressions</a></li>
<li><a href="#super-forms">Super-forms</a></li>
<li><a href="#jump-expressions">Jump expressions</a><ul>
<li><a href="#throw-expressions">Throw expressions</a></li>
<li><a href="#return-expressions">Return expressions</a></li>
<li><a href="#continue-expression">Continue expression</a></li>
<li><a href="#break-expression">Break expression</a></li>
</ul></li>
<li><a href="#string-interpolation-expressions">String interpolation expressions</a></li>
</ul></li>
<li><a href="#todos">TODOs()</a></li>
<li><a href="#order-of-evaluation">Order of evaluation</a></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#control--and-data-flow-analysis">Control- and data-flow analysis</a></li>
<li><a href="#kotlin-type-constraints">Kotlin type constraints</a><ul>
<li><a href="#type-constraint-definition">Type constraint definition</a></li>
<li><a href="#type-constraint-solving">Type constraint solving</a><ul>
<li><a href="#checking-constraint-system-soundness">Checking constraint system soundness</a></li>
<li><a href="#finding-optimal-solution">Finding optimal solution</a></li>
<li><a href="#the-relations-on-types-as-constraints">The relations on types as constraints</a></li>
</ul></li>
</ul></li>
<li><a href="#type-inference">Type inference</a><ul>
<li><a href="#smart-casts">Smart casts</a><ul>
<li><a href="#smart-cast-sources">Smart cast sources</a></li>
<li><a href="#smart-cast-sink-stability">Smart cast sink stability</a><ul>
<li><a href="#effectively-immutable-smart-cast-sinks">Effectively immutable smart cast sinks</a></li>
</ul></li>
<li><a href="#source-sink-domination">Source-sink domination</a></li>
<li><a href="#bound-smart-casts">Bound smart casts</a></li>
</ul></li>
<li><a href="#local-type-inference">Local type inference</a></li>
<li><a href="#todo-1">TODO</a></li>
</ul></li>
<li><a href="#overload-resolution">Overload resolution</a><ul>
<li><a href="#intro">Intro</a></li>
<li><a href="#receivers">Receivers</a></li>
<li><a href="#the-forms-of-call-expression">The forms of call-expression</a></li>
<li><a href="#callables-and-invoke-convention">Callables and <code>invoke</code> convention</a></li>
<li><a href="#overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</a></li>
<li><a href="#a-call-with-an-explicit-receiver">A call with an explicit receiver</a></li>
<li><a href="#infix-function-calls">Infix function calls</a></li>
<li><a href="#operator-calls">Operator calls</a></li>
<li><a href="#a-call-without-an-explicit-receiver">A call without an explicit receiver</a></li>
<li><a href="#calls-with-named-parameters">Calls with named parameters</a></li>
<li><a href="#calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</a></li>
<li><a href="#calls-with-specified-type-parameters">Calls with specified type parameters</a></li>
<li><a href="#determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</a><ul>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#description">Description</a></li>
</ul></li>
<li><a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</a><ul>
<li><a href="#rationale-1">Rationale</a></li>
<li><a href="#description-1">Description</a></li>
</ul></li>
<li><a href="#about-type-inference">About type inference</a><ul>
<li><a href="#todos-1">TODOs</a></li>
</ul></li>
</ul></li>
<li><a href="#concurrency">Concurrency</a></li>
<li><a href="#coroutines">Coroutines</a><ul>
<li><a href="#suspending-functions">Suspending functions</a></li>
<li><a href="#coroutine-intrinsics">Coroutine intrinsics</a></li>
</ul></li>
<li><a href="#annotations">Annotations</a><ul>
<li><a href="#annotation-values">Annotation values</a></li>
<li><a href="#annotation-retention">Annotation retention</a></li>
<li><a href="#annotation-targets">Annotation targets</a></li>
<li><a href="#annotation-declarations">Annotation declarations</a></li>
<li><a href="#builtin-annotations">Builtin annotations</a></li>
</ul></li>
<li><a href="#documentation-comments">Documentation comments</a></li>
<li><a href="#exceptions">Exceptions</a><ul>
<li><a href="#catching-exceptions">Catching exceptions</a></li>
<li><a href="#throwing-exceptions">Throwing exceptions</a></li>
</ul></li>
</ul></li>
</ul>
</nav>










<h1 id="glossary">Glossary</h1>
<div class="paragraph">
<p><span class="sentence">w.r.t.:: with respect to</span></p>
</div>
<h1 id="kotlincore">Kotlin/Core</h1>
<h2 id="introduction">Introduction</h2>
<div class="paragraph">
<p><span class="sentence">Here be dragons…</span></p>
</div>
<h2 id="syntax">Syntax</h2>
<h3 id="grammar">Grammar</h3>
<h4 id="lexical-grammar">Lexical grammar</h4>
<h5 id="character-classes">Character classes</h5>
<div id="grammar-rule-LF" class="grammar-rule">
<dl>
<dt><strong><em>LF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Line Feed U+000A&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-CR" class="grammar-tule">
<dl>
<dt><strong><em>CR</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Carriage Return U+000D&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-WS" class="grammar-tule">
<dl>
<dt><strong><em>WS</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;one of the following characters: SPACE U+0020, TAB U+0009, Form Feed U+000C&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Underscore" class="grammar-tule">
<dl>
<dt><strong><em>Underscore</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;unicode character Low Line U+005F&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-Letter" class="grammar-tule">
<dl>
<dt><strong><em>Letter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from classes Ll, Lm, Lo, Lt, Lu or Nl&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeDigit" class="grammar-tule">
<dl>
<dt><strong><em>UnicodeDigit</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character from class Nd&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineCharacter" class="grammar-tule">
<dl>
<dt><strong><em>LineCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any unicode character excluding LF and CR&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinaryDigit" class="grammar-tule">
<dl>
<dt><strong><em>BinaryDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecimalDigit" class="grammar-tule">
<dl>
<dt><strong><em>DecimalDigit</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> | <code>'1'</code> | <code>'2'</code> | <code>'3'</code> | <code>'4'</code> | <code>'5'</code> | <code>'6'</code> | <code>'7'</code> | <code>'8'</code> | <code>'9'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigit" class="grammar-tule">
<dl>
<dt><strong><em>HexDigit</em>:</strong></dt>
<dd><span class="sentence"><em>DecimalDigit</em><br />
| <code>'A'</code> | <code>'B'</code> | <code>'C'</code> | <code>'D'</code> | <code>'E'</code> | <code>'F'</code><br />
| <code>'a'</code> | <code>'b'</code> | <code>'c'</code> | <code>'d'</code> | <code>'e'</code> | <code>'f'</code></span>
</dd>
</dl>
</div>
<h5 id="keywords-and-operators">Keywords and operators</h5>
<dl>
<dt><strong><em>Operator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code> | <code>','</code> | <code>'('</code> | <code>')'</code> | <code>'['</code> | <code>']'</code> | <code>'@['</code> | <code>'{'</code> | <code>'}'</code> | <code>'*'</code> | <code>'%'</code> | <code>'/'</code> | <code>'+'</code> | <code>'-'</code> | <code>'++'</code> | <code>'--'</code><br />
| <code>'&amp;&amp;'</code> | <code>'||'</code> | <code>'!'</code> | <code>'!!'</code> | <code>':'</code> | <code>';'</code> | <code>'='</code> | <code>'+='</code> | <code>'-='</code> | <code>'*='</code> | <code>'/='</code> | <code>'%='</code> | <code>'-&gt;'</code> | <code>'=&gt;'</code><br />
| <code>'..'</code> | <code>'::'</code> | <code>'?::'</code> | <code>';;'</code> | <code>'#'</code> | <code>'@'</code> | <code>'?'</code> | <code>'?:'</code> | <code>'&lt;'</code> | <code>'&gt;'</code> | <code>'\m'</code> | <code>'&gt;='</code> | <code>'!='</code> | <code>'!=='</code><br />
| <code>'=='</code> | <code>'==='</code> | <code>'''</code> | <code>'&quot;'</code> | <code>'&quot;&quot;&quot;'</code></span>
</dd>
<dt><strong><em>SoftKeyword</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code> | <code>'private'</code> | <code>'protected'</code> | <code>'internal'</code><br />
| <code>'enum'</code> | <code>'sealed'</code> | <code>'annotation'</code> | <code>'data'</code> | <code>'inner'</code><br />
| <code>'tailrec'</code> | <code>'operator'</code> | <code>'inline'</code> | <code>'infix'</code> | <code>'external'</code><br />
| <code>'suspend'</code> | <code>'override'</code> | <code>'abstract'</code> | <code>'final'</code> | <code>'open'</code><br />
| <code>'const'</code> | <code>'lateinit'</code> | <code>'vararg'</code> | <code>'noinline'</code> | <code>'crossinline'</code><br />
| <code>'reified'</code> | <code>'expect'</code> | <code>'actual'</code></span>
</dd>
<dt><strong><em>Keyword</em>:</strong></dt>
<dd><span class="sentence"><code>'package'</code> | <code>'import'</code> | <code>'class'</code> | <code>'interface'</code><br />
| <code>'fun'</code> | <code>'object'</code> | <code>'val'</code> | <code>'var'</code> | <code>'typealias'</code><br />
| <code>'constructor'</code> | <code>'by'</code> | <code>'companion'</code> | <code>'init'</code><br />
| <code>'this'</code> | <code>'super'</code> | <code>'typeof'</code> | <code>'where'</code><br />
| <code>'if'</code> | <code>'else'</code> | <code>'when'</code> | <code>'try'</code> | <code>'catch'</code><br />
| <code>'finally'</code> | <code>'for'</code> | <code>'do'</code> | <code>'while'</code> | <code>'throw'</code><br />
| <code>'return'</code> | <code>'continue'</code> | <code>'break'</code> | <code>'as'</code><br />
| <code>'is'</code> | <code>'in'</code> | <code>'!is'</code> | <code>'!in'</code> | <code>'out'</code><br />
| <code>'get'</code> | <code>'set'</code> | <code>'dynamic'</code> | <code>'@file'</code><br />
| <code>'@field'</code> | <code>'@property'</code> | <code>'@get'</code> | <code>'@set'</code><br />
| <code>'@receiver'</code> | <code>'@param'</code> | <code>'@setparam'</code> | <code>'@delegate'</code></span>
</dd>
</dl>
<h5 id="whitespace-and-comments">Whitespace and comments</h5>
<div id="grammar-rule-NL" class="grammar-tule">
<dl>
<dt><strong><em>NL</em>:</strong></dt>
<dd><span class="sentence"><em>LF</em> | <em>CR</em> [<em>LF</em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-ShebangLine" class="grammar-tule">
<dl>
<dt><strong><em>ShebangLine</em>:</strong></dt>
<dd><span class="sentence"><code>'#!'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineComment" class="grammar-tule">
<dl>
<dt><strong><em>LineComment</em>:</strong></dt>
<dd><span class="sentence"><code>'//'</code> {<em>LineCharacter</em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DelimitedComment" class="grammar-tule">
<dl>
<dt><strong><em>DelimitedComment</em>:</strong></dt>
<dd><span class="sentence"><code>'/*'</code> {<em>DelimitedComment</em> | &lt;any character&gt;} <code>'*/'</code></span>
</dd>
</dl>
</div>
<h5 id="number-literals">Number literals</h5>
<div id="grammar-rule-RealLiteral" class="grammar-tule">
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-FloatLiteral" class="grammar-tule">
<dl>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>'f'</code> | <code>'F'</code>) | <em>DecDigits</em> (<code>'f'</code> | <code>'F'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-DoubleLiteral" class="grammar-tule">
<dl>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>'.'</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LongLiteral" class="grammar-tule">
<dl>
<dt><strong><em>LongLiteral</em>:</strong></dt>
<dd><span class="sentence">(<em>IntegerLiteral</em> | <em>HexLiteral</em> | <em>BinLiteral</em>) <code>'L'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IntegerLiteral" class="grammar-tule">
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexLiteral" class="grammar-tule">
<dl>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>'0'</code> (<code>'x'</code>|<code>'X'</code>) <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinLiteral" class="grammar-tule">
<dl>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>'0'</code> (<code>'b'</code>|<code>'B'</code>) <em>BinDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DegDigitNoZero" class="grammar-tule">
<dl>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>'0'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-HexDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BinDigitOrSeparator" class="grammar-tule">
<dl>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-DecDigits" class="grammar-tule">
<dl>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-BooleanLiteral" class="grammar-tule">
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'true'</code> | <code>'false'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-NullLiteral" class="grammar-tule">
<dl>
<dt><strong><em>NullLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'null'</code></span>
</dd>
</dl>
</div>
<h5 id="identifiers">Identifiers</h5>
<div id="grammar-rule-Identifier" class="grammar-tule">
<dl>
<dt><strong><em>Identifier</em>:</strong></dt>
<dd><span class="sentence">(<em>Letter</em> | <em>Underscore</em>) {<em>Letter</em> | <em>Underscore</em> | <em>UnicodeDigit</em>}<br />
| <code>'`'</code> {<em>EscapedIdentifierCharacter</em>} <code>'`'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedIdentifierCharacter" class="grammar-tule">
<dl>
<dt><strong><em>EscapedIdentifierCharacter</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;any character except CR, LF, <code>'`''</code>, <code>'['</code>, <code>']'</code>, <code>'&lt;'</code> or <code>'&gt;'</code>&gt;</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierOrSoftKey" class="grammar-tule">
<dl>
<dt><strong><em>IdentifierOrSoftKey</em>:</strong></dt>
<dd><span class="sentence"><em>Identifier</em> | <em>SoftKeyword</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-AtIdentifier" class="grammar-tule">
<dl>
<dt><strong><em>AtIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'@'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-IdentifierAt" class="grammar-tule">
<dl>
<dt><strong><em>IdentifierAt</em>:</strong></dt>
<dd><span class="sentence"><em>IdentifierOrSoftKey</em> <code>'@'</code></span>
</dd>
</dl>
</div>
<h5 id="string-literals">String literals</h5>
<div class="paragraph">
<p><span class="sentence">Syntax literals are fully defined in syntax grammar due to the complex nature of string interpolation</span></p>
</div>
<div id="grammar-rule-CharacterLiteral" class="grammar-tule">
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'''</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'''</code> and <code>'\'</code>&gt;</em>) <code>'''</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapeSeq" class="grammar-tule">
<dl>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-UnicodeCharacterLiteral" class="grammar-tule">
<dl>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> <code>'u'</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-EscapedCharacter" class="grammar-tule">
<dl>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>'\'</code> (<code>'t'</code> | <code>'b'</code> | <code>'r'</code> | <code>'n'</code> | <code>'</code> | <code>'&quot;'</code> | <code>'\'</code> | <code>'$'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-FieldIdentifier" class="grammar-tule">
<dl>
<dt><strong><em>FieldIdentifier</em>:</strong></dt>
<dd><span class="sentence"><code>'$'</code> <em>IdentifierOrSoftKey</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrRef" class="grammar-tule">
<dl>
<dt><strong><em>LineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrEscapedChar" class="grammar-tule">
<dl>
<dt><strong><em>LineStrEscapedChar</em>:</strong></dt>
<dd><span class="sentence"><em>EscapedCharacter</em> | <em>UnicodeCharacterLiteral</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-LineStrExprStart" class="grammar-tule">
<dl>
<dt><strong><em>LineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStringQuote" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStringQuote</em>:</strong></dt>
<dd><span class="sentence"><code>'&quot;'</code> {<code>'&quot;'</code>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrRef" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrRef</em>:</strong></dt>
<dd><span class="sentence"><em>FieldIdentifier</em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrText" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrText</em>:</strong></dt>
<dd><span class="sentence">{&lt;any character except <code>'&quot;'</code> and <code>'$'</code>} | <code>'$'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-MultiLineStrExprStart" class="grammar-tule">
<dl>
<dt><strong><em>MultiLineStrExprStart</em>:</strong></dt>
<dd><span class="sentence"><code>'${'</code></span>
</dd>
</dl>
</div>
<h5 id="misc">Misc</h5>
<div id="grammar-rule-EOF" class="grammar-tule">
<dl>
<dt><strong><em>EOF</em>:</strong></dt>
<dd><span class="sentence"><em>&lt;end of input&gt;</em></span>
</dd>
</dl>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: redo all the lexical grammar, right now it is a hand-written mess</span></p>
</div>
</div>
<h4 id="syntax-grammar">Syntax grammar</h4>
<div id="grammar-rule-kotlinFile" class="grammar-rule">
<dl>
<dt><strong><em>kotlinFile</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
<em><a href="#grammar-rule-packageHeader">packageHeader</a></em><br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-topLevelObject">topLevelObject</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-script" class="grammar-rule">
<dl>
<dt><strong><em>script</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-shebangLine">shebangLine</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-fileAnnotation">fileAnnotation</a></em>}<br />
<em><a href="#grammar-rule-packageHeader">packageHeader</a></em><br />
<em><a href="#grammar-rule-importList">importList</a></em><br />
{<em><a href="#grammar-rule-statement">statement</a></em> <em><a href="#grammar-rule-semi">semi</a></em>}<br />
<em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-shebangLine" class="grammar-rule">
<dl>
<dt><strong><em>shebangLine</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-ShebangLine">ShebangLine</a></em> (<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-fileAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>fileAnnotation</em>:</strong></dt>
<dd><span class="sentence"><code>'@file'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
((<code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>) | <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-packageHeader" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence">[<code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importList" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-topLevelObject" class="grammar-rule">
<dl>
<dt><strong><em>topLevelObject</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeAlias" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-declaration" class="grammar-rule">
<dl>
<dt><strong><em>declaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-classDeclaration">classDeclaration</a></em><br />
| <em><a href="#grammar-rule-objectDeclaration">objectDeclaration</a></em><br />
| <em><a href="#grammar-rule-functionDeclaration">functionDeclaration</a></em><br />
| <em><a href="#grammar-rule-propertyDeclaration">propertyDeclaration</a></em><br />
| <em><a href="#grammar-rule-typeAlias">typeAlias</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>primaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[[<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'constructor'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-classParameters">classParameters</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classBody" class="grammar-rule">
<dl>
<dt><strong><em>classBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameters" class="grammar-rule">
<dl>
<dt><strong><em>classParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-classParameter">classParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classParameter">classParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classParameter" class="grammar-rule">
<dl>
<dt><strong><em>classParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
[<code>'val'</code> | <code>'var'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifiers" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-annotatedDelegationSpecifier">annotatedDelegationSpecifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-delegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>delegationSpecifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-explicitDelegation">explicitDelegation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em><br />
| <em><a href="#grammar-rule-functionType">functionType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorInvocation" class="grammar-rule">
<dl>
<dt><strong><em>constructorInvocation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em> <em><a href="#grammar-rule-valueArguments">valueArguments</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedDelegationSpecifier" class="grammar-rule">
<dl>
<dt><strong><em>annotatedDelegationSpecifier</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifier">delegationSpecifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-explicitDelegation" class="grammar-rule">
<dl>
<dt><strong><em>explicitDelegation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-userType">userType</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'by'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameters" class="grammar-rule">
<dl>
<dt><strong><em>typeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeParameter">typeParameter</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameter">typeParameter</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameter" class="grammar-rule">
<dl>
<dt><strong><em>typeParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeParameterModifiers">typeParameterModifiers</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraints" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraints</em>:</strong></dt>
<dd><span class="sentence"><code>'where'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraint">typeConstraint</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeConstraint" class="grammar-rule">
<dl>
<dt><strong><em>typeConstraint</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclarations" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclarations</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-classMemberDeclaration">classMemberDeclaration</a></em> [<em><a href="#grammar-rule-semis">semis</a></em>]}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classMemberDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>classMemberDeclaration</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-declaration">declaration</a></em><br />
| <em><a href="#grammar-rule-companionObject">companionObject</a></em><br />
| <em><a href="#grammar-rule-anonymousInitializer">anonymousInitializer</a></em><br />
| <em><a href="#grammar-rule-secondaryConstructor">secondaryConstructor</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousInitializer" class="grammar-rule">
<dl>
<dt><strong><em>anonymousInitializer</em>:</strong></dt>
<dd><span class="sentence"><code>'init'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-companionObject" class="grammar-rule">
<dl>
<dt><strong><em>companionObject</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'companion'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'object'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionValueParameter">functionValueParameter</a></em>}]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionValueParameter" class="grammar-rule">
<dl>
<dt><strong><em>functionValueParameter</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <em><a href="#grammar-rule-parameter">parameter</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-variableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>variableDeclaration</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiVariableDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>multiVariableDeclaration</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>) | <em><a href="#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="#grammar-rule-getter">getter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-setter">setter</a></em>]) | ([<em><a href="#grammar-rule-setter">setter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyDelegate" class="grammar-rule">
<dl>
<dt><strong><em>propertyDelegate</em>:</strong></dt>
<dd><span class="sentence"><code>'by'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-getter" class="grammar-rule">
<dl>
<dt><strong><em>getter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'get'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-setter" class="grammar-rule">
<dl>
<dt><strong><em>setter</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code>)<br />
| ([<em><a href="#grammar-rule-modifiers">modifiers</a></em>] <code>'set'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em>} <em><a href="#grammar-rule-setterParameter">setterParameter</a></em> <code>')'</code> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-setterParameter" class="grammar-rule">
<dl>
<dt><strong><em>setterParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameter" class="grammar-rule">
<dl>
<dt><strong><em>parameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>':'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-secondaryConstructor" class="grammar-rule">
<dl>
<dt><strong><em>secondaryConstructor</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'constructor'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-constructorDelegationCall">constructorDelegationCall</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-block">block</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-constructorDelegationCall" class="grammar-rule">
<dl>
<dt><strong><em>constructorDelegationCall</em>:</strong></dt>
<dd><span class="sentence">(<code>'this'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)<br />
| (<code>'super'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumClassBody" class="grammar-rule">
<dl>
<dt><strong><em>enumClassBody</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-enumEntries">enumEntries</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classMemberDeclarations">classMemberDeclarations</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntries" class="grammar-rule">
<dl>
<dt><strong><em>enumEntries</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-enumEntry">enumEntry</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumEntry">enumEntry</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>','</code>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-enumEntry" class="grammar-rule">
<dl>
<dt><strong><em>enumEntry</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}] <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-type" class="grammar-rule">
<dl>
<dt><strong><em>type</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-functionType">functionType</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeReference" class="grammar-rule">
<dl>
<dt><strong><em>typeReference</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-userType">userType</a></em><br />
| <code>'dynamic'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-nullableType" class="grammar-rule">
<dl>
<dt><strong><em>nullableType</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-typeReference">typeReference</a></em> | <em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-quest">quest</a></em> {<em><a href="#grammar-rule-quest">quest</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-quest" class="grammar-rule">
<dl>
<dt><strong><em>quest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em><br />
| <em><a href="#grammar-rule-QUEST_WS">QUEST_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-userType" class="grammar-rule">
<dl>
<dt><strong><em>userType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-simpleUserType">simpleUserType</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleUserType" class="grammar-rule">
<dl>
<dt><strong><em>simpleUserType</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeArguments">typeArguments</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionType" class="grammar-rule">
<dl>
<dt><strong><em>functionType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
<em><a href="#grammar-rule-functionTypeParameters">functionTypeParameters</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'-&gt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionTypeParameters" class="grammar-rule">
<dl>
<dt><strong><em>functionTypeParameters</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>]<br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-parameter">parameter</a></em> | <em><a href="#grammar-rule-type">type</a></em>)}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedType</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-receiverType" class="grammar-rule">
<dl>
<dt><strong><em>receiverType</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-typeModifiers">typeModifiers</a></em>] (<em><a href="#grammar-rule-parenthesizedType">parenthesizedType</a></em> | <em><a href="#grammar-rule-nullableType">nullableType</a></em> | <em><a href="#grammar-rule-typeReference">typeReference</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedUserType" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedUserType</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-userType">userType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-parenthesizedUserType">parenthesizedUserType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statements" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statement" class="grammar-rule">
<dl>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-label">label</a></em> | <em><a href="#grammar-rule-annotation">annotation</a></em>} (<em><a href="#grammar-rule-declaration">declaration</a></em> | <em><a href="#grammar-rule-assignment">assignment</a></em> | <em><a href="#grammar-rule-loopStatement">loopStatement</a></em> | <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-label" class="grammar-rule">
<dl>
<dt><strong><em>label</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-IdentifierAt">IdentifierAt</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-controlStructureBody" class="grammar-rule">
<dl>
<dt><strong><em>controlStructureBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| <em><a href="#grammar-rule-statement">statement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-block" class="grammar-rule">
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-statements">statements</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-loopStatement" class="grammar-rule">
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-forStatement">forStatement</a></em><br />
| <em><a href="#grammar-rule-whileStatement">whileStatement</a></em><br />
| <em><a href="#grammar-rule-doWhileStatement">doWhileStatement</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-forStatement" class="grammar-rule">
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'for'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
(<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em> | <em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em>)<br />
<em><a href="#grammar-rule-IN">IN</a></em><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whileStatement" class="grammar-rule">
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence">(<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)<br />
| (<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-doWhileStatement" class="grammar-rule">
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'do'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'while'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignment" class="grammar-rule">
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em> <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| (<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em> <em><a href="#grammar-rule-assignmentAndOperator">assignmentAndOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-semi" class="grammar-rule">
<dl>
<dt><strong><em>semi</em>:</strong></dt>
<dd><span class="sentence">((<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-semis" class="grammar-rule">
<dl>
<dt><strong><em>semis</em>:</strong></dt>
<dd><span class="sentence">(<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em> {<code>';'</code> | <em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-EOF">EOF</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-expression" class="grammar-rule">
<dl>
<dt><strong><em>expression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-disjunction">disjunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-disjunction" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-conjunction" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equality" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparison" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixOperation" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvisExpression" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-elvis" class="grammar-rule">
<dl>
<dt><strong><em>elvis</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>':'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-infixFunctionCall" class="grammar-rule">
<dl>
<dt><strong><em>infixFunctionCall</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em> {<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-rangeExpression">rangeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeExpression" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveExpression" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asExpression" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-directlyAssignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>directlyAssignableExpression</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em> <em><a href="#grammar-rule-assignableSuffix">assignableSuffix</a></em>)<br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableExpression" class="grammar-rule">
<dl>
<dt><strong><em>assignableExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignableSuffix" class="grammar-rule">
<dl>
<dt><strong><em>assignableSuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArgument" class="grammar-rule">
<dl>
<dt><strong><em>valueArgument</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-annotation">annotation</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>}]<br />
[<code>'*'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-primaryExpression" class="grammar-rule">
<dl>
<dt><strong><em>primaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em><br />
| <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
| <em><a href="#grammar-rule-literalConstant">literalConstant</a></em><br />
| <em><a href="#grammar-rule-stringLiteral">stringLiteral</a></em><br />
| <em><a href="#grammar-rule-callableReference">callableReference</a></em><br />
| <em><a href="#grammar-rule-functionLiteral">functionLiteral</a></em><br />
| <em><a href="#grammar-rule-objectLiteral">objectLiteral</a></em><br />
| <em><a href="#grammar-rule-collectionLiteral">collectionLiteral</a></em><br />
| <em><a href="#grammar-rule-thisExpression">thisExpression</a></em><br />
| <em><a href="#grammar-rule-superExpression">superExpression</a></em><br />
| <em><a href="#grammar-rule-ifExpression">ifExpression</a></em><br />
| <em><a href="#grammar-rule-whenExpression">whenExpression</a></em><br />
| <em><a href="#grammar-rule-tryExpression">tryExpression</a></em><br />
| <em><a href="#grammar-rule-jumpExpression">jumpExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parenthesizedExpression" class="grammar-rule">
<dl>
<dt><strong><em>parenthesizedExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'('</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-collectionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>collectionLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)<br />
| (<code>'['</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-literalConstant" class="grammar-rule">
<dl>
<dt><strong><em>literalConstant</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-BooleanLiteral">BooleanLiteral</a></em><br />
| <em><a href="#grammar-rule-IntegerLiteral">IntegerLiteral</a></em><br />
| <em><a href="#grammar-rule-HexLiteral">HexLiteral</a></em><br />
| <em><a href="#grammar-rule-BinLiteral">BinLiteral</a></em><br />
| <em><a href="#grammar-rule-CharacterLiteral">CharacterLiteral</a></em><br />
| <em><a href="#grammar-rule-RealLiteral">RealLiteral</a></em><br />
| <em><a href="#grammar-rule-NullLiteral">NullLiteral</a></em><br />
| <em><a href="#grammar-rule-LongLiteral">LongLiteral</a></em><br />
| <em><a href="#grammar-rule-UnsignedLiteral">UnsignedLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-stringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>stringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lineStringLiteral">lineStringLiteral</a></em><br />
| <em><a href="#grammar-rule-multiLineStringLiteral">multiLineStringLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUOTE_OPEN">QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-lineStringContent">lineStringContent</a></em> | <em><a href="#grammar-rule-lineStringExpression">lineStringExpression</a></em>} <em><a href="#grammar-rule-QUOTE_CLOSE">QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringLiteral" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-TRIPLE_QUOTE_OPEN">TRIPLE_QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-multiLineStringContent">multiLineStringContent</a></em> | <em><a href="#grammar-rule-multiLineStringExpression">multiLineStringExpression</a></em> | <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em>} <em><a href="#grammar-rule-TRIPLE_QUOTE_CLOSE">TRIPLE_QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>lineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrText">LineStrText</a></em><br />
| <em><a href="#grammar-rule-LineStrEscapedChar">LineStrEscapedChar</a></em><br />
| <em><a href="#grammar-rule-LineStrRef">LineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>lineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrExprStart">LineStrExprStart</a></em> <em><a href="#grammar-rule-expression">expression</a></em> <code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringContent" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrText">MultiLineStrText</a></em><br />
| <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em><br />
| <em><a href="#grammar-rule-MultiLineStrRef">MultiLineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringExpression" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrExprStart">MultiLineStrExprStart</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaLiteral" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-anonymousFunction" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionLiteral" class="grammar-rule">
<dl>
<dt><strong><em>functionLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em><br />
| <em><a href="#grammar-rule-anonymousFunction">anonymousFunction</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectLiteral" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-thisExpression" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-superExpression" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<code>'@'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-ifExpression" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenExpression" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-tryExpression" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-jumpExpression" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-callableReference" class="grammar-rule">
<dl>
<dt><strong><em>callableReference</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-receiverType">receiverType</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'::'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignmentAndOperator" class="grammar-rule">
<dl>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+='</code><br />
| <code>'-='</code><br />
| <code>'*='</code><br />
| <code>'/='</code><br />
| <code>'%='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-excl" class="grammar-rule">
<dl>
<dt><strong><em>excl</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em><br />
| <em><a href="#grammar-rule-EXCL_WS">EXCL_WS</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-safeNav" class="grammar-rule">
<dl>
<dt><strong><em>safeNav</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUEST_NO_WS">QUEST_NO_WS</a></em> <code>'.'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifiers" class="grammar-rule">
<dl>
<dt><strong><em>modifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em> {<em><a href="#grammar-rule-annotation">annotation</a></em> | <em><a href="#grammar-rule-modifier">modifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-modifier" class="grammar-rule">
<dl>
<dt><strong><em>modifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-classModifier">classModifier</a></em> | <em><a href="#grammar-rule-memberModifier">memberModifier</a></em> | <em><a href="#grammar-rule-visibilityModifier">visibilityModifier</a></em> | <em><a href="#grammar-rule-functionModifier">functionModifier</a></em> | <em><a href="#grammar-rule-propertyModifier">propertyModifier</a></em> | <em><a href="#grammar-rule-inheritanceModifier">inheritanceModifier</a></em> | <em><a href="#grammar-rule-parameterModifier">parameterModifier</a></em> | <em><a href="#grammar-rule-platformModifier">platformModifier</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeModifier">typeModifier</a></em> {<em><a href="#grammar-rule-typeModifier">typeModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeModifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| (<code>'suspend'</code> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-classModifier" class="grammar-rule">
<dl>
<dt><strong><em>classModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'enum'</code><br />
| <code>'sealed'</code><br />
| <code>'annotation'</code><br />
| <code>'data'</code><br />
| <code>'inner'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberModifier" class="grammar-rule">
<dl>
<dt><strong><em>memberModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'override'</code><br />
| <code>'lateinit'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-visibilityModifier" class="grammar-rule">
<dl>
<dt><strong><em>visibilityModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'public'</code><br />
| <code>'private'</code><br />
| <code>'internal'</code><br />
| <code>'protected'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-varianceModifier" class="grammar-rule">
<dl>
<dt><strong><em>varianceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <code>'out'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifiers" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em> {<em><a href="#grammar-rule-typeParameterModifier">typeParameterModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeParameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>typeParameterModifier</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-reificationModifier">reificationModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| (<em><a href="#grammar-rule-varianceModifier">varianceModifier</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})<br />
| <em><a href="#grammar-rule-annotation">annotation</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionModifier" class="grammar-rule">
<dl>
<dt><strong><em>functionModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'tailrec'</code><br />
| <code>'operator'</code><br />
| <code>'infix'</code><br />
| <code>'inline'</code><br />
| <code>'external'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-propertyModifier" class="grammar-rule">
<dl>
<dt><strong><em>propertyModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'const'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-inheritanceModifier" class="grammar-rule">
<dl>
<dt><strong><em>inheritanceModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'abstract'</code><br />
| <code>'final'</code><br />
| <code>'open'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-parameterModifier" class="grammar-rule">
<dl>
<dt><strong><em>parameterModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'vararg'</code><br />
| <code>'noinline'</code><br />
| <code>'crossinline'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-reificationModifier" class="grammar-rule">
<dl>
<dt><strong><em>reificationModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'reified'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-platformModifier" class="grammar-rule">
<dl>
<dt><strong><em>platformModifier</em>:</strong></dt>
<dd><span class="sentence"><code>'expect'</code><br />
| <code>'actual'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotation" class="grammar-rule">
<dl>
<dt><strong><em>annotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-singleAnnotation">singleAnnotation</a></em> | <em><a href="#grammar-rule-multiAnnotation">multiAnnotation</a></em>) {<em><a href="#grammar-rule-NL">NL</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-singleAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>singleAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)<br />
| (<code>'@'</code> <em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>multiAnnotation</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-annotationUseSiteTarget">annotationUseSiteTarget</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)<br />
| (<code>'@'</code> <code>'['</code> (<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em> {<em><a href="#grammar-rule-unescapedAnnotation">unescapedAnnotation</a></em>}) <code>']'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotationUseSiteTarget" class="grammar-rule">
<dl>
<dt><strong><em>annotationUseSiteTarget</em>:</strong></dt>
<dd><span class="sentence"><code>'@'</code> (<code>'field'</code> | <code>'property'</code> | <code>'get'</code> | <code>'set'</code> | <code>'receiver'</code> | <code>'param'</code> | <code>'setparam'</code> | <code>'delegate'</code>) {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unescapedAnnotation" class="grammar-rule">
<dl>
<dt><strong><em>unescapedAnnotation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-constructorInvocation">constructorInvocation</a></em><br />
| <em><a href="#grammar-rule-userType">userType</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-simpleIdentifier" class="grammar-rule">
<dl>
<dt><strong><em>simpleIdentifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-Identifier">Identifier</a></em><br />
| <code>'abstract'</code><br />
| <code>'annotation'</code><br />
| <code>'by'</code><br />
| <code>'catch'</code><br />
| <code>'companion'</code><br />
| <code>'constructor'</code><br />
| <code>'crossinline'</code><br />
| <code>'data'</code><br />
| <code>'dynamic'</code><br />
| <code>'enum'</code><br />
| <code>'external'</code><br />
| <code>'final'</code><br />
| <code>'finally'</code><br />
| <code>'get'</code><br />
| <code>'import'</code><br />
| <code>'infix'</code><br />
| <code>'init'</code><br />
| <code>'inline'</code><br />
| <code>'inner'</code><br />
| <code>'internal'</code><br />
| <code>'lateinit'</code><br />
| <code>'noinline'</code><br />
| <code>'open'</code><br />
| <code>'operator'</code><br />
| <code>'out'</code><br />
| <code>'override'</code><br />
| <code>'private'</code><br />
| <code>'protected'</code><br />
| <code>'public'</code><br />
| <code>'reified'</code><br />
| <code>'sealed'</code><br />
| <code>'tailrec'</code><br />
| <code>'set'</code><br />
| <code>'vararg'</code><br />
| <code>'where'</code><br />
| <code>'expect'</code><br />
| <code>'actual'</code><br />
| <code>'const'</code><br />
| <code>'suspend'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-identifier" class="grammar-rule">
<dl>
<dt><strong><em>identifier</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>}</span>
</dd>
</dl>
</div>
<h2 id="type-system">Type system</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add examples)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Add grammar snippets?)</span></p>
</div>
</div>
<h3 id="glossary-1">Glossary</h3>
<dl>
<dt><span class="math inline">\(T\)</span></dt>
<dd><span class="sentence">Type</span>
</dd>
<dt><span class="math inline">\(T!!\)</span></dt>
<dd><span class="sentence">Non-nullable type</span>
</dd>
<dt><span class="math inline">\(T?\)</span></dt>
<dd><span class="sentence">Nullable type</span>
</dd>
<dt><span class="math inline">\(\{T\}\)</span></dt>
<dd><span class="sentence">Universe of all possible types</span>
</dd>
<dt><span class="math inline">\(\{T!!\}\)</span></dt>
<dd><span class="sentence">Universe of non-nullable types</span>
</dd>
<dt><span class="math inline">\(\{T?\}\)</span></dt>
<dd><span class="sentence">Universe of nullable types</span>
</dd>
<dt><span class="math inline">\(\Gamma\)</span></dt>
<dd><span class="sentence">Type context</span>
</dd>
<dt><span class="math inline">\(A &lt;: B\)</span></dt>
<dd><span class="sentence">A is a subtype of B</span>
</dd>
<dt><span class="math inline">\(A &lt;:&gt; B\)</span></dt>
<dd><span class="sentence">A and B are not related w.r.t. subtyping</span>
</dd>
<dt>Type constructor</dt>
<dd><span class="sentence">An abstract type with one or more type parameters, which must be instantiated before use</span>
</dd>
<dt>Parameterized type</dt>
<dd><span class="sentence">A concrete type, which is the result of type constructor instantiation</span>
</dd>
<dt>Type parameter</dt>
<dd><span class="sentence">Formal type argument of a type constructor</span>
</dd>
<dt>Type argument</dt>
<dd><span class="sentence">Actual type argument in a parameterized type</span>
</dd>
<dt><span class="math inline">\(T\lbrack A_1, \ldots, A_n\rbrack\)</span></dt>
<dd><span class="sentence">The result of type constructor <span class="math inline">\(T\)</span> instantiation with type arguments <span class="math inline">\(A_i\)</span></span>
</dd>
<dt><span class="math inline">\(T\lbrack\sigma\rbrack\)</span></dt>
<dd><span class="sentence">The result of type constructor <span class="math inline">\(T(F_1, \ldots, F_n)\)</span> instantiation with the assumed substitution <span class="math inline">\(\sigma : F_1 = A_1, \ldots, F_n = A_n\)</span></span>
</dd>
<dt><span class="math inline">\(\sigma T\)</span></dt>
<dd><span class="sentence">The result of type substitution in type <span class="math inline">\(T\)</span> w.r.t. substitution <span class="math inline">\(\sigma\)</span></span>
</dd>
<dt><span class="math inline">\(K_T(F, A)\)</span></dt>
<dd><span class="sentence">Captured type from the <a href="#type-capturing">type capturing</a> of type parameter <span class="math inline">\(F\)</span> and type argument <span class="math inline">\(A\)</span> in parameterized type <span class="math inline">\(T\)</span></span>
</dd>
<dt><span class="math inline">\(T\langle K_1, \ldots, K_n\rangle\)</span></dt>
<dd><span class="sentence">The result of type capturing for parameterized type <span class="math inline">\(T\)</span> with <em>captured</em> types <span class="math inline">\(K_i\)</span></span>
</dd>
<dt><span class="math inline">\(A \operatorname{\&amp;}B\)</span></dt>
<dd><span class="sentence">Intersection type of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></span>
</dd>
<dt><span class="math inline">\(A | B\)</span></dt>
<dd><span class="sentence">Union type of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span></span>
</dd>
<dt><span class="math inline">\(\mathtt{GLB}\)</span></dt>
<dd><span class="sentence">Greatest lower bound</span>
</dd>
<dt><span class="math inline">\(\mathtt{LUB}\)</span></dt>
<dd><span class="sentence">Least upper bound</span>
</dd>
</dl>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Not everything is in the glossary, make some criteria of what goes where)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Cleanup glossary)</span></p>
</div>
</div>
<h3 id="introduction-1">Introduction</h3>
<div class="paragraph">
<p><span class="sentence">Similarly to most other programming languages, Kotlin operates on data in the form of <em>values</em> or <em>objects</em>, which have <em>types</em> — descriptions of what is the expected behaviour and possible values for their datum. </span><span class="sentence">An empty value is represented by a special <code>null</code> object; most operations with it result in runtime <a href="#exceptions">errors or exceptions</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin has a type system with the following main properties.</span></p>
</div>
<ul>
<li><span class="sentence">Hybrid static and gradual type checking</span></li>
<li><span class="sentence">Null safety</span></li>
<li><span class="sentence">No unsafe implicit conversions</span></li>
<li><span class="sentence">Unified top and bottom types</span></li>
<li><span class="sentence">Nominal subtyping with bounded parametric polymorphism and mixed-site variance</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(static type checking, gradual type checking)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Null safety is enforced by having two type universes: <em>nullable</em> (with nullable types <span class="math inline">\(T?\)</span>) and <em>non-nullable</em> (with non-nullable types <span class="math inline">\(T!!\)</span>). </span><span class="sentence">A value of any non-nullable type cannot contain <code>null</code>, meaning all operations within the non-nullable type universe are safe w.r.t. empty values, i.e., should never result in a runtime error caused by <code>null</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit conversions between types in Kotlin are limited to safe upcasts w.r.t. subtyping, meaning all other (unsafe) conversions must be explicit, done via either a conversion function or an <a href="#cast-expression">explicit cast</a>. </span><span class="sentence">However, Kotlin also supports smart casts — a special kind of implicit conversions which are safe w.r.t. program control- and data-flow, which are covered in more detail <a href="#smart-casts">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The unified supertype type for all types in Kotlin is <span class="math inline">\(\mathtt{kotlin.Any?}\)</span>, a <a href="#nullable-types">nullable</a> version of [<span class="math inline">\(\mathtt{kotlin.Any}\)</span>][kotlin.Any]. </span><span class="sentence">The unified subtype type for all types in Kotlin is [<span class="math inline">\(\mathtt{kotlin.Nothing}\)</span>][kotlin.Nothing].</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses nominal subtyping, meaning subtyping relation is defined when a type is declared, with bounded parametric polymorphism, implemented as <a href="#generics">generics</a> via <a href="#parameterized-classifier-types">parameterized types</a>. </span><span class="sentence">Subtyping between these parameterized types is defined through <a href="#mixed-site-variance">mixed-site variance</a>.</span></p>
</div>
<h3 id="type-kinds">Type kinds</h3>
<div class="paragraph">
<p><span class="sentence">For the purposes of this section, we establish the following type kinds — different flavours of types which exist in the Kotlin type system.</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#built-in-types">Built-in types</a></span></li>
<li><span class="sentence"><a href="#classifier-types">Classifier types</a></span></li>
<li><span class="sentence"><a href="#type-parameters">Type parameters</a></span></li>
<li><span class="sentence"><a href="#function-types">Function types</a></span></li>
<li><span class="sentence"><a href="#array-types">Array types</a></span></li>
<li><span class="sentence"><a href="#flexible-types">Flexible types</a></span></li>
<li><span class="sentence"><a href="#nullable-types">Nullable types</a></span></li>
<li><span class="sentence"><a href="#intersection-types">Intersection types</a></span></li>
<li><span class="sentence"><a href="#union-types">Union types</a></span></li>
<li><div class="TODO">
<span class="sentence">TODO(Error / invalid types)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">We distinguish between <em>concrete</em> and <em>abstract</em> types. </span><span class="sentence">Concrete types are types which are assignable to values. </span><span class="sentence">Abstract types need to be instantiated as concrete types before they can be used as types for values.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for brevity, we omit specifying that a type is concrete. </span><span class="sentence">All types not described as abstract are implicitly concrete.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">We further distinguish <em>concrete</em> types between <em>class</em> and <em>interface</em> types; as Kotlin is a language with single inheritance, sometimes it is important to discriminate between these kinds of types. </span><span class="sentence">Any given concrete type may be either a class or an interface type, but never both.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">We also distinguish between <em>denotable</em> and <em>non-denotable</em> types. </span><span class="sentence">The former are types which are expressible in Kotlin and can be written by the end-user. </span><span class="sentence">The latter are special types which are <em>not</em> expressible in Kotlin and are used internally by the compiler.</span></p>
</div>
<h4 id="built-in-types">Built-in types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin type system uses the following built-in types, which have special semantics and representation (or lack thereof).</span></p>
</div>
<h5 id="kotlin.any"><code>kotlin.Any</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{kotlin.Any}\)</span> is the unified <a href="#subtyping">supertype</a> (<span class="math inline">\(\top\)</span>) for <span class="math inline">\(\{T!!\}\)</span>, i.e., all non-nullable types are subtypes of <span class="math inline">\(\mathtt{kotlin.Any}\)</span>, either explicitly, implicitly, or by <a href="#subtyping">subtyping relation</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<span class="math inline">\(\mathtt{kotlin.Any}\)</span> members?)</span></p>
</div>
</div>
<h5 id="kotlin.nothing"><code>kotlin.Nothing</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{kotlin.Nothing}\)</span> is the unified <a href="#subtyping">subtype</a> (<span class="math inline">\(\bot\)</span>) for <span class="math inline">\(\{T\}\)</span>, i.e., <span class="math inline">\(\mathtt{kotlin.Nothing}\)</span> is a subtype of all well-formed Kotlin types, including user-defined ones. </span><span class="sentence">This makes it an uninhabited type (as it is impossible for anything to be, for example, a function and an integer at the same time), meaning instances of this type can never exist at runtime; subsequently, there is no way to create an instance of <span class="math inline">\(\mathtt{kotlin.Nothing}\)</span> in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As the evaluation of an expression with <span class="math inline">\(\mathtt{kotlin.Nothing}\)</span> type can never complete normally, it is used to mark special situations, such as</span></p>
</div>
<ul>
<li><span class="sentence">non-terminating expressions</span></li>
<li><span class="sentence">exceptional control flow</span></li>
<li><span class="sentence">control flow transfer</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Additional details about how <span class="math inline">\(\mathtt{kotlin.Nothing}\)</span> should be processed are available <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<h5 id="kotlin.unit"><code>kotlin.Unit</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{kotlin.Unit}\)</span> is a unit type, i.e., a type with only one value <span class="math inline">\(\mathtt{kotlin.Unit}\)</span>; all values of type <span class="math inline">\(\mathtt{kotlin.Unit}\)</span> should reference the same underlying <span class="math inline">\(\mathtt{kotlin.Unit}\)</span> object.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Compare to <code>void</code>?)</span></p>
</div>
</div>
<h5 id="kotlin.function"><code>kotlin.Function</code></h5>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{kotlin.Function}(R)\)</span> is the unified supertype of all <a href="#function-types">function types</a>. </span><span class="sentence">It is parameterized over function return type <code>R</code>.</span></p>
</div>
<h4 id="classifier-types">Classifier types</h4>
<div class="paragraph">
<p><span class="sentence">Classifier types represent regular types which are declared as [classes][Classes], [interfaces][Interfaces] or [objects][Objects]. </span><span class="sentence">As Kotlin supports <a href="#generics">generics</a>, there are two variants of classifier types: simple and parameterized.</span></p>
</div>
<h5 id="simple-classifier-types">Simple classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A simple classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed simple classifier type, <span class="math inline">\(T : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,m]: S_i\)</span> must be concrete, <a href="#nullable-types">non-nullable</a>, well-formed type</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// A well-formed type with no supertypes</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">interface</span> Base</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">// A well-formed type with a single supertype Base</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">interface</span> Derived : <span class="dt">Base</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">// <span class="dt">An</span> <span class="dt">ill</span>-<span class="dt">formed</span> <span class="dt">type</span>,</a>
<a class="sourceLine" id="cb1-8" title="8">// <span class="kw">as</span> nullable type cannot be a supertype</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">interface</span> Invalid : <span class="dt">Base</span>?</a></code></pre></div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for the purpose of different type system examples, we assume the presence of the following well-formed concrete types:</span></p>
</div>
<ul>
<li><span class="sentence">class <code>String</code></span></li>
<li><span class="sentence">interface <code>Number</code></span></li>
<li><span class="sentence">class <code>Int</code> &lt;: <code>Number</code></span></li>
<li><span class="sentence">class <code>Double</code> &lt;: <code>Number</code></span></li>
</ul>
</blockquote>
<h5 id="parameterized-classifier-types">Parameterized classifier types</h5>
<div class="paragraph">
<p><span class="sentence">A classifier type constructor</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T(F_1, \ldots, F_n) : S_1, \ldots, S_m\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">describes an abstract type and consists of</span></p>
</div>
<ul>
<li><span class="sentence">type name <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type parameters <span class="math inline">\(F_1, \ldots, F_n\)</span></span></li>
<li><span class="sentence">(optional) list of supertypes <span class="math inline">\(S_1, \ldots, S_m\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed type constructor, <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a valid type name</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: F_i\)</span> must be well-formed <a href="#type-parameters">type parameter</a></span></li>
<li><span class="sentence"><span class="math inline">\(\forall j \in [1,m]: S_j\)</span> must be concrete, <a href="#nullable-types">non-nullable</a>, well-formed type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To instantiate a type constructor, one provides it with type arguments, creating a concrete parameterized classifier type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[T[A_1, \ldots, A_n]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">which consists of</span></p>
</div>
<ul>
<li><span class="sentence">type constructor <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence">type arguments <span class="math inline">\(A_1, \ldots, A_n\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed parameterized type, <span class="math inline">\(T[A_1, \ldots, A_n]\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a well-formed type constructor with <span class="math inline">\(n\)</span> type parameters</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: A_i\)</span> must be well-formed concrete type</span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: K_T(F_i, A_i)\)</span> is a well-formed captured type, where <span class="math inline">\(K\)</span> is a <a href="#type-capturing">type capturing</a> operator</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// A well-formed PACT with no supertypes</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">// A and B are unbounded type parameters</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">interface</span> Generic&lt;<span class="dt">A</span>, <span class="dt">B</span>&gt;</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">// A well-formed PACT with a single iPACT supertype</a>
<a class="sourceLine" id="cb2-6" title="6">// Int and String are well-formed concrete types</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">interface</span> ConcreteDerived&lt;<span class="dt">P</span>, <span class="dt">Q</span>&gt; : <span class="dt">Generic</span>&lt;<span class="dt">Int</span>, <span class="dt">String</span>&gt;</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9">// <span class="dt">A</span> <span class="dt">well</span>-<span class="dt">formed</span> <span class="dt">PACT</span> <span class="dt">with</span> <span class="dt">a</span> <span class="dt">single</span> <span class="dt">iPACT</span> <span class="dt">supertype</span></a>
<a class="sourceLine" id="cb2-10" title="10">// <span class="dt">P</span> <span class="dt">and</span> <span class="dt">Q</span> <span class="dt">are</span> <span class="dt">type</span> <span class="dt">parameters</span> <span class="dt">of</span> <span class="dt">GenericDerived</span>,</a>
<a class="sourceLine" id="cb2-11" title="11">//   <span class="dt">used</span> <span class="kw">as</span> type arguments of Generic</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">interface</span> GenericDerived&lt;<span class="dt">P</span>, <span class="dt">Q</span>&gt; : <span class="dt">Generic</span>&lt;<span class="dt">P</span>, <span class="dt">Q</span>&gt;</a>
<a class="sourceLine" id="cb2-13" title="13"></a>
<a class="sourceLine" id="cb2-14" title="14">// <span class="dt">An</span> <span class="dt">ill</span>-<span class="dt">formed</span> <span class="dt">PACT</span>,</a>
<a class="sourceLine" id="cb2-15" title="15">//   <span class="kw">as</span> an abstract type Generic</a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">//   cannot be used as a supertype</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="kw">interface</span> Invalid&lt;<span class="dt">P</span>&gt; : <span class="dt">Generic</span></a>
<a class="sourceLine" id="cb2-18" title="18"></a>
<a class="sourceLine" id="cb2-19" title="19"></a>
<a class="sourceLine" id="cb2-20" title="20">// <span class="dt">A</span> <span class="dt">well</span>-<span class="dt">formed</span> <span class="dt">PACT</span> <span class="dt">with</span> <span class="dt">no</span> <span class="dt">supertypes</span></a>
<a class="sourceLine" id="cb2-21" title="21">// <span class="kw">out</span> A <span class="kw">is</span> a projected type parameter</a>
<a class="sourceLine" id="cb2-22" title="22"><span class="kw">interface</span> Out&lt;<span class="kw">out</span> <span class="dt">A</span>&gt;</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24"></a>
<a class="sourceLine" id="cb2-25" title="25">// A well-formed PACT with no supertypes</a>
<a class="sourceLine" id="cb2-26" title="26">// S : <span class="dt">Number</span> <span class="kw">is</span> a bounded type parameter</a>
<a class="sourceLine" id="cb2-27" title="27"><span class="co">// (S &lt;: Number)</span></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="kw">interface</span> NumberWrapper&lt;<span class="dt">S</span> : <span class="dt">Number</span>&gt;</a>
<a class="sourceLine" id="cb2-29" title="29"></a>
<a class="sourceLine" id="cb2-30" title="30">// A well-formed type with a single iPACT supertype</a>
<a class="sourceLine" id="cb2-31" title="31">// NumberWrapper&lt;<span class="dt">Int</span>&gt; <span class="kw">is</span> well-formed,</a>
<a class="sourceLine" id="cb2-32" title="32">//   <span class="kw">as</span> Int &lt;: <span class="dt">Number</span></a>
<a class="sourceLine" id="cb2-33" title="33"><span class="kw">interface</span> <span class="dt">IntWrapper</span> : <span class="dt">NumberWrapper</span>&lt;<span class="dt">Int</span>&gt;</a>
<a class="sourceLine" id="cb2-34" title="34"></a>
<a class="sourceLine" id="cb2-35" title="35">// <span class="dt">An</span> <span class="dt">ill</span>-<span class="dt">formed</span> <span class="dt">type</span>,</a>
<a class="sourceLine" id="cb2-36" title="36">//   <span class="kw">as</span> <span class="dt">NumberWrapper</span>&lt;<span class="dt">String</span>&gt; <span class="kw">is</span> <span class="dt">an</span> <span class="dt">ill</span>-<span class="dt">formed</span> <span class="dt">iPACT</span></a>
<a class="sourceLine" id="cb2-37" title="37">//   (<span class="dt">String</span> &lt;:&gt; <span class="dt">Number</span>)</a>
<a class="sourceLine" id="cb2-38" title="38"><span class="kw">interface</span> <span class="dt">InvalidWrapper</span> : <span class="dt">NumberWrapper</span>&lt;<span class="dt">String</span>&gt;</a></code></pre></div>
</blockquote>
<h4 id="type-parameters">Type parameters</h4>
<div class="paragraph">
<p><span class="sentence">Type parameters are a special kind of types, which are introduced by type constructors. </span><span class="sentence">They are considered well-formed concrete types only in the type context of their declaring type constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When creating a parameterized type from a type constructor, its type parameters with their respective type arguments go through <a href="#type-capturing">capturing</a> and create <em>captured</em> types, which follow special rules described in more detail below.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type parameters may be either unbounded or bounded. </span><span class="sentence">By default, a type parameter <span class="math inline">\(F\)</span> is unbounded, which is the same as saying it is a bounded type parameter of the form <span class="math inline">\(F &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A bounded type parameter additionally specify upper type bounds for the type parameter and is defined as <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span>, where <span class="math inline">\(B_i\)</span> is an i-th upper bound on type parameter <span class="math inline">\(F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed bounded type parameter of type constructor <span class="math inline">\(T\)</span>, <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> should satisfy either of the following sets of conditions.</span></p>
</div>
<ul>
<li><span class="sentence">Bounded type parameter with regular bounds:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall i \in [1,n]: B_i\)</span> must be concrete, non-type-parameter, well-formed type</span></li>
<li><span class="sentence">No more than one of <span class="math inline">\(B_i\)</span> may be a class type</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the last condition is a nod to the single inheritance nature of Kotlin; as any type may be a subtype of no more than one class type, it makes no sense to support several class type bounds. </span><span class="sentence">For any two class types, either these types are in a subtyping relation (and you should use the more specific type in the bounded type parameter), or they are unrelated (and the bounded type parameter is empty).</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">Bounded type parameter with type parameter bound:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(F\)</span> is a type parameter of PACT <span class="math inline">\(T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(i = 1\)</span> (i.e., there is a single upper bound)</span></li>
<li><span class="sentence"><span class="math inline">\(B_1\)</span> must be well-formed <a href="#type-parameters">type parameter</a></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">From the definition, it follows <span class="math inline">\(F &lt;: B_1, \ldots, B_n\)</span> can be represented as <span class="math inline">\(K &lt;: U\)</span> where <span class="math inline">\(U = B_1 \operatorname{\&amp;}\ldots \operatorname{\&amp;}B_n\)</span>.</span></p>
</div>
<h5 id="mixed-site-variance">Mixed-site variance</h5>
<div class="paragraph">
<p><span class="sentence">To implement subtyping between parameterized types, Kotlin uses <em>mixed-site variance</em> — a combination of declaration- and use-site variance, which is easier to understand and reason about, compared to wildcards from Java. </span><span class="sentence">Mixed-site variance means you can specify, whether you want your parameterized type to be co-, contra- or invariant on some type parameter, both in type parameter (declaration-site) and type argument (use-site).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Info: <em>variance</em> is a way of describing how <a href="#subtyping">subtyping</a> works for <em>variant</em> parameterized types. </span><span class="sentence">With declaration-site variance, for two types <span class="math inline">\(A &lt;: B\)</span>, subtyping between <code>T&lt;A&gt;</code> and <code>T&lt;B&gt;</code> depends on the variance of type parameter <span class="math inline">\(F\)</span> of some type constructor <span class="math inline">\(T\)</span>.</span></p>
</div>
<ul>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is covariant (<span class="math inline">\(\mathtt{out\ }F\)</span>), <code>T&lt;A&gt; &lt;: T&lt;B&gt;</code></span></li>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is contravariant(<span class="math inline">\(\mathtt{in\ }F\)</span>), <code>T&lt;A&gt; :&gt; T&lt;B&gt;</code></span></li>
<li><span class="sentence">if <span class="math inline">\(F\)</span> is invariant (default), <code>T&lt;A&gt; &lt;:&gt; T&lt;B&gt;</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Use-site variance allows the user to change the type variance of an <em>invariant</em> type parameter by specifying it on the corresponding type argument. </span><span class="sentence"><span class="math inline">\(\mathtt{out\ }A\)</span> means covariant type argument, <span class="math inline">\(\mathtt{in\ }A\)</span> means contravariant type argument; for two types <span class="math inline">\(A &lt;: B\)</span> and an invariant type parameter <span class="math inline">\(F\)</span> of some type constructor <span class="math inline">\(T\)</span>, subtyping for use-site variance has the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><code>T&lt;out A&gt; &lt;: T&lt;out B&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;in A&gt; :&gt; T&lt;in B&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;A&gt; &lt;: T&lt;out A&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;A&gt; &lt;: T&lt;in A&gt;</code></span></li>
<li><span class="sentence"><code>T&lt;in A&gt; &lt;:&gt; T&lt;out A&gt;</code></span></li>
</ul>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin does not support specifying both co- and contravariance at the same time, i.e., it is impossible to have <code>T&lt;in A out B&gt;</code> neither on declaration- nor on use-site.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For further discussion about mixed-site variance and its practical applications, we readdress you to <a href="#subtyping">subtyping</a> and <a href="#generics">generics</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Fix formatting here)</span></p>
</div>
</div>
<h5 id="declaration-site-variance">Declaration-site variance</h5>
<div class="paragraph">
<p><span class="sentence">A type parameter <span class="math inline">\(F\)</span> may be invariant, covariant or contravariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">By default, all type parameters are invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a covariant type parameter, it is marked as <span class="math inline">\(\mathtt{out\ }F\)</span>. </span><span class="sentence">To specify a contravariant type parameter, it is marked as <span class="math inline">\(\mathtt{in\ }F\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The variance information is used by <a href="#subtyping">subtyping</a> and for checking allowed operations on values of co- and contravariant type parameters.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: declaration-site variance can be used only when declaring types, e.g., type parameters of functions cannot be variant.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// A type constructor with an invariant type parameter</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">interface</span> Invariant&lt;<span class="dt">A</span>&gt;</a>
<a class="sourceLine" id="cb3-3" title="3">// A type <span class="kw">constructor</span> with a covariant type parameter</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">interface</span> Out&lt;<span class="kw">out</span> <span class="dt">A</span>&gt;</a>
<a class="sourceLine" id="cb3-5" title="5">// A type <span class="kw">constructor</span> with a contravariant type parameter</a>
<a class="sourceLine" id="cb3-6" title="6"><span class="kw">interface</span> In&lt;<span class="kw">in</span> <span class="dt">A</span>&gt;</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="kw">fun</span> testInvariant() {</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="kw">var</span> <span class="va">invInt</span>: Invariant&lt;<span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb3-10" title="10">    <span class="kw">var</span> <span class="va">invNumber</span>: Invariant&lt;Number&gt; = ...</a>
<a class="sourceLine" id="cb3-11" title="11">    </a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="cf">if</span> (random) invInt = invNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="cf">else</span> invNumber = invInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb3-14" title="14">    </a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="co">// Invariant type parameters do not create subtyping</span></a>
<a class="sourceLine" id="cb3-16" title="16">}</a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="kw">fun</span> <span class="fu">testOut</span>() {</a>
<a class="sourceLine" id="cb3-19" title="19">    <span class="kw">var</span> <span class="va">outInt</span>: Out&lt;<span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb3-20" title="20">    <span class="kw">var</span> <span class="va">outNumber</span>: Out&lt;Number&gt; = ...</a>
<a class="sourceLine" id="cb3-21" title="21">    </a>
<a class="sourceLine" id="cb3-22" title="22">    <span class="cf">if</span> (random) outInt = outNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="cf">else</span> outNumber = outInt <span class="co">// OK</span></a>
<a class="sourceLine" id="cb3-24" title="24">    </a>
<a class="sourceLine" id="cb3-25" title="25">    <span class="co">// Covariant type parameters create &quot;same-way&quot; subtyping</span></a>
<a class="sourceLine" id="cb3-26" title="26">    <span class="co">//   Int &lt;: Number =&gt; Out&lt;Int&gt; &lt;: Out&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb3-27" title="27">    <span class="co">// (more specific type Out&lt;Int&gt; can be assigned</span></a>
<a class="sourceLine" id="cb3-28" title="28">    <span class="co">//  to a less specific type Out&lt;Number&gt;)</span></a>
<a class="sourceLine" id="cb3-29" title="29">}</a>
<a class="sourceLine" id="cb3-30" title="30"></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="kw">fun</span> <span class="fu">testIn</span>() {</a>
<a class="sourceLine" id="cb3-32" title="32">    <span class="kw">var</span> <span class="va">inInt</span>: In&lt;<span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb3-33" title="33">    <span class="kw">var</span> <span class="va">inNumber</span>: In&lt;Number&gt; = ...</a>
<a class="sourceLine" id="cb3-34" title="34">    </a>
<a class="sourceLine" id="cb3-35" title="35">    <span class="cf">if</span> (random) inInt = inNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb3-36" title="36">    <span class="cf">else</span> inNumber = inInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb3-37" title="37">    </a>
<a class="sourceLine" id="cb3-38" title="38">    <span class="co">// Contravariant type parameters create &quot;opposite-way&quot; subtyping</span></a>
<a class="sourceLine" id="cb3-39" title="39">    <span class="co">//   Int &lt;: Number =&gt; In&lt;Int&gt; :&gt; In&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb3-40" title="40">    <span class="co">// (more specific type In&lt;Number&gt; can be assigned</span></a>
<a class="sourceLine" id="cb3-41" title="41">    <span class="co">//  to a less specific type In&lt;Int&gt;)</span></a>
<a class="sourceLine" id="cb3-42" title="42">}</a></code></pre></div>
</blockquote>
<h5 id="use-site-variance">Use-site variance</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports use-site variance, by specifying the variance for type arguments. </span><span class="sentence">Similarly to type parameters, one can have type arguments being co-, contra- or invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">By default, all type arguments are invariant.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a covariant type argument, it is marked as <span class="math inline">\(\mathtt{out\ }A\)</span>. </span><span class="sentence">To specify a contravariant type argument, it is marked as <span class="math inline">\(\mathtt{in\ }A\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in some cases, Kotlin prohibits certain combinations of declaration- and use-site variance, i.e., which type arguments can be used in which type parameters. </span><span class="sentence">These rules are covered in more detail [here][TODO()].</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In case one cannot specify any well-formed type argument, but still needs to use a parameterized type in a type-safe way, one may use <em>bivariant</em> type argument <span class="math inline">\(\star\)</span>, which is roughly equivalent to a combination of <span class="math inline">\(\mathtt{out\ }\mathtt{kotlin.Any?}\)</span> and <span class="math inline">\(\mathtt{in\ }\mathtt{kotlin.Nothing}\)</span> (for further details, see <a href="#subtyping">subtyping</a> and <a href="#generics">generics</a>).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Specify how this combination of co- and contravariant parameters works from the practical PoV)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: use-site variance cannot be used when declaring a supertype.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// A type constructor with an invariant type parameter</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">interface</span> Inv&lt;<span class="dt">A</span>&gt;</a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">fun</span> test() {</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="kw">var</span> <span class="va">invInt</span>: Inv&lt;<span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">var</span> <span class="va">invNumber</span>: Inv&lt;Number&gt; = ...</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="kw">var</span> <span class="va">outInt</span>: Inv&lt;<span class="kw">out</span> <span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">var</span> <span class="va">outNumber</span>: Inv&lt;<span class="kw">out</span> Number&gt; = ...</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">var</span> <span class="va">inInt</span>: Inv&lt;<span class="kw">in</span> <span class="kw">Int</span>&gt; = ...</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="kw">var</span> <span class="va">inNumber</span>: Inv&lt;<span class="kw">in</span> Number&gt; = ...</a>
<a class="sourceLine" id="cb4-11" title="11">    </a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="cf">when</span> (random) {</a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="dv">1</span> -&gt; {</a>
<a class="sourceLine" id="cb4-14" title="14">            inInt = invInt    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-15" title="15">            <span class="co">// T&lt;in Int&gt; :&gt; T&lt;Int&gt;</span></a>
<a class="sourceLine" id="cb4-16" title="16">            </a>
<a class="sourceLine" id="cb4-17" title="17">            inInt = invNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-18" title="18">            <span class="co">// T&lt;in Int&gt; :&gt; T&lt;in Number&gt; :&gt; T&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb4-19" title="19">        }</a>
<a class="sourceLine" id="cb4-20" title="20">        <span class="dv">2</span> -&gt; {</a>
<a class="sourceLine" id="cb4-21" title="21">            outNumber = invInt    <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-22" title="22">            <span class="co">// T&lt;out Number&gt; :&gt; T&lt;out Int&gt; :&gt; T&lt;Int&gt;</span></a>
<a class="sourceLine" id="cb4-23" title="23">            </a>
<a class="sourceLine" id="cb4-24" title="24">            outNumber = invNumber <span class="co">// OK</span></a>
<a class="sourceLine" id="cb4-25" title="25">            <span class="co">// T&lt;out Number&gt; :&gt; T&lt;Number&gt;</span></a>
<a class="sourceLine" id="cb4-26" title="26">        }</a>
<a class="sourceLine" id="cb4-27" title="27">        <span class="dv">3</span> -&gt; {</a>
<a class="sourceLine" id="cb4-28" title="28">            invInt = inInt  <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-29" title="29">            invInt = outInt <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-30" title="30">            <span class="co">// It is invalid to assign less specific type</span></a>
<a class="sourceLine" id="cb4-31" title="31">            <span class="co">// to a more specific one</span></a>
<a class="sourceLine" id="cb4-32" title="32">            <span class="co">//   T&lt;Int&gt; &lt;: T&lt;in Int&gt;</span></a>
<a class="sourceLine" id="cb4-33" title="33">            <span class="co">//   T&lt;Int&gt; &lt;: T&lt;out Int&gt;</span></a>
<a class="sourceLine" id="cb4-34" title="34">        }</a>
<a class="sourceLine" id="cb4-35" title="35">        <span class="dv">4</span> -&gt; {</a>
<a class="sourceLine" id="cb4-36" title="36">            inInt = outInt    <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-37" title="37">            inInt = outNumber <span class="co">// ERROR</span></a>
<a class="sourceLine" id="cb4-38" title="38">            <span class="co">// types with co- and contravariant type parameters</span></a>
<a class="sourceLine" id="cb4-39" title="39">            <span class="co">// are not connected by subtyping</span></a>
<a class="sourceLine" id="cb4-40" title="40">            <span class="co">//   T&lt;in Int&gt; &lt;:&gt; T&lt;out Int&gt;</span></a>
<a class="sourceLine" id="cb4-41" title="41">        }</a>
<a class="sourceLine" id="cb4-42" title="42">    }</a>
<a class="sourceLine" id="cb4-43" title="43">}</a></code></pre></div>
</blockquote>
<h4 id="type-capturing">Type capturing</h4>
<div class="paragraph">
<p><span class="sentence">Type capturing (similarly to Java capture conversion) is used when instantiating type constructors; it creates <em>abstract captured</em> types based on the type information of both type parameters and arguments, which present a unified view on the resulting types and simplifies further reasoning.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The reasoning behind type capturing is closely related to variant parameterized types being a form of <em>bounded existential types</em>; e.g., <code>A&lt;out T&gt;</code> may be loosely considered as the following existential type: <span class="math inline">\(\exists X : X &lt;: T . \mathtt{A&lt;X&gt;}\)</span>. </span><span class="sentence">Informally, a bounded existential type describes a <em>set</em> of possible types, which satisfy its bound constraints. </span><span class="sentence">Before such a type can be used, it needs to be <em>opened</em> (or <em>unpacked</em>): existentially quantified type variables are lifted to fresh type variables with corresponding bounds. </span><span class="sentence">We call these type variables <em>captured</em> types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For a given type constructor <span class="math inline">\(T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span>, its instance <span class="math inline">\(T[\sigma]\)</span> uses the following rules to create captured type <span class="math inline">\(K_i\)</span> from the type parameter <span class="math inline">\(F_i\)</span> and type argument <span class="math inline">\(A_i\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <strong>All</strong> applicable rules are used to create the resulting constraint set.</span></p>
</div>
</blockquote>
<ul>
<li><span class="sentence">For a covariant type parameter <span class="math inline">\(\mathtt{out\ }F_i\)</span>, if <span class="math inline">\(A_i\)</span> is an ill-formed type or a contravariant type argument, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i &lt;: A_i\)</span>.</span></li>
<li><span class="sentence">For a contravariant type parameter <span class="math inline">\(\mathtt{in\ }F_i\)</span>, if <span class="math inline">\(A_i\)</span> is an ill-formed type or a covariant type argument, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i :&gt; A_i\)</span>.</span></li>
<li><div class="paragraph">
<p><span class="sentence">For a bounded type parameter <span class="math inline">\(F_i &lt;: B_1, \ldots, B_m\)</span>, if <span class="math inline">\(\exists j \in [1,m]: \neg (A_i &lt;: B_j)\)</span>, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(\forall j \in [1,m]: K_i &lt;: \sigma B_j\)</span>.</span></p>
</div></li>
<li><span class="sentence">For a covariant type argument <span class="math inline">\(\mathtt{out\ }A_i\)</span>, if <span class="math inline">\(F_i\)</span> is a contravariant type parameter, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i &lt;: A_i\)</span>.</span></li>
<li><div class="paragraph">
<p><span class="sentence">For a contravariant type argument <span class="math inline">\(\mathtt{in\ }A_i\)</span>, if <span class="math inline">\(F_i\)</span> is a covariant type parameter, <span class="math inline">\(K_i\)</span> is an ill-formed type. </span><span class="sentence">Otherwise, <span class="math inline">\(K_i :&gt; A_i\)</span>.</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">For a bivariant type argument <span class="math inline">\(\star\)</span>, <span class="math inline">\(\mathtt{kotlin.Nothing}&lt;: K_i &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Otherwise, <span class="math inline">\(K_i \equiv A_i\)</span>.</span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">By construction, every captured type <span class="math inline">\(K\)</span> has the following form:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[\{L_1 &lt;: K, \ldots, L_p &lt;: K, K &lt;: U_1, \ldots, K &lt;: U_q\}\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">which can be represented as</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[L &lt;: K &lt;: U\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where <span class="math inline">\(L = L_1 | \ldots | L_p\)</span> and <span class="math inline">\(U = U_1 \operatorname{\&amp;}\ldots \operatorname{\&amp;}U_q\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as every captured type corresponds to a fresh type variable, two different captured types <span class="math inline">\(K_i\)</span> and <span class="math inline">\(K_j\)</span> which describe the same set of possible types (i.e., their constraint sets are equal) are <em>not</em> considered equal. </span><span class="sentence">However, in some cases <a href="#type-inference">type inference</a> may approximate a captured type <span class="math inline">\(K\)</span> to a concrete type <span class="math inline">\(K^{\approx}\)</span>; in our case, it would be that <span class="math inline">\(K_i^{\approx} \equiv K_j^{\approx}\)</span>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Need to think more about this part)</span></p>
</div>
</div>
<h4 id="function-types">Function types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin has first-order functions; e.g., it supports function types, which describe the argument and return types of its corresponding function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type FT</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FT(A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and may be considered the following instantiation of a special type constructor <span class="math inline">\(FunctionN(\mathtt{in\ }P_1, \ldots, \mathtt{in\ }P_n, \mathtt{out\ }RT)\)</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FT(A_1, \ldots, A_n) \rightarrow R \equiv FunctionN[A_1, \ldots, A_n, R]\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">These <span class="math inline">\(FunctionN\)</span> types follow the rules of regular type constructors and parameterized types w.r.t. subtyping.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A function type with receiver FTR</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FTR(TH, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">consists of</span></p>
</div>
<ul>
<li><span class="sentence">receiver type <span class="math inline">\(TH\)</span></span></li>
<li><span class="sentence">argument types <span class="math inline">\(A_i\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">From the type system’s point of view, it is equivalent to the following function type</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[FTR(TH, A_1, \ldots, A_n) \rightarrow R \equiv FT(TH, A_1, \ldots, A_n) \rightarrow R\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">i.e., receiver is considered as yet another argument of its function type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for example, these two types are equivalent</span></p>
</div>
<ul>
<li><span class="sentence"><code>Int.(Int) -&gt; String</code></span></li>
<li><span class="sentence"><code>(Int, Int) -&gt; String</code></span></li>
</ul>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Furthermore, all function types <span class="math inline">\(FunctionN\)</span> are subtypes of a general argument-agnostic type [<span class="math inline">\(\mathtt{kotlin.Function}\)</span>][kotlin.Function] for the purpose of unification.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: a compiler implementation may consider a function type <span class="math inline">\(FunctionN\)</span> to have additional supertypes, if it is necessary.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We already have <code>kotlin.Function</code> settled in this spec earlier. </span><span class="sentence">The reason for this is that overloading needs it)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// A function of type Function1&lt;Number, Number&gt;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">//   or (Number) -&gt; Number</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">i</span>: <span class="dt">Number</span>): <span class="dt">Number</span> = ...</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">// A valid assignment w.r.t. function type variance</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// Function1&lt;in Int, out Any&gt; :&gt; Function1&lt;in Number, out Number&gt;</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">val</span> <span class="va">fooRef</span>: (<span class="kw">Int</span>) -&gt; Any = ::foo</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">// A function with receiver of type Function1&lt;Number, Number&gt;</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">//   or Number.() -&gt; Number</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">fun</span> <span class="fu">Number</span>.<span class="fu">bar</span>(): <span class="dt">Number</span> = ...</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">// A valid assignment w.r.t. function type variance</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co">// Receiver is just yet another function argument</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co">// Function1&lt;in Int, out Any&gt; :&gt; Function1&lt;in Number, out Number&gt;</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="kw">val</span> <span class="va">barRef</span>: (<span class="kw">Int</span>) -&gt; Any = Number::bar</a></code></pre></div>
</blockquote>
<h4 id="array-types">Array types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin arrays are represented as a parameterized type <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span>, where <span class="math inline">\(T\)</span> is the type of the stored elements, which supports <code>get</code>/<code>set</code> operations. </span><span class="sentence">The <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> type follows the rules of regular type constructors and parameterized types w.r.t. subtyping.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike Java, arrays in Kotlin are declared as invariant. </span><span class="sentence">To use them in a co- or contravariant way, one should use <a href="#use-site-variance">use-site variance</a>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In addition to the general <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> type, Kotlin also has the following specialized array types:</span></p>
</div>
<ul>
<li><span class="sentence"><code>DoubleArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Double)\)</span>)</span></li>
<li><span class="sentence"><code>FloatArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Float)\)</span>)</span></li>
<li><span class="sentence"><code>LongArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Long)\)</span>)</span></li>
<li><span class="sentence"><code>IntArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Int)\)</span>)</span></li>
<li><span class="sentence"><code>ShortArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Short)\)</span>)</span></li>
<li><span class="sentence"><code>ByteArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Byte)\)</span>)</span></li>
<li><span class="sentence"><code>CharArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Char)\)</span>)</span></li>
<li><span class="sentence"><code>BooleanArray</code> (for <span class="math inline">\(\mathtt{kotlin.Array}(Boolean)\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These array types structurally match the corresponding <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> type; i.e., <code>IntArray</code> has the same methods and properties as <span class="math inline">\(\mathtt{kotlin.Array}(Int)\)</span>. </span><span class="sentence">However, they are <strong>not</strong> related by subtyping; meaning one cannot pass a <code>BooleanArray</code> argument to a function expecting an <span class="math inline">\(\mathtt{kotlin.Array}(Boolean)\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the presence of such specialized types allows the compiler to perform additional array-related optimizations.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><em>Array type specialization</em> <span class="math inline">\(\mathtt{ATS}(T)\)</span> is a transformation of a generic <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> type to a corresponding specialized version, which works as follows.</span></p>
</div>
<ul>
<li><span class="sentence">if <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> has a specialized version <code>TArray</code>, <span class="math inline">\(\mathtt{ATS}(\mathtt{kotlin.Array}(T)) = TArray\)</span></span></li>
<li><span class="sentence">if <span class="math inline">\(\mathtt{kotlin.Array}(T)\)</span> does not have a specialized version, <span class="math inline">\(\mathtt{ATS}(\mathtt{kotlin.Array}(T)) = \mathtt{kotlin.Array}(T)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{ATS}\)</span> takes an important part in how <a href="#variable-length-parameters">variable length parameters</a> are handled.</span></p>
</div>
<h4 id="flexible-types">Flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin, being a multi-platform language, needs to support transparent interoperability with platform-dependent code. </span><span class="sentence">However, this presents a problem in that some platforms may not support null safety the way Kotlin does. </span><span class="sentence">To deal with this, Kotlin supports <em>gradual typing</em> in the form of flexible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A flexible type represents a range of possible types between type <span class="math inline">\(L\)</span> (lower bound) and type <span class="math inline">\(U\)</span> (upper bound), written as <span class="math inline">\((L..U)\)</span>. </span><span class="sentence">One should note flexible types are <em>non-denotable</em>, i.e., one cannot explicitly declare a variable with flexible type, these types are created by the type system when needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed flexible type, <span class="math inline">\((L..U)\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are well-formed concrete types</span></li>
<li><span class="sentence"><span class="math inline">\(L &lt;: U\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\neg (L &lt;: U)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are <strong>not</strong> flexible types (but may contain other flexible types as some of their type arguments)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As the name suggests, flexible types are flexible — a value of type <span class="math inline">\((L..U)\)</span> can be used in any context, where one of the possible types between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> is needed (for more details, see <a href="#subtyping-for-flexible-types">subtyping rules for flexible types</a>). </span><span class="sentence">However, the actual type will be a specific type between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, thus making the substitution possibly unsafe, which is why Kotlin generates dynamic assertions, when it is impossible to prove statically the safety of flexible type use.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Details of assertion generation?)</span></p>
</div>
</div>
<h5 id="dynamic-type">Dynamic type</h5>
<div class="paragraph">
<p><span class="sentence">Kotlin includes a special <em>dynamic</em> type, which is a flexible type <span class="math inline">\((\mathtt{kotlin.Nothing}..\mathtt{kotlin.Any?})\)</span>. </span><span class="sentence">By definition, this type represents <em>any</em> possible Kotlin type, and may be used to support interoperability with dynamically typed libraries, platforms or languages.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We should reconsider defining <code>dynamic</code> as a flexible type, cause it doesn’t behave like one in many situations)</span></p>
</div>
</div>
<h5 id="platform-types">Platform types</h5>
<div class="paragraph">
<p><span class="sentence">The main use cases for flexible types are <em>platform types</em> — types which the Kotlin compiler uses, when interoperating with code written for another platform (e.g., Java). </span><span class="sentence">In this case all types on the interoperability boundary are subject to <em>flexibilization</em> — the process of converting a platform-specific type to a Kotlin-compatible flexible type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For further details on how <em>flexibilization</em> is done, see:</span></p>
</div>
<ul>
<li><span class="sentence">[Platform types for Java][TODO(need a way to have same section names in different parts of the spec)]</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: platform types should not be confused with <em>multi-platform projects</em> — another Kotlin feature targeted at supporting platform interop.</span></p>
</div>
</blockquote>
<h4 id="nullable-types">Nullable types</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports null safety by having two type universes — nullable and non-nullable. </span><span class="sentence">All classifier type declarations, built-in or user-defined, create non-nullable types, i.e., types which cannot hold <code>null</code> value at runtime.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">To specify a nullable version of type <span class="math inline">\(T\)</span>, one needs to use <span class="math inline">\(T?\)</span> as a type. </span><span class="sentence">Redundant nullability specifiers are ignored — <span class="math inline">\(T?? \equiv T?\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, question mark means “<span class="math inline">\(T?\)</span> may hold values of type <span class="math inline">\(T\)</span> or value <code>null</code>”</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">To represent a well-formed nullable type, <span class="math inline">\(T?\)</span> should satisfy the following conditions.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(T\)</span> is a well-formed concrete type</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If an operation is safe regardless of absence or presence of <code>null</code>, e.g., assignment of one nullable value to another, it can be used as-is for nullable types. </span><span class="sentence">For operations on <span class="math inline">\(T?\)</span> which may violate null safety, e.g., access to a property, one has the following null-safe options:</span></p>
</div>
<ol type="1">
<li><span class="sentence">Use safe operations</span>
<ul>
<li><span class="sentence"><a href="#navigation-operators">safe call</a></span></li>
</ul></li>
<li><span class="sentence">Downcast from <span class="math inline">\(T?\)</span> to <span class="math inline">\(T!!\)</span></span>
<ul>
<li><span class="sentence"><a href="#cast-expression">unsafe cast</a></span></li>
<li><span class="sentence"><a href="#type-checking-expression">type check</a> combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence">null check combined with <a href="#smart-casts">smart casts</a></span></li>
<li><span class="sentence"><a href="#not-null-assertion-expression">not-null assertion operator</a></span></li>
</ul></li>
<li><span class="sentence">Supply a default value to use if <code>null</code> is present</span>
<ul>
<li><span class="sentence"><a href="#elvis-operator-expression">elvis operator</a></span></li>
</ul></li>
</ol>
<h4 id="intersection-types">Intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types are special <em>non-denotable</em> types used to express the fact that a value belongs to <em>all</em> of <em>several</em> types at the same time.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Intersection type of two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is denoted <span class="math inline">\(A \operatorname{\&amp;}B\)</span> and is equivalent to the <a href="#greatest-lower-bound">greatest lower bound</a> of its components <span class="math inline">\(\mathtt{GLB}(A, B)\)</span>. </span><span class="sentence">Thus, the normalization procedure for <span class="math inline">\(\mathtt{GLB}\)</span> may be used to <em>normalize</em> an intersection type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means intersection types are commutative and associative (following the GLB properties); e.g., <span class="math inline">\(A \operatorname{\&amp;}B\)</span> is the same type as <span class="math inline">\(B \operatorname{\&amp;}A\)</span>, and <span class="math inline">\(A \operatorname{\&amp;}(B \operatorname{\&amp;}C)\)</span> is the same type as <span class="math inline">\(A \operatorname{\&amp;}B \operatorname{\&amp;}C\)</span>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for presentation purposes, we will henceforth order intersection type operands lexicographically based on their notation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">When needed, the compiler may <em>approximate</em> an intersection type to a <em>denotable concrete</em> type using <a href="#type-approximation">type approximation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">One of the main uses of intersection types are <a href="#smart-casts">smart casts</a>.</span></p>
</div>
<h4 id="integer-literal-types">Integer literal types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Think this through)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An integer literal type containing types <span class="math inline">\(T_1, \ldots, T_N\)</span>, denoted <span class="math inline">\(\mathtt{LTS}(T_1, \ldots, T_N)\)</span> is a special <em>non-denotable</em> type designed for integer literals. </span><span class="sentence">Each type <span class="math inline">\(T_1, \ldots, T_N\)</span> must be one of the <a href="#built-in-integer-types">built-in integer types</a></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Integer literal types are the types of <a href="#integer-literals">integer literals</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Consult with the team)</span></p>
</div>
</div>
<h4 id="union-types">Union types</h4>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: Kotlin does <strong>not</strong> have union types in its type system. </span><span class="sentence">However, they make reasoning about several type system features easier. </span><span class="sentence">Therefore, we decided to include a brief intro to the union types here.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Union types are special <em>non-denotable</em> types used to express the fact that a value belongs to <em>one</em> of <em>several</em> possible types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Union type of two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is denoted <span class="math inline">\(A | B\)</span> and is equivalent to the <a href="#least-upper-bound">least upper bound</a> of its components <span class="math inline">\(\mathtt{LUB}(A, B)\)</span>. </span><span class="sentence">Thus, the normalization procedure for <span class="math inline">\(\mathtt{LUB}\)</span> may be used to <em>normalize</em> a union type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Moreover, as union types are <em>not</em> used in Kotlin, the compiler always <em>decays</em> a union type to a <em>non-union</em> type using <a href="#type-approximation">type approximation</a>.</span></p>
</div>
<h3 id="type-context">Type context</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Type contexts and their relation to scopes) TODO(Inner vs nested type contexts)</span></p>
</div>
</div>
<h3 id="subtyping">Subtyping</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Need to change the way we think about subtyping)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin uses the classic notion of <em>subtyping</em> as <em>substitutability</em> — if <span class="math inline">\(S\)</span> is a subtype of <span class="math inline">\(T\)</span> (denoted as <span class="math inline">\(S &lt;: T\)</span>), values of type <span class="math inline">\(S\)</span> can be safely used where values of type <span class="math inline">\(T\)</span> are expected. </span><span class="sentence">The subtyping relation <span class="math inline">\(&lt;:\)</span> is:</span></p>
</div>
<ul>
<li><span class="sentence">reflexive (<span class="math inline">\(A &lt;: A\)</span>)</span></li>
<li><span class="sentence">transitive (<span class="math inline">\(A &lt;: B \land B &lt;: C \Rightarrow A &lt;: C\)</span>)</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are <em>equivalent</em> (<span class="math inline">\(A \equiv B\)</span>), iff <span class="math inline">\(A &lt;: B \land B &lt;: A\)</span>. </span><span class="sentence">Due to the presence of flexible types, this relation is <strong>not</strong> transitive (see <a href="#subtyping-for-flexible-types">here</a> for more details).</span></p>
</div>
<h4 id="subtyping-rules">Subtyping rules</h4>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, concrete types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \mathtt{kotlin.Nothing}&lt;: T &lt;: \mathtt{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any simple classifier type <span class="math inline">\(T : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: T &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any parameterized type <span class="math inline">\(\widehat{T} = T[\sigma]: S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: \sigma S_i\)</span></span></li>
<li><span class="sentence">For any two parameterized types <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with captured type arguments <span class="math inline">\(K_i\)</span> and <span class="math inline">\(K_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: K_i &lt;: K_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for non-nullable, abstract types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall T : \mathtt{kotlin.Nothing}&lt;: T &lt;: \mathtt{kotlin.Any}\)</span></span></li>
<li><span class="sentence">For any type constructor <span class="math inline">\(\widehat{T} = T(F_1, \ldots, F_n) : S_1, \ldots, S_m\)</span> it is true that <span class="math inline">\(\forall i \in [1,m]: \widehat{T} &lt;: S_i\)</span></span></li>
<li><span class="sentence">For any two type constructors <span class="math inline">\(\widehat{T}\)</span> and <span class="math inline">\(\widehat{T^\prime}\)</span> with type parameters <span class="math inline">\(F_i\)</span> and <span class="math inline">\(F_i^\prime\)</span> it is true that <span class="math inline">\(\widehat{T} &lt;: \widehat{T^\prime}\)</span> if <span class="math inline">\(\forall i \in [1,n]: F_i &lt;: F_i^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for type parameters uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall F : \mathtt{kotlin.Nothing}&lt;: F &lt;: \mathtt{kotlin.Any?}\)</span></span></li>
<li><span class="sentence">For any two type parameters <span class="math inline">\(F\)</span> and <span class="math inline">\(F^\prime\)</span>, it is true that <span class="math inline">\(F &lt;: F^\prime\)</span>, if all of the following hold</span>
<ul>
<li><span class="sentence">variance of <span class="math inline">\(F\)</span> matches variance of <span class="math inline">\(F^\prime\)</span></span>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{out\ }\)</span> matches <span class="math inline">\(\mathtt{out\ }\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{in\ }\)</span> matches <span class="math inline">\(\mathtt{in\ }\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{inv\ }\)</span> matches any variance</span></li>
</ul></li>
<li><span class="sentence">for <span class="math inline">\(F &lt;: B\)</span> and <span class="math inline">\(F^\prime &lt;: B^\prime\)</span>, <span class="math inline">\(B &lt;: B^\prime\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for captured types uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\forall K : \text{kotlin.Nothing} &lt;: K &lt;: \text{kotlin.Any?}\)</span></span></li>
<li><span class="sentence">For any two captured types <span class="math inline">\(L &lt;: K &lt;: U\)</span> and <span class="math inline">\(L^\prime &lt;: K^\prime &lt;: U^\prime\)</span>, it is true that <span class="math inline">\(K &lt;: K^\prime\)</span> if <span class="math inline">\(L^\prime &lt;: L\)</span> and <span class="math inline">\(U &lt;: U^\prime\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping for nullable types is checked separately and uses a special set of rules which are described <a href="#subtyping-for-nullable-types">here</a>.</span></p>
</div>
<h4 id="subtyping-for-flexible-types">Subtyping for flexible types</h4>
<div class="paragraph">
<p><span class="sentence">Flexible types (being flexible) follow a simple subtyping relation with other inflexible types. </span><span class="sentence">Let <span class="math inline">\(T, A, B, L, U\)</span> be inflexible types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: T \Rightarrow (L..U) &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(T &lt;: U \Rightarrow T &lt;: (L..U)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This captures the notion of flexible type <span class="math inline">\((L..U)\)</span> as something which may be used in place of any type in between <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>. </span><span class="sentence">If we are to extend this idea to subtyping between <em>two</em> flexible types, we get the following definition.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(L &lt;: B \Rightarrow (L..U) &lt;: (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">This is the most extensive definition possible, which, unfortunately, makes the type equivalence relation non-transitive. </span><span class="sentence">Let <span class="math inline">\(A, B\)</span> be two <em>different</em> types, for which <span class="math inline">\(A &lt;: B\)</span>. </span><span class="sentence">The following relations hold:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: (A..B) \land (A..B) &lt;: A \Rightarrow A \equiv (A..B)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: (A..B) \land (A..B) &lt;: B \Rightarrow B \equiv (A..B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, <span class="math inline">\(A \not \equiv B\)</span>.</span></p>
</div>
<h4 id="subtyping-for-intersection-types">Subtyping for intersection types</h4>
<div class="paragraph">
<p><span class="sentence">Intersection types introduce several new rules for subtyping. </span><span class="sentence">Let <span class="math inline">\(A, B, C, D\)</span> be non-nullable types.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A \operatorname{\&amp;}B &lt;: A\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \operatorname{\&amp;}B &lt;: B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A &lt;: C \land B &lt;: D \Rightarrow A \operatorname{\&amp;}B &lt;: C \operatorname{\&amp;}D\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Moreover, any type <span class="math inline">\(T\)</span> with supertypes <span class="math inline">\(S_1, \ldots, S_N\)</span> is also a subtype of <span class="math inline">\(S_1 \operatorname{\&amp;}\ldots \operatorname{\&amp;}S_N\)</span>.</span></p>
</div>
<h4 id="subtyping-for-integer-literal-types">Subtyping for integer literal types</h4>
<div class="paragraph">
<p><span class="sentence">Every integer literal type is equivalent with w.r.t. subtyping, meaning that for any sets <span class="math inline">\(T_1, \ldots, T_K\)</span> and <span class="math inline">\(U_1, \ldots, U_N\)</span> of builtin integer types:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{LTS}(T_1, \ldots, T_K) &lt;: \mathtt{LTS}(U_1, \ldots, U_N)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{LTS}(U_1, \ldots, U_K) &lt;: \mathtt{LTS}(T_1, \ldots, T_K)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall T_i \in \{T_1, \ldots, T_K\} \ldotp T_i &lt;: \mathtt{LTS}(T_1, \ldots, T_K)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\forall T_i \in \{T_1, \ldots, T_K\} \ldotp \mathtt{LTS}(T_1, \ldots, T_K) &lt;: T_i\)</span></span></li>
</ul>
<h4 id="subtyping-for-nullable-types">Subtyping for nullable types</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Why can’t we just say that <span class="math inline">\(\forall T : T &lt;: T?\)</span> and <span class="math inline">\(\forall T : T!! &lt;: T\)</span> and be done with it?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Subtyping for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is defined via <em>two</em> relations, both of which must hold.</span></p>
</div>
<ul>
<li><span class="sentence">Regular subtyping <span class="math inline">\(&lt;:\)</span> for non-nullable types <span class="math inline">\(A!!\)</span> and <span class="math inline">\(B!!\)</span></span></li>
<li><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Subtyping by nullability <span class="math inline">\(\stackrel{null}{&lt;:}\)</span> for two possibly nullable types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> uses the following rules.</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A!! \stackrel{null}{&lt;:}B\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\exists T!! : A &lt;: T!!\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B?\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \stackrel{null}{&lt;:}B\)</span> if <span class="math inline">\(\not \exists T!! : B &lt;: T!!\)</span></span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How the existence check works)</span></p>
</div>
</div>
<h3 id="generics">Generics</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(How are generics different from type parameters? </span><span class="sentence">Or are we going to get into deep technical detail?)</span></p>
</div>
</div>
<h3 id="upper-and-lower-bounds">Upper and lower bounds</h3>
<div class="paragraph">
<p><span class="sentence">A type <span class="math inline">\(U\)</span> is an <em>upper bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(A &lt;: U\)</span> and <span class="math inline">\(B &lt;: U\)</span>. </span><span class="sentence">A type <span class="math inline">\(L\)</span> is a <em>lower bound</em> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> if <span class="math inline">\(L &lt;: A\)</span> and <span class="math inline">\(L &lt;: B\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the type system of Kotlin is bounded by definition (the upper bound of all types is <span class="math inline">\(\mathtt{kotlin.Any?}\)</span>, and the lower bound of all types is <span class="math inline">\(\mathtt{kotlin.Nothing}\)</span>), any two types have at least one lower bound and at least one upper bound.</span></p>
</div>
</blockquote>
<h4 id="least-upper-bound">Least upper bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>least upper bound</em> <span class="math inline">\(\mathtt{LUB}(A, B)\)</span> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is an upper bound <span class="math inline">\(U\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other upper bound of these types which is less by subtyping relation than <span class="math inline">\(U\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <span class="math inline">\(\mathtt{LUB}\)</span> is commutative, i.e., <span class="math inline">\(\mathtt{LUB}(A, B) = \mathtt{LUB}(B, A)\)</span>. </span><span class="sentence">This property is used in the subsequent description, e.g., other properties of <span class="math inline">\(\mathtt{LUB}\)</span> are defined only for a specific order of the arguments. </span><span class="sentence">Definitions following from commutativity of <span class="math inline">\(\mathtt{LUB}\)</span> are implied.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{LUB}(A, B)\)</span> has the following properties, which may be used to <em>normalize</em> it. </span><span class="sentence">This normalization procedure, if finite, creates a <em>canonical</em> representation of LUB.</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{LUB}(A, A) = A\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A &lt;: B\)</span>, <span class="math inline">\(\mathtt{LUB}(A, B) = B\)</span></span></p>
</div></li>
<li><span class="sentence">if <span class="math inline">\(A\)</span> is nullable, <span class="math inline">\(\mathtt{LUB}(A, B)\)</span> is also nullable</span></li>
<li><span class="sentence">if both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are nullable, <span class="math inline">\(\mathtt{LUB}(A, B) = \mathtt{LUB}(A!!, B!!)?\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A\)</span> is nullable and <span class="math inline">\(B\)</span> is not, <span class="math inline">\(\mathtt{LUB}(A, B) = \mathtt{LUB}(A!!, B)?\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = T\langle K_{A,1}, \ldots, K_{A,n}\rangle\)</span> and <span class="math inline">\(B = T\langle K_{B,1}, \ldots, K_{B,n}\rangle\)</span>, <span class="math inline">\(\mathtt{LUB}(A, B) = T\langle \phi(K_{A,1}, K_{B,1}), \ldots, \phi(K_{A,n}, K_{B,n})\rangle\)</span>, where <span class="math inline">\(\phi(X, Y)\)</span> is defined as follows:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{inv\ }X) = X\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{out\ }Y) = \mathtt{out\ }\mathtt{LUB}(X, Y)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{in\ }Y) = \star\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{out\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{in\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }\mathtt{kotlin.Any?}) = \mathtt{out\ }\mathtt{kotlin.Any?}\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{out\ }Y) = \star\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }\mathtt{kotlin.Any?}, \mathtt{out\ }Y) = \mathtt{out\ }\mathtt{kotlin.Any?}\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{in\ }Y) = \mathtt{in\ }\mathtt{GLB}(X, Y)\)</span></span></p>
</div></li>
<li><div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(we may also choose the <code>in</code> projection for <code>inv</code> parameters, do we wanna do it though?)</span></p>
</div>
</div></li>
</ul></li>
<li><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B = (L_B..U_B)\)</span>, <span class="math inline">\(\mathtt{LUB}(A, B) = (\mathtt{LUB}(L_A, L_B)..\mathtt{LUB}(U_A, U_B))\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B\)</span> is not flexible, <span class="math inline">\(\mathtt{LUB}(A, B) = (\mathtt{LUB}(L_A, B)..\mathtt{LUB}(U_A, B))\)</span></span></p>
</div></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(prettify formatting)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(actual algorithm for computing LUB)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(LUB for 3+ types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(what do we do if this procedure loops?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Why do we need union types again?)</span></p>
</div>
</div>
<h4 id="greatest-lower-bound">Greatest lower bound</h4>
<div class="paragraph">
<p><span class="sentence">The <em>greatest lower bound</em> <span class="math inline">\(\mathtt{GLB}(A, B)\)</span> of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is a lower bound <span class="math inline">\(L\)</span> of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> such that there is no other lower bound of these types which is greater by subtyping relation than <span class="math inline">\(L\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: enumerating all subtypes of a given type is impossible in general, but in the presence of <a href="#intersection-types">intersection types</a>, <span class="math inline">\(GLB(A, B) \equiv A \operatorname{\&amp;}B\)</span>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(It’s not if types are related)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <span class="math inline">\(\mathtt{GLB}\)</span> is commutative, i.e., <span class="math inline">\(\mathtt{GLB}(A, B) = \mathtt{GLB}(B, A)\)</span>. </span><span class="sentence">This property is used in the subsequent description, e.g., other properties of <span class="math inline">\(\mathtt{GLB}\)</span> are defined only for a specific order of the arguments. </span><span class="sentence">Definitions following from commutativity of <span class="math inline">\(\mathtt{GLB}\)</span> are implied.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{GLB}(A, B)\)</span> has the following properties, which may be used to <em>normalize</em> it. </span><span class="sentence">This normalization procedure, if finite, creates a <em>canonical</em> representation of GLB.</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\mathtt{GLB}(A, A) = A\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A &lt;: B\)</span>, <span class="math inline">\(\mathtt{GLB}(A, B) = A\)</span></span></p>
</div></li>
<li><span class="sentence">if <span class="math inline">\(A\)</span> is non-nullable, <span class="math inline">\(\mathtt{GLB}(A, B)\)</span> is also non-nullable</span></li>
<li><span class="sentence">if both <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are nullable, <span class="math inline">\(\mathtt{GLB}(A, B) = \mathtt{GLB}(A!!, B!!)?\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A\)</span> is nullable and <span class="math inline">\(B\)</span> is not, <span class="math inline">\(\mathtt{GLB}(A, B) = \mathtt{GLB}(A!!, B)\)</span></span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = T\langle K_{A,1}, \ldots, K_{A,n}\rangle\)</span> and <span class="math inline">\(B = T\langle K_{B,1}, \ldots, K_{B,n}\rangle\)</span>, <span class="math inline">\(\mathtt{GLB}(A, B) = T\langle \phi(K_{A,1}, K_{B,1}), \ldots, \phi(K_{A,n}, K_{B,n})\rangle\)</span>, where <span class="math inline">\(\phi(X, Y)\)</span> is defined as follows:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{inv\ }X) = X\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{out\ }Y) = \mathtt{out\ }\mathtt{GLB}(X, Y)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{out\ }X, \mathtt{in\ }Y) = \star\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{out\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }Y)\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi(\mathtt{inv\ }X, \mathtt{in\ }Y) = \phi(\mathtt{out\ }X, \mathtt{out\ }\mathtt{kotlin.Any?}) = \mathtt{out\ }\mathtt{kotlin.Any?}\)</span></span></p>
</div></li>
<li><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{out\ }Y) = \star\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{inv\ }Y) = \phi(\mathtt{out\ }\mathtt{kotlin.Any?}, \mathtt{out\ }Y) = \mathtt{out\ }\mathtt{kotlin.Any?}\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence"><span class="math inline">\(\phi( \mathtt{in\ }X, \mathtt{in\ }Y) = \mathtt{in\ }\mathtt{LUB}(X, Y)\)</span></span></p>
</div></li>
<li><div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(we may also choose the <code>in</code> projection for <code>inv</code> parameters, do we wanna do it though?)</span></p>
</div>
</div></li>
</ul></li>
<li><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B = (L_B..U_B)\)</span>, <span class="math inline">\(\mathtt{GLB}(A, B) = (\mathtt{GLB}(L_A, L_B)..\mathtt{GLB}(U_A, U_B))\)</span></span></li>
<li><div class="paragraph">
<p><span class="sentence">if <span class="math inline">\(A = (L_A..U_A)\)</span> and <span class="math inline">\(B\)</span> is not flexible, <span class="math inline">\(\mathtt{GLB}(A, B) = (\mathtt{GLB}(L_A, B)..\mathtt{GLB}(U_A, B))\)</span></span></p>
</div></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(prettify formatting)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(actual algorithm for computing GLB)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(GLB for 3+ types)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(what do we do if this procedure loops?)</span></p>
</div>
</div>
<h3 id="type-approximation">Type approximation</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="references">References</h3>
<ol type="1">
<li><span class="sentence">Ross Tate. </span><span class="sentence">“Mixed-site variance.” FOOL, 2013.</span></li>
<li><span class="sentence">Ross Tate, Alan Leung, and Sorin Lerner. </span><span class="sentence">“Taming wildcards in Java’s type system.” PLDI, 2011.</span></li>
</ol>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(the big TODO for the whole chapter: we need to clearly decide what kind of type system we want to specify: an algo-driven ts vs a full declarational ts, operation-based or relation-based. </span><span class="sentence">An example of the second distinction would be difference between <span class="math inline">\((A?)!!\)</span> and <span class="math inline">\(((A!!)?)!!\)</span>. </span><span class="sentence">Are they the same type? </span><span class="sentence">Are they different, but equivalent? </span><span class="sentence">Same goes for <span class="math inline">\((A..B)?\)</span> vs <span class="math inline">\((A?..B?)\)</span> and such.)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(another big question is: do we want to formally prove all the different thing here?)</span></p>
</div>
</div>
<h2 id="built-in-classifier-types">Built-in classifier types</h2>
<ul>
<li><div class="TODO">
<span class="sentence">TODO: Move the whole section to type system?</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: Move <code>kotlin.Unit</code> here?</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: <code>Appendable</code>/<code>StringBuilder</code>? </span><span class="sentence">depends on how we plan to approach the interpolation expansion</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO: <code>{Builtin}Array</code> types?</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">As well as the types defined in the <a href="#built-in-types">type system section</a>, Kotlin defines several built-in classifier types that are important for the rest of this document. </span><span class="sentence">These have their own declarations in the standard library, but have special semantics in Kotlin.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this is not meant to declare all the types available in the standard library, for this please refer to the standard library documentation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>.</span></p>
</div>
</blockquote>
<h3 id="kotlin.boolean"><code>kotlin.Boolean</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Boolean</code> is the boolean logic type of Kotlin, representing the value that may be either <code>true</code> or <code>false</code>. </span><span class="sentence">It is the type of <a href="#boolean-literals">boolean literals</a> as well as the type returned or expected by some built-in Kotlin operators. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<h3 id="built-in-integer-types">Built-in integer types</h3>
<div class="paragraph">
<p><span class="sentence">There are several built-in class types that represent signed integer numbers of different bit size. </span><span class="sentence">Kotlin does not have a built-in infinite-length integer number class. </span><span class="sentence">Kotlin also does not currently define any built-in unsigned integer number types <span><span class="TODO">(TODO: Kotlin 1.3 does)</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">The signed integer number types are:</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin.Int</code></span></li>
<li><span class="sentence"><code>kotlin.Short</code></span></li>
<li><span class="sentence"><code>kotlin.Byte</code></span></li>
<li><span class="sentence"><code>kotlin.Long</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These types may or may not have different runtime representation. </span><span class="sentence">See your platform reference for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Int</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^{31}\)</span> to <span class="math inline">\(2^{31} - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Int</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Short</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^{15}\)</span> to <span class="math inline">\(2^{15} - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Short</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Byte</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^{7}\)</span> to <span class="math inline">\(2^{7} - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Byte</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Long</code> is the type of integer numbers that is required to be able to hold at least the values in the range from <span class="math inline">\(-2^{63}\)</span> to <span class="math inline">\(2^{63} - 1\)</span>. </span><span class="sentence">If an arithmetic operation on <code>kotlin.Long</code> results in arithmetic overflow or underflow, the result is undefined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For other traits of these types (such as the classes they inherit from, interfaces they may inherit from and their member functions) please refer to the standard library specification.</span></p>
</div>
<h3 id="built-in-floating-point-arithmetic-types">Built-in floating point arithmetic types</h3>
<div class="paragraph">
<p><span class="sentence">There are two built-in class types that represent floating-point numbers: <code>kotlin.Float</code> and <code>kotlin.Double</code>. </span><span class="sentence">These types may or may not have different runtime representations. </span><span class="sentence">See your platform reference for details.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Float</code> is the type of floating-point number that is able to contain all the numbers as a IEEE754 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> single-precision binary floating number with the same precision. </span><span class="sentence"><code>kotlin.Double</code> is the type of floating-point number that is able to contain all the numbers as a IEEE754 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> double-precision binary floating number with the same precision.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: or do they?</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Platform specification may give a more thorough information on how these types are represented on a particular platform. </span><span class="sentence">For other traits of these types (such as the classes they inherit from, interfaces they may inherit from and their member functions) please refer to the standard library specification.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: FP semantics are pretty hard, how much of that we want to put here?</span></p>
</div>
</div>
<h3 id="kotlin.char"><code>kotlin.Char</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.Char</code> is the built-in class type that represents a single unicode symbol in UTF-16 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> character encoding. </span><span class="sentence">It is the type of <a href="#character-literals">character literals</a>. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: UTF-16 or UCS-2?</span></p>
</div>
</div>
<h3 id="kotlin.string"><code>kotlin.String</code></h3>
<div class="paragraph">
<p><span class="sentence"><code>kotlin.String</code> is the built-in class type that represents a sequence of unicode symbol in UTF-16 <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> character encoding. </span><span class="sentence">It is the type of the result of <a href="#string-interpolation-expressions">string interpolation</a>. </span><span class="sentence">For other traits of this type (such as the classes it inherits from, interfaces it may inherit from and its member functions) please refer to the standard library specification.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: UTF-16 or UCS-2?</span></p>
</div>
</div>
<h2 id="runtime-type-information">Runtime type information</h2>
<div class="paragraph">
<p><span class="sentence">The <em>runtime type information</em> (RTTI) is the information about Kotlin types of values available from these values at runtime. </span><span class="sentence">RTTI affects the semantics of certain expressions, changing their evaluation depending on the amount of RTTI available for particular values, implementation, and platform:</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#type-checking-expression">The type checking operator</a></span></li>
<li><span class="sentence"><a href="#cast-expression">The cast expression</a>, expecially the <code>as?</code> operator</span></li>
<li><span class="sentence">[Class literals][class literal] and the values they evaluate to</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><em>Runtime types</em> are particular instances of RTTI for a particular value at runtime. </span><span class="sentence">These model a subset of the Kotlin <a href="#type-system">type system</a>. </span><span class="sentence">Namely, the runtime types are limited to <a href="#classifier-types">classifier types</a>, <a href="#function-types">function types</a> and a special case of <code>kotlin.Nothing?</code> which is the type of <a href="#null-literal"><code>null</code> reference</a> and the only nullable runtime type. </span><span class="sentence">This includes the classifier types created by <a href="#object-literals">anonymous object literals</a>. </span><span class="sentence">There is a slight distinction between a Kotlin type system type and its runtime counterpart:</span></p>
</div>
<ul>
<li><span class="sentence">On some platforms, some particular types may have the same runtime type representation. </span><span class="sentence">This means that checking or casting values of these types works the same way as if they were the same type</span></li>
<li><span class="sentence">Generic types with the same classifier are not required to have different runtime representations. </span><span class="sentence">One cannot generally rely on them having the same representation outside of a particular platform. </span><span class="sentence">Platform specifications must clarify whether some or all types on these platforms have this feature.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">RTTI is also the source of information for platform-specific <em>reflection</em> facilities in the standard library.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The types actual values may have are limited to <a href="#classifier-types">class and object types</a> and <a href="#function-types">function types</a> as well as <code>kotlin.Nothing?</code> for the <code>null</code> reference. </span><span class="sentence"><code>kotlin.Nothing</code> (not to be confused with its nullable variant <code>kotlin.Nothing?</code>) is special in the way that this type is never encountered as a runtime type even though it may have a platform-specific representation. </span><span class="sentence">The reason for this is that this type is used to signify non-existent values.</span></p>
</div>
<h3 id="runtime-available-types">Runtime-available types</h3>
<div class="paragraph">
<p><span class="sentence"><em>Runtime-available types</em> are the types that can be guaranteed (during compilation) to have a concrete <em>runtime</em> counterpart. </span><span class="sentence">These include all the runtime types, their nullable variants as well as [<code>reified</code> type parameters][Reified type parameters], that are guaranteed to inline to a runtime type during type parameter substitution. </span><span class="sentence">Only runtime-available types may be passed (implicitly or explicitly) as substitutions to reified type paramters, used for type checks and safe casts. </span><span class="sentence">During these operations, the nullability of the type is checked using reference-equality to <code>null</code>, while the rest is performed by accessing the runtime type of a value and comparing it to the supplied runtime-available type.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For all generic types that are not expected to have RTTI for their generic arguments, only “raw” variants of generic types (denoted in code using the star-projected type notation or a special parameter-less notation <span><span class="TODO">(TODO: link?)</span><span class="TODO-marker">*</span></span>) are runtime-available.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may say that classifier generics are <em>partially</em> runtime available due to them having information about only the classifier part of the type</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><a href="#exceptions">Exception types</a> must be runtime-available to enable type checks that the <code>catch</code> clause of <a href="#try-expression"><code>try</code>-expression</a> performs.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Only non-nullable runtime types may be used in <code>class</code> literal expressions. </span><span class="sentence">These include reified type parameters with non-nullable upper bounds, as well as all classifier and function types.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Anything else?)</span></p>
</div>
</div>
<h2 id="scopes-and-identifiers">Scopes and identifiers</h2>
<div class="paragraph">
<p><span class="sentence">All the program code in Kotlin is logically divided into <em>scopes</em>. </span><span class="sentence">A scope is a syntactically-delimited region of code that constitutes a context in which entities and their names can be introduced. </span><span class="sentence">Scopes are nested, with entities introduced in outer scopes also available in the inner scopes. </span><span class="sentence">The top level of a Kotlin file is also a scope, containing all the scopes within the file.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All the scopes are divided into two categories: declaration scopes and statement scopes. </span><span class="sentence">These two kinds of scopes differ in how the identifiers in code refer to the values definied in the scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Declaration scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a normal Kotlin file (not script file);</span></li>
<li><span class="sentence">The bodies of <a href="#classifier-declaration">classifier declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#object-literals">object literals</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Statement scopes include:</span></p>
</div>
<ul>
<li><span class="sentence">The top level scope of a Kotlin script file;</span></li>
<li><span class="sentence">Various scopes produced by control structure bodies of different <a href="#expressions">expressions</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#function-declaration">function declarations</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#anonymous-function-declarations">anonymous function literals</a>;</span></li>
<li><span class="sentence">The bodies of getters and setters of <a href="#property-declaration">properties</a>;</span></li>
<li><span class="sentence">The bodies of <a href="#constructor-declaration">constructors</a>;</span></li>
<li><span class="sentence">The bodies of instance initialization blocks in <a href="#class-declaration">class declarations</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">All the declarations in a particular scope introduce new <em>bindings</em> of identifiers in this scope to their respective entities in the program. </span><span class="sentence">These entities may be types or values, where values may refer to objects, functions or properties (that may be delegated). </span><span class="sentence">Top-level scopes additionally allow to introduce such bindings using <a href="#packages-and-imports"><code>import</code> directive</a> from other top-level scopes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In most situations, it is not allowed to bind several values to the same identifier in the same scope, but it is allowed to bind a value to an identifier already available in the scope through outer scopes or imports. </span><span class="sentence">An exception to this rule are function declarations, that, in addition to identifier bound to, also may differ by signature <span><span class="TODO">(TODO: what’s a signature?)</span><span class="TODO-marker">*</span></span> and allow definining several functions with the same name in the same scope. </span><span class="sentence">When <a href="#call-and-property-access-expressions">calling functions</a> a process called <a href="#overload-resolution">overloading resolution</a> takes places that allows differentiating such functions. </span><span class="sentence">Overloading resolution also applies to properties if they are used as functions through <code>invoke</code>-convention, but it does not mean several properties with the same name may be defined in the same scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between declaration scopes and statement scopes is that names in the statement scope are bound in the order their declarations appear in it. </span><span class="sentence">It is not allowed to access a value through an identifier in the code that (syntactically) precedes the binding itself. </span><span class="sentence">On the contrary, in declaration scopes it is fully allowed, although initialization cycles may occur and need to be detected by the compiler. </span><span class="sentence">It also means that the statement scopes nested inside declaration scopes may access values declared after itself in the declaration scopes, but any values defined inside the statement scope must be accessed only after they are declared.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">In declaration scope:</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1">    <span class="co">// x refers to the property defined below even if there is another property</span></a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="co">// called x in outer scope or imported</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">In statement scope:</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb7-1" title="1">    <span class="co">// x either refers to other property defined in some outer scope or imported</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="co">// or it is a compile-time error</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">fun</span> <span class="fu">foo</span>() { <span class="kw">return</span> x + <span class="dv">2</span>; } </a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">val</span> <span class="va">x</span> = <span class="dv">3</span>; </a></code></pre></div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: please note that all the above is primarily applied to declarations, because declaration scopes do not allow standalone statements to appear in them</span></p>
</div>
</blockquote>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(qualified names?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(extensions?)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(receivers)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(rewrite expressions and statements as references to this part)</span>
</div></li>
<li><div class="TODO">
<span class="sentence">TODO(identifier lifetime &amp; such)</span>
</div></li>
</ul>
<h2 id="packages-and-imports">Packages and imports</h2>
<div class="paragraph">
<p><span class="sentence">Any Kotlin project is structured into <strong>packages</strong>. </span><span class="sentence">A package may contain one or more Kotlin files and each file is related to the corresponding package using the <em>package header</em>. </span><span class="sentence">A file may contain only one (or zero) package headers, meaning that each file belongs to exactly one package.</span></p>
</div>
<div id="grammar-rule-packageHeader-pasted-0" class="grammar-rule">
<dl>
<dt><strong><em>packageHeader</em>:</strong></dt>
<dd><span class="sentence">[<code>'package'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>]]</span>
</dd>
</dl>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an absence of a package header in a file means that is belongs to the special <em>root package</em></span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Packages are different from <a href="#modules">modules</a>. </span><span class="sentence">A module may contain many packages, while a single package can be spread across several modules.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The name of a package is a dot (<code>.</code>)-separated sequence of identifiers, introducing a package hierarchy. </span><span class="sentence">Unlike Java and some other languages, Kotlin does not restrict the package hierarchy to correspond directly to the folder structure of the project.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that the hierarchy itself is only notational, not affecting the code in any way. </span><span class="sentence">It is strongly recommended, however, that the folder structure of the project does correspond to the package hierarchy.</span></p>
</div>
</blockquote>
<h3 id="importing">Importing</h3>
<div class="paragraph">
<p><span class="sentence">Program entities declared in one package may be freely used in any file in the same package with the only restriction being <a href="#modules">module</a> boundaries. </span><span class="sentence">In order to use an entity from a file belonging to a different package, the programmer must use <em>import directives</em>.</span></p>
</div>
<div id="grammar-rule-importList-pasted-1" class="grammar-rule">
<dl>
<dt><strong><em>importList</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-importHeader">importHeader</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importHeader-pasted-2" class="grammar-rule">
<dl>
<dt><strong><em>importHeader</em>:</strong></dt>
<dd><span class="sentence"><code>'import'</code> <em><a href="#grammar-rule-identifier">identifier</a></em> [(<code>'.'</code> <code>'*'</code>) | <em><a href="#grammar-rule-importAlias">importAlias</a></em>] [<em><a href="#grammar-rule-semi">semi</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-importAlias-pasted-3" class="grammar-rule">
<dl>
<dt><strong><em>importAlias</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An import directive contains dot-separated <em>path</em> to an entity, as well as the name of the entity itself (the last argument of the navigation dot operator). </span><span class="sentence">A path may include not only the package the import is importing from, but also an object or a type (referring to companion object of this type). </span><span class="sentence">Any named declaration within that scope (that is, top-level scope of all files in the package or, in the object case, the object declararion scope) may be imported using their names. </span><span class="sentence">There are two special kinds of imports: star-imports ending in an asterisk (<code>*</code>) and renaming imports employing the use of <code>as</code> operator. </span><span class="sentence">Star-imports import all the named entities inside the corresponding scope, but have weaker priority during <a href="#overload-resolution">resolution</a> of functions and properties. </span><span class="sentence">Renaming imports work just as regular imports, but introduce the entity into current file with a name different from the name it has at declaration site.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Imports are file-based, meaning that if an entity is introduced into file A.kt belonging to package <code>kotlinx.foo</code>, it does not introduce this entity to all other files belonging to <code>kotlinx.foo</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are some packages that have all their entities <em>implicitly imported</em> into any Kotlin file, meaning one can access this entity without explicitly using import directives. </span><span class="sentence">One may, however, import this entities explicitly if they choose to. </span><span class="sentence">These are the following packages of the standard library:</span></p>
</div>
<ul>
<li><span class="sentence"><code>kotlin</code></span></li>
<li><span class="sentence"><code>kotlin.annotation</code></span></li>
<li><span class="sentence"><code>kotlin.collections</code></span></li>
<li><span class="sentence"><code>kotlin.comparisons</code></span></li>
<li><span class="sentence"><code>kotlin.io</code></span></li>
<li><span class="sentence"><code>kotlin.ranges</code></span></li>
<li><span class="sentence"><code>kotlin.sequences</code></span></li>
<li><span class="sentence"><code>kotlin.text</code></span></li>
<li><span class="sentence"><code>kotlin.math</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Platform implementations may introduce additional implicitly imported packages, for example, adding standard platform functionality into Kotlin code.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an example of this would be <code>java.lang</code> package implicitly imported on the jvm platform</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Importing certain entities may be disallowed by their [visibility modifiers][Visibility].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clarify all this)</span></p>
</div>
</div>
<h3 id="modules">Modules</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Here be The dragons)</span></p>
</div>
</div>
<h2 id="overloadable-operators">Overloadable operators</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(rename this and all the refs to smth)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Some syntax forms in Kotlin are defined <em>by convention</em>, meaning that their semantics are defined through syntactic expansion of current syntax form into another syntax form. </span><span class="sentence">The expansion of a particular syntax form is a different piece of code usually defined in the terms of operator functions. </span><span class="sentence">Operator functions are function that are <a href="#function-declaration">declared</a> with a special keyword <code>operator</code> and are not different from normal functions when called normally, but allow themselves to be employed by syntactic expansion. </span><span class="sentence">Different platforms may add other criteria on whether a function may be considered a suitable candidate for operator convention.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Particular cases of definition by convention include:</span></p>
</div>
<ul>
<li><span class="sentence">Arithmetic and comparison operators;</span></li>
<li><span class="sentence">Operator-form <a href="#assignments">assignments</a>;</span></li>
<li><span class="sentence"><a href="#for-loop-statement">For-loop statements</a>;</span></li>
<li><span class="sentence"><a href="#delegated-property-declaration">Delegated properties</a>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(anything else?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">There are several common points among all the syntax forms defined using this mechanism:</span></p>
</div>
<ul>
<li><span class="sentence">The expansions are hygenic: if they seemingly introduce new identifiers that were not present in original syntax, all such identifiers are not accessible outside the expansion and cannot clash with any other declarations in the program;</span></li>
<li><span class="sentence">The expressions captured by an expansion are using call-by-need evaluation strategy, meaning that they are evaluated only once during first usage specified in the expansion even if the expansion itself has more than one usage of such an expression;</span></li>
<li><span class="sentence">An expansion may lead to another expansion, following the same rules;</span></li>
<li><span class="sentence">All the new call expressions that are produced by expansion are only allowed to use operator functions.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For example, take the following declarations:</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> A {</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="fu">inc</span>(): <span class="dt">A</span> { ... }</a>
<a class="sourceLine" id="cb8-3" title="3">}</a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">object</span> B {</a>
<a class="sourceLine" id="cb8-6" title="6">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(<span class="va">i</span>: <span class="dt">Int</span>): <span class="dt">A</span> { ... }</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">set</span>(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">value</span>: <span class="dt">A</span>) { ... }</a>
<a class="sourceLine" id="cb8-8" title="8">}</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">object</span> C {</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">operator</span> <span class="kw">fun</span> <span class="kw">get</span>(<span class="va">i</span>: <span class="dt">Int</span>): <span class="dt">B</span> { ... }</a>
<a class="sourceLine" id="cb8-12" title="12">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The expression <code>C[0][0]++</code> is expanded (see the <a href="#expressions">Expressions</a> section for details) using the following rules:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">First, the <a href="#postfix-increment-expression">increment operator</a> is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1">C[<span class="dv">0</span>][<span class="dv">0</span>] = C[<span class="dv">0</span>][<span class="dv">0</span>].inc()</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Second, the <a href="#assignments">assigment</a> to an indexing expression (produced by the previous expansion) is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1">C[<span class="dv">0</span>].<span class="kw">set</span>(C[<span class="dv">0</span>].<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div></li>
<li><div class="paragraph">
<p><span class="sentence">Third, the [indexing expression][Indexing expression] is expanded, resulting in:</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1">C.<span class="kw">get</span>(<span class="dv">0</span>).<span class="kw">set</span>(C.<span class="kw">get</span>(<span class="dv">0</span>).<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Although the resulting expression contains several invocations of the subexpression <code>C.get(0)</code>, it is evaluated only once, making this code roughly equivalent to:</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">val</span> $<span class="va">tmp</span> = C.<span class="kw">get</span>(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb12-2" title="2">$tmp.<span class="kw">set</span>($tmp.<span class="kw">get</span>(<span class="dv">0</span>).inc())</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="declarations">Declarations</h2>
<h3 id="glossary-2">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">A distinguishable part of a program</span>
</dd>
<dt>Path</dt>
<dd><span class="sentence">A sequence of names which identifies a program entity</span>
</dd>
</dl>
<h3 id="identifiers-names-and-paths">Identifiers, names and paths</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Explain paths)</span></p>
</div>
</div>
<h3 id="introduction-2">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e. they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<div id="grammar-rule-classDeclaration-pasted-4" class="grammar-rule">
<dl>
<dt><strong><em>classDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'class'</code> | <code>'interface'</code>)<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-primaryConstructor">primaryConstructor</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-enumClassBody">enumClassBody</a></em>)]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-objectDeclaration-pasted-5" class="grammar-rule">
<dl>
<dt><strong><em>objectDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'object'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described <a href="#classifier-types">here</a>. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations;</span></li>
<li><span class="sentence">interface declarations;</span></li>
<li><span class="sentence">object declarations.</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span>;</span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span>;</span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span>;</span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following:</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span>;</span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span>;</span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span>;</span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span>;</span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span>;</span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span>.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this class’ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this class’ name or under the path <code>C.CO</code>. </span><span class="sentence">Companion object name may be omitted, in which case it is considered to be equal to <code>Companion</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Nested classifier declarations introduce new classifiers, available under this class’ path for all nested classifiers except for inner classes. </span><span class="sentence">Inner classes are available only on the corresponding class’ entities. </span><span class="sentence">Further details are available [here][Inner and nested classes].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple class declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[ptor : (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(name: type\)</span>;</span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(\mathtt{val} name: type\)</span>;</span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(\mathtt{val} name: type\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type. </span><span class="sentence">One can consider them to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb13-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters. </span><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>kotlin.Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(elaborate this <code>this(...)</code> and <code>super(...)</code> business)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(default values in constructors???)</span></p>
</div>
</div>
<h5 id="nested-and-inner-classifiers">Nested and inner classifiers</h5>
<div class="paragraph">
<p><span class="sentence">If a classifier declaration <span class="math inline">\(ND\)</span> is <em>nested</em> in another classifier declaration <span class="math inline">\(PD\)</span>, it creates a nested classifier type — a classifier type available under the path <span class="math inline">\(PD.ND\)</span>. </span><span class="sentence">In all other aspects, nested classifiers are equivalent to regular ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Inner classes are a special kind of nested classifiers, which introduce types of objects associated (linked) with other (parent) objects. </span><span class="sentence">An inner class declaration <span class="math inline">\(ID\)</span> nested in another classifier declaration <span class="math inline">\(PD\)</span> may reference an <em>object</em> of type <span class="math inline">\(ID\)</span> associated with it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This association happens when instantiating an object of type <span class="math inline">\(ID\)</span>, as its constructor may be invoked only when a receiver of type <span class="math inline">\(PD\)</span> is available, and this receiver becomes associated with the new instantiated object of type <span class="math inline">\(ID\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="paragraph">
<p><span class="sentence">In a classifier (an object or a class) <span class="math inline">\(C\)</span> declaration any supertype <span class="math inline">\(I\)</span> inheritance may be <em>delegated to</em> an arbitrary value <span class="math inline">\(v\)</span> if:</span></p>
</div>
<ul>
<li><span class="sentence">The supertype <span class="math inline">\(I\)</span> is an interface type;</span></li>
<li><span class="sentence"><span class="math inline">\(v\)</span> has type <span class="math inline">\(T\)</span> such that <span class="math inline">\(T &lt;: I\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The inheritance delegation uses a syntax similar to [property delegation][Property delegation] using the <code>by</code> keyword, but is specified in the classifier declaration header and is a very different concept. </span><span class="sentence">If inherited using delegation, each method <span class="math inline">\(M\)</span> of <span class="math inline">\(I\)</span> (whether they have a default implementation or not) is delegated to the corresponding method of <span class="math inline">\(v\)</span> as if it was overriden in <span class="math inline">\(C\)</span> with all the parameter values directly passed to the corresponding method in <span class="math inline">\(v\)</span>, unless the body of <span class="math inline">\(C\)</span> itself has a suitable override of <span class="math inline">\(M\)</span> (see the method overriding <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> section).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The particular means on how <span class="math inline">\(v\)</span> is stored inside the classifier object is platform-defined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Due to the <a href="#classifier-initialization">initialization order of a classifier object</a>, the expression used to construct <span class="math inline">\(v\)</span> can not access any of the classifier object properties or methods excluding the parameters of the primary constructor.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(dataClass\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((dp_1, \ldots, dp_m)\)</span>, described in its primary constructor. </span><span class="sentence">As such, it allows Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions. </span><span class="sentence">Each one of these functions is generated if and only if a matching signature function is not present in the class body.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with their contracts:</span>
<ul>
<li><span class="sentence"><code>equals(that)</code> returns true iff:</span>
<ul>
<li><span class="sentence"><code>that</code> has the same runtime type as <code>this</code>;</span></li>
<li><span class="sentence"><code>this.prop.equals(that.prop)</code> returns <code>true</code> for every data property <code>prop</code>;</span></li>
</ul></li>
<li><span class="sentence"><code>hashCode()</code> returns different numbers for objects <code>A</code> and <code>B</code> if they do not equal by the generated <code>equals</code>;</span></li>
<li><span class="sentence"><code>toString</code> returns a string representations which is guaranteed to include the class name along with all the data properties’ string representations.</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Be more specific?).</span>
</div></li>
</ul></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying with the following properties:</span>
<ul>
<li><span class="sentence">It has the same number of parameters as the primary constructor with the same names and types;</span></li>
<li><span class="sentence">It calls the primary constructor with the corresponding parameters at the corresponding positions;</span></li>
<li><span class="sentence">It has defaults for all the parameters defaulting to the value of the corresponding property in <code>this</code> object.</span></li>
</ul></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for destructive declaration:</span>
<ul>
<li><span class="sentence">For the data property at position <span class="math inline">\(N\)</span> (<strong>starting with 1</strong>), the generated <code>component</code><span class="math inline">\(N\)</span> function has the same type as this property and returns the value of this property;</span></li>
<li><span class="sentence">It has an <code>operator</code> modifier, allowing it to be used in [destructuring declarations][Destructuring declaration];</span></li>
<li><span class="sentence">The number of these functions is the same as the number of data properties.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These generated declarations of <code>equals</code>, <code>hashCode</code> and <code>toString</code> may be overriden the same way they may be overriden in normal classes. </span><span class="sentence">The overriding version is preferred, as normally. </span><span class="sentence">In addition, for every other function, if any of the base types provide an open function with a matching signature, it is automatically overriden by the generated function as if it was generated with an <code>override</code> modifier.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: base classes may also have functions that are either not open or have a conflicting signature with the same function name. </span><span class="sentence">As expected, these cases result in override or overload conflicts the same way they would do with a normal class declaration.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{dp_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Data classes have the following restrictions:</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are final and cannot be inherited from;</span></li>
<li><span class="sentence">Data classes must have a primary constructor with only property constructor parameters, which become data properties for the data class;</span></li>
<li><span class="sentence">There must be at least one data property in the primary constructor.</span></li>
</ul>
<h5 id="data-class-generation">Data class generation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Do we really need this?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A more detailed explaination)</span></p>
</div>
</div>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(grammar reference)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Use “enumeration” instead of “enum”?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Enum class is a special kind of class with the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">It has a number of predefined values that are declared in the class itself (<em>enum entries</em>);</span></li>
<li><span class="sentence">No other values of this class can be constructed;</span></li>
<li><span class="sentence">It implicitly inherits the built-in class <code>kotlin.Enum</code> (and cannot have any other base classes);</span></li>
<li><span class="sentence">It it implicitly final and cannot be inherited from;</span></li>
<li><span class="sentence">It has special syntax to accommodate for the properties described above.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Enum class body uses special kind of syntax (see grammar) to declare enum entries in addition to all other declarations inside the class body. </span><span class="sentence">Enum entries have their own bodies that may contain their own declarations, similar to <a href="#object-declaration">object declarations</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an enum class can have zero enum entries. </span><span class="sentence">This makes objects of this class impossible to construct.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In addition to this, every enum class has an implicit companion object declaration with the following member functions (in addition to the ones the object declaration specified explicitly has):</span></p>
</div>
<ul>
<li><span class="sentence"><code>valueOf(value: String)</code> returning an object corresponding to the entry with the name equal to <code>value</code> parameter of the call;</span></li>
<li><span class="sentence"><code>values()</code> returning an <a href="#array-types">array</a> of all the possible enum values. </span><span class="sentence">Every invocation of this function returns a new array to disallow changing its contents.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin standard library introduces another function to access all enum values for a specific enum class called <code>kotlin.enumValues&lt;T&gt;</code>. </span><span class="sentence">Please refer to the standard library documentation for details.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>kotlin.Comparable</code> generation?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="paragraph">
<p><span class="sentence">Annotations class is a special kind of class that is used to declare <a href="#annotations">annotations</a>. </span><span class="sentence">Annotation classes have the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">They cannot have any secondary constructors;</span></li>
<li><span class="sentence">All the primary constructor parameters must use the property syntax;</span></li>
<li><span class="sentence">They implicitly inherit <code>kotlin.Annotation</code> class (and cannot have any other base classes);</span></li>
<li><span class="sentence">They cannot implement interfaces;</span></li>
<li><span class="sentence">They are implicitly final and cannot be inherited from;</span></li>
<li><span class="sentence">They may not have any member functions, properties not declared in the primary constructor or any overriding declarations;</span></li>
<li><span class="sentence">They cannot have companion objects;</span></li>
<li><span class="sentence">They cannot have nested classes;</span></li>
<li><span class="sentence">The types of primary constructor parameters are limited to:</span>
<ul>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
<li><span class="sentence"><code>kotlin.KClass</code>;</span></li>
<li><span class="sentence"><a href="#built-in-types">Built-in number types</a>;</span></li>
<li><span class="sentence">Other annotation types;</span></li>
<li><span class="sentence">Arrays of any other allowed type.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Annotation classes cannot be constructed directly, but their primary constructors are used when specifying <a href="#annotations">code annotations</a> for other entities.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interface’s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype;</span></li>
<li><span class="sentence">An interface cannot have a constructor;</span></li>
<li><span class="sentence">Interface properties cannot have initializers or backing fields;</span></li>
<li><span class="sentence">An interface cannot have inner classes (but can have nested classes and companion objects);</span></li>
<li><span class="sentence">An interface and all its members are implicitly open;</span></li>
<li><span class="sentence">All interface member properties and functions are implicitly public;</span>
<ul>
<li><span class="sentence">Trying to declare a non-public member property or function in an interface is an error.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are used to support a singleton pattern and, thus, do two things at the same time. </span><span class="sentence">One, they (just like class declarations) introduce a new type to the program. </span><span class="sentence">Two, they create a singleton-like object of that type.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(do we really need this ironic-ish statement about doing two things at the same time?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object type cannot be used as a supertype for other types;</span></li>
<li><span class="sentence">An object cannot have a constructor;</span></li>
<li><span class="sentence">An object cannot have a companion object;</span></li>
<li><span class="sentence">An object may not have inner classes;</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this section is about declaration of <em>named</em> objects. </span><span class="sentence">Kotlin also has a concept of <em>anonymous</em> objects, or object literals, which are similar to their named counterparts, but are expressions rather than declarations and, as such, are described in the <a href="#object-literals">corresponding section</a>.</span></p>
</div>
</blockquote>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">First, a supertype constructor corresponding to <span class="math inline">\(ctor\)</span> is called with its respective parameters.</span></p>
</div>
<ul>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a primary constructor, a corresponding supertype constructor is the one from the supertype specifier list;</span></li>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a secondary constructor, a corresponding supertype constructor is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span>;</span></li>
<li><span class="sentence">If an explicit supertype constructor is not available, <code>Any()</code> is implicitly used.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">After the supertype initialization is done, we continue the initialization by processing each inner declaration in its body, <em>in the order of their inclusion in the body</em>. </span><span class="sentence">If any initialization step creates a loop, it is considered an undefined behavior.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a classifier type is initialized using a particular secondary constructor <span class="math inline">\(ctor\)</span> delegated to primary constructor <span class="math inline">\(pctor\)</span> which, in turn, is delegated to the superclass constructor <span class="math inline">\(sctor\)</span>, the following happens, in this order:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(pctor\)</span> is invoked using the specified parameters, initializing all the properties declared by its property parameters in the order they appear in the constructor declaration;</span></li>
<li><span class="sentence">The superclass object (if any) is initialized as if created by invoking <span class="math inline">\(sctor\)</span> with the specified parameters;</span></li>
<li><span class="sentence">Interface delegation expressions (if any) are invoked and the result of each is stored in the object to allow for interface delegation, in the order of appearance of delegation declarations in the classifier header;</span></li>
<li><span class="sentence">All the properties’ initialization code as well as all the initialization blocks in the class body get initialized in the order of appearance in the class body;</span></li>
<li><span class="sentence"><span class="math inline">\(ctor\)</span> body is invoked using the specified parameters.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that if an <code>init</code>-block appears between two property declarations in the class body, its body is invoked between the initialization code of these two properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">This order stays the same if any of the entities involved are omitted, omitting the corresponding step (e.g. if there is no primary constructor, it is not invoked, and if the object is created using primary constructor, the body of the secondary one is not invoked, etc.), but performing all others. </span><span class="sentence">If any of the properties of the object are accessed before they are initialized in this order (for example, if a method called in an initialization block accesses a property that is mention after the block), the value of the property is undefined.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this can happen if a property is captured in a lambda expression that is used in some way during other initialization phases</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(This needs thorough testing)</span></p>
</div>
</div>
<h3 id="function-declaration">Function declaration</h3>
<div id="grammar-rule-functionDeclaration-pasted-6" class="grammar-rule">
<dl>
<dt><strong><em>functionDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-functionBody-pasted-7" class="grammar-rule">
<dl>
<dt><strong><em>functionBody</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-block">block</a></em><br />
| (<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to functions — blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail <a href="#function-types">here</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts:</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a function type <span class="math inline">\(f : (P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters — inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a <a href="#kotlin.nothing">special meaning</a> in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: <code>expect</code> and <code>external</code> functions also do not have implementations</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb14-4" title="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb14-5" title="5">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Argument names are resolved in compile time)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(P_1, \ldots, P_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(P_i\)</span> is a positional argument, <span class="math inline">\(N_j\)</span> is a named argument; i.e., positional arguments must precede all of the named ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters — parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb15-2" title="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb15-6" title="6">    println(bar())</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb15-8" title="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb15-9" title="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb15-10" title="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb15-11" title="11"></a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb15-13" title="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb15-14" title="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more positional arguments;</span></li>
<li><span class="sentence">Zero or more named arguments.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values, if they exist.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as a value <span class="math inline">\(p_i\)</span> of type, which is the result of <a href="#array-types"><em>array type specialization</em></a> of type <code>Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to a value of type, which is the result of <a href="#array-types"><em>array type specialization</em></a> of type <code>Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An array of type <code>Array&lt;Q&gt;</code><span class="math inline">\(\: &lt;: \:\)</span><code>ATS(Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;)</code> may be <em>unpacked</em> to a variable length parameter in function invocation using [spread operator][Spread operator]; in this case array elements are considered to be separate arguments in the variable length parameter position.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for variable length parameters corresponding to specialized array types, unpacking is possible only for these specialized versions; for a variable length parameter of type <code>Int</code>, for example, unpacking is valid only for <code>IntArray</code>, and not for <code>Array&lt;Int&gt;</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension function declaration</em> is similar to a standard function declaration, but introduces an additional special function parameter, the <em>receiver parameter</em>. </span><span class="sentence">This parameter is designated by specifying the receiver type (the type before <code>.</code> in function name), which becomes the type of this receiver parameter. </span><span class="sentence">This parameter is not named and must always be supplied (either explicitly or implicitly), e.g. it cannot be a variable-argument parameter, have a default value, etc.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Calling such a function is special because the receiver parameter is not supplied as an argument of the call, but as the <a href="#receivers"><em>receiver</em></a> of the call, be it implicit or explicit. </span><span class="sentence">This parameter is available inside the scope of the function as the implicit receiver or <code>this</code>-expression, while nested scopes may introduce additional receivers that take precedence over this one. </span><span class="sentence">See <a href="#receivers">the receiver section</a> for details. </span><span class="sentence">This receiver is also available (as usual) in nested scope using labeled <code>this</code> syntax using the name of the declared function as the label.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For more information on how a particular receiver for each call is chosen, please refer to the <a href="#overload-resolution">overloading section</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension functions inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested functions</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension functions are not different from non-extension functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb16"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span> + <span class="dv">1</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="fl">2.f</span>oo() <span class="co">// prints &quot;3&quot;</span></a>
<a class="sourceLine" id="cb16-5" title="5">}</a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="kw">fun</span> <span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Bar</span></a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb16-10" title="10">}</a></code></pre></div>
<h3 id="property-declaration">Property declaration</h3>
<div id="grammar-rule-propertyDeclaration-pasted-8" class="grammar-rule">
<dl>
<dt><strong><em>propertyDeclaration</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
(<code>'val'</code> | <code>'var'</code>)<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-receiverType">receiverType</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
({<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> | <em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em>))<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} ((<code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>) | <em><a href="#grammar-rule-propertyDelegate">propertyDelegate</a></em>)]<br />
[(<em><a href="#grammar-rule-NL">NL</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}) <code>';'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
(([<em><a href="#grammar-rule-getter">getter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-setter">setter</a></em>]) | ([<em><a href="#grammar-rule-setter">setter</a></em>] [{<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-semi">semi</a></em>] <em><a href="#grammar-rule-getter">getter</a></em>]))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter — functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb17"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation. </span><span class="sentence">Both the right-hand value <code>e</code>, the type <code>T</code> and the getter are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if both the type of <code>e</code> and the return type of the getter cannot be <a href="#type-inference">inferred</a> (or, in case of the getter, specified explicitely), the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both <code>e</code> and <code>T</code> are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see <a href="#subtyping">subtyping</a> for more details).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: we never actually say how getters are similar/different to normal functions and, henceworth, how the inference works</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The initializer expression <code>e</code>, if given, serves as the starting value for the property backing field (see <a href="#getters-and-setters">getters and setters section</a> for details) and is evaluated when the property is created. </span><span class="sentence">Properties that are not allowed to have backing fields (see <a href="#getters-and-setters">getters and setters section</a> for details) are also not allowed to have initializer expressions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: although a property with an initializer expression looks similar to an <a href="#assignments">assignment</a>, it is different in several key ways: first, a read-only property cannot be assigned, but may have an initializer expression; second, the initializer expression never invokes the property setter, but assigns the property backing field value directly.</span></p>
</div>
</blockquote>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="#getters-and-setters">getter</a> and/or custom <a href="#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb18"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="#getters-and-setters">getters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In case of a delegated read-only property, every access to such property (<code>x</code> in this case) becomes an [overloadable][Operator overloading] form which is expanded into the following:</span></p>
</div>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">e<span class="op">.</span>getValue(thisRef, property)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the <a href="#receivers">receiver</a> object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read access is handled the same way as for a delegated read-only property. </span><span class="sentence">Any write access to <code>x</code> (using, for example, an assignment operator <code>x = y</code>) becomes an overloadable form with the following expansion:</span></p>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">e<span class="op">.</span>setValue(thisRef, property, y)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the <a href="#receivers">receiver</a> object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details);</span></li>
<li><span class="sentence"><code>y</code> is the value <code>x</code> is assigned to. </span><span class="sentence">In case of complex assignments (see the <a href="#assignments">assignment</a> section), as they are all overloadable forms, first the assignment expansion is performed, and after that, the expansion of the delegated property using normal assignment.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An example on how the delegation expansion may be actually implemented by the compiler is as follows.</span></p>
</div>
<div class="sourceCode" id="cb21"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb21-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb21-5" title="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb21-6" title="6">}</a>
<a class="sourceLine" id="cb21-7" title="7"></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb21-11" title="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb21-12" title="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb21-13" title="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb21-14" title="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb21-15" title="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb21-16" title="16">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The type of a delegated property may be omitted at the declaration site, meaning that it may be <a href="#type-inference">inferred</a> from the delegating function itself. </span><span class="sentence">If this type is omitted, it is inferred as if it was assigned the value of its expansion. </span><span class="sentence">If this inference fails, it is a compile-time error.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb22"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sugar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb23"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb23-3" title="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb23-4" title="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb24"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb24-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="kw">set</span>(anyValidArgumentName: TS): RT { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(RT \equiv \mathtt{kotlin.Unit}\)</span>;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Types <span class="math inline">\(TG\)</span>, <span class="math inline">\(TS\)</span> and <span class="math inline">\(RT\)</span> are optional and may be omitted from the declaration;</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a custom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid identifier as argument name.</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb25"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb25-2" title="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb25-3" title="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the property’s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, <code>field</code> has the same type <code>T</code></span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors;</span></li>
<li><span class="sentence">A property has a default accessor;</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property;</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both/</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field. </span><span class="sentence">Properties without backing fields are not allowed to have initializer expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow for some modifiers available for function declarations (for example, they may be declared <code>inline</code>, see grammar for details).</span></p>
</div>
<h4 id="extension-property-declaration">Extension property declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension property declaration</em> is similar to a standard property declaration, but, very much alike an <a href="#extension-function-declaration">extension function</a>, introduces an additional parameter to the property called <em>the receiver parameter</em>. </span><span class="sentence">This is different from usual property declarations, that do not have any parameters. </span><span class="sentence">There are other differences from standard property declarations:</span></p>
</div>
<ul>
<li><span class="sentence">Extension properties cannot have initializers;</span></li>
<li><span class="sentence">Extension properties cannot have backing fields;</span></li>
<li><span class="sentence">Extension properties cannot have default accessors.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, on can say that extension properties have no state of their own. </span><span class="sentence">Only properties that use other objects’ storage facilities and/or uses constant data can be extension properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Aside from these differences, extension properties are similar to regular properties, but, when accessing such a property one always need to supply a <a href="#receivers"><em>receiver</em></a>, implicit or explicit. </span><span class="sentence">Also, unlike regular properties, the type of the receiver must be a subtype of the receiver parameter, and the value that is supplied as the receiver is bound to the receiver parameter. </span><span class="sentence">For more information on how a particular receiver for each access is chosen, please refer to the <a href="#overload-resolution">overloading section</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The receiver parameter can be accessed inside getter and setter scopes of the property as the implicit receiver or <code>this</code>. </span><span class="sentence">It may also be accessed inside nested scopes using <a href="#this-expressions">labeled <code>this</code> syntax</a> using the name of the property declared as the label. </span><span class="sentence">For delegated properties, the value passed into the operator functions <code>getValue</code> and <code>setValue</code> as the receiver is the value of the receiver parameter, rather than the value of the outer classifier. </span><span class="sentence">This is also true for local extension properties: while regular local properties are passed <code>null</code> as the first argument of these operator functions, local extension properties are passed the value of the receiver argument instead.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension properties inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested properties</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension properties are not different from non-extension properties.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb26"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">val</span> <span class="va">Int</span>.foo: <span class="kw">Int</span> <span class="kw">get</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb26-4" title="4">    println(<span class="fl">2.f</span>oo.foo) <span class="co">// prints &quot;4&quot;</span></a>
<a class="sourceLine" id="cb26-5" title="5">}</a>
<a class="sourceLine" id="cb26-6" title="6"></a>
<a class="sourceLine" id="cb26-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb26-8" title="8">    <span class="kw">val</span> <span class="va">foo</span> <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Bar</span></a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="kw">val</span> <span class="va">Int</span>.foo <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Int</span></a>
<a class="sourceLine" id="cb26-10" title="10">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(More examples (delegation, at least))</span></p>
</div>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail <a href="#control--and-data-flow-analysis">here</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(maybe it makes more sense to write all the initialization business right here)</span></p>
</div>
</div>
<h4 id="constant-properties">Constant properties</h4>
<div class="paragraph">
<p><span class="sentence">A property may be declared <strong>constant</strong>, meaning that its value is known during compilation, by using the special <code>const</code> modifier. </span><span class="sentence">In order to be declared <code>const</code>, a property must meet the following requirements:</span></p>
</div>
<ul>
<li><span class="sentence">Its type is one of the following:</span>
<ul>
<li><span class="sentence">One of the <a href="#built-in-integer-types">the built-in integral types</a>;</span></li>
<li><span class="sentence"><code>kotlin.Boolean</code>;</span></li>
<li><span class="sentence"><code>kotlin.Char</code>;</span></li>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
</ul></li>
<li><span class="sentence">It is declared in the top-level scope or inside [an object declaration][Object declarations];</span></li>
<li><span class="sentence">It has an initializer expression and this initializer expression may be evaluated in the compile-time. </span><span class="sentence">Integer literals and string interpolation expressions without evaluated expressions, as well as builtin arithmetic/comparison operations and string concatenation operations on those are such expressions, but it is implementation-defined which other expressions qualify for this;</span></li>
<li><span class="sentence">It does not have getters, setters or delegation specifiers.</span></li>
</ul>
<h3 id="type-alias">Type alias</h3>
<div id="grammar-rule-typeAlias-pasted-9" class="grammar-rule">
<dl>
<dt><strong><em>typeAlias</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-modifiers">modifiers</a></em>]<br />
<code>'typealias'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeParameters">typeParameters</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'='</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be <a href="#type-parameters">unbounded</a>. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden — the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its [<em>visibility modifiers</em>][Visibility].</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="declaration-modifiers">Declaration modifiers</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(declaration scope)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>open</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>abstract</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>lateinit</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>const</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(overriding vs overloading vs shadowing)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(visibility)</span></p>
</div>
</div>
<h2 id="statements">Statements</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div id="grammar-rule-statements-pasted-10" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-statement-pasted-11" class="grammar-rule">
<dl>
<dt><strong><em>statement</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-label">label</a></em> | <em><a href="#grammar-rule-annotation">annotation</a></em>} (<em><a href="#grammar-rule-declaration">declaration</a></em> | <em><a href="#grammar-rule-assignment">assignment</a></em> | <em><a href="#grammar-rule-loopStatement">loopStatement</a></em> | <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Unlike some other languages, Kotlin does not explicitly distinguish between statements, expressions and declarations, i.e., expressions and declarations can be used in statement positions. </span><span class="sentence">This section focuses only on those statements that are <em>not</em> expressions or declarations. </span><span class="sentence">For information on those parts of Kotlin, please refer to the <a href="#expressions">Expressions</a> and <a href="#declarations">Declarations</a> sections of the specification.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example: Kotlin supports using <a href="#conditional-expression">conditionals</a> both as expressions and as statements. </span><span class="sentence">As their use as expressions is more general, detailed information about conditionals is available in the <a href="#expressions">Expressions</a> section of the specification.</span></p>
</div>
</blockquote>
<h3 id="assignments">Assignments</h3>
<div id="grammar-rule-assignment-pasted-12" class="grammar-rule">
<dl>
<dt><strong><em>assignment</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-directlyAssignableExpression">directlyAssignableExpression</a></em> <code>'='</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| (<em><a href="#grammar-rule-assignableExpression">assignableExpression</a></em> <em><a href="#grammar-rule-assignmentAndOperator">assignmentAndOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-assignmentAndOperator-pasted-13" class="grammar-rule">
<dl>
<dt><strong><em>assignmentAndOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+='</code><br />
| <code>'-='</code><br />
| <code>'*='</code><br />
| <code>'/='</code><br />
| <code>'%='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>assignment</em> is a statement that writes a new value to some program entity, denoted by its left-hand side. </span><span class="sentence">Both left-hand and right-hand sides of an assignment must be expressions, more so, there are several restrictions for the expression on the left-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an expression to be <em>assignable</em>, i.e. be allowed to occur on the left-hand side of an assignment, it <strong>must</strong> be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">an identifier referring to a mutable property;</span></li>
<li><span class="sentence">a navigation expression referring to a mutable property;</span></li>
<li><span class="sentence">an indexing expression.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(switch to navigation paths when we have them?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin assignments <strong>are not</strong> expressions and cannot be used as such.</span></p>
</div>
</blockquote>
<h4 id="simple-assignments">Simple assignments</h4>
<div class="paragraph">
<p><span class="sentence">A <em>simple assigment</em> is an assignment which uses the assign operator <code>=</code>. </span><span class="sentence">If the left-hand side of an assignment refers to a mutable property, a value of that property is changed when an assignment is evaluated, using the following rules (applied in order).</span></p>
</div>
<ul>
<li><span class="sentence">If a property is <a href="#delegated-property-declaration">delegated</a>, the corresponding operator function <code>setValue</code> is called using the right-hand side expression as the <code>value</code> argument;</span></li>
<li><span class="sentence">If a property has a <a href="#getters-and-setters">setter</a>, it is called using the right-hand side expression as its argument;</span></li>
<li><span class="sentence">Otherwise, if a property is a <a href="#mutable-property-declaration">mutable property</a>, its value is changed to the evaluation result of the right-hand side expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of an assignment refers to a mutable property through the usage of safe navigation operator (<code>?.</code>), the same rules apply to it, but only if the left-hand side of the navigation operator is not referentially equal to <code>null</code> reference, e.g.:</span></p>
</div>
<div class="sourceCode" id="cb27"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb27-1" title="1">a?.b?.z?.x = y </a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">is semantically the same as</span></p>
</div>
<div class="sourceCode" id="cb28"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">val</span> <span class="va">__tmp</span> = a?.b?.z</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="cf">if</span>(__tmp !== <span class="kw">null</span>) __tmp.x = y</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(just use setters for everything?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If the left-hand side of an assignment is an indexing expression, the whole statement is treated as an <a href="#overloadable-operators">overloaded operator</a> with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math inline">\(A[B_1,B_2,B_3,\ldots,B_N] = C\)</span> is the same as calling <span class="math inline">\(A\text{.set}(B_1,B_2,B_3,\ldots,B_N,C)\)</span> where <code>set</code> is a suitable operator function.</span></p>
</div>
<h4 id="operator-assignments">Operator assignments</h4>
<div class="paragraph">
<p><span class="sentence">An <em>operator assignment</em> is a combined-form assignment which involves one of the following operators: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>. </span><span class="sentence">All of these operators are overloadable operator functions with the following expansions (applied in order):</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>+=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.plusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>plusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.plus(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>plus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>-=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.minusAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>minusAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.minus(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>minus</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>*=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.timesAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>timesAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.times(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>times</code> operator function exists and is available.</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>/=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.divAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>divAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.div(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>div</code> operator function exists and is available;</span></li>
</ul></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>%=</code><span class="math inline">\(B\)</span> is exactly the same as one of the following:</span>
<ul>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>.remAssign(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>remAssign</code> operator function exists and is available;</span></li>
<li><span class="sentence"><span class="math inline">\(A\)</span><code>=</code><span class="math inline">\(A\)</span><code>.rem(</code><span class="math inline">\(B\)</span><code>)</code> if a suitable <code>rem</code> operator function exists and is available.</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as of Kotlin version 1.2.31, there are additional overloadable functions for <code>%</code> called <code>mod</code>/<code>modAssign</code>, which are deprecated.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">After the expansion, the resulting [function call expression][Function call expressions] or <a href="#simple-assignments">simple assignment</a> is processed according to their corresponding rules.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: although for most real-world use cases operators <code>++</code> and <code>--</code> are similar to operator assignments, in Kotlin they are expressions and are described in the <a href="#expressions">corresponding section</a> of this specification.</span></p>
</div>
</blockquote>
<h3 id="loop-statements">Loop statements</h3>
<div class="paragraph">
<p><span class="sentence">Loop statements describe an evaluation of a certain number of statements repeatedly until a <em>loop exit condition</em> applies.</span></p>
</div>
<div id="grammar-rule-loopStatement-pasted-14" class="grammar-rule">
<dl>
<dt><strong><em>loopStatement</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-forStatement">forStatement</a></em><br />
| <em><a href="#grammar-rule-whileStatement">whileStatement</a></em><br />
| <em><a href="#grammar-rule-doWhileStatement">doWhileStatement</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Loops are closely related to the semantics of <a href="#jump-expressions">jump expressions</a>, as these expressions, namely <a href="#break-expression"><code>break</code></a> and <a href="#continue-expression"><code>continue</code></a>, are only allowed in a body of a loop. </span><span class="sentence">Please refer to the corresponding sections for details.</span></p>
</div>
<h4 id="while-loop-statement">While-loop statement</h4>
<div id="grammar-rule-whileStatement-pasted-15" class="grammar-rule">
<dl>
<dt><strong><em>whileStatement</em>:</strong></dt>
<dd><span class="sentence">(<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>)<br />
| (<code>'while'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>';'</code>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>while-loop statement</em> is similar to an <a href="#conditional-expression"><code>if</code> expression</a> in that it also has a condition expression and a body consisting of zero or more statements. </span><span class="sentence">While-loop statement evaluating its body repeatedly for as long as its condition expression evaluates to true or a <a href="#jump-expressions">jump expression</a> is evaluated to finish the loop.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that the condition expression is evaluated before every evaluation of the body, including the first one.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The while-loop condition expression <strong>must be a subtype</strong> of <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="do-while-loop-statement">Do-while-loop statement</h4>
<div id="grammar-rule-doWhileStatement-pasted-16" class="grammar-rule">
<dl>
<dt><strong><em>doWhileStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'do'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'while'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>do-while-loop statement</em>, similarly to a while-loop statement, also describes a loop, with the following differences. </span><span class="sentence">First, it has a different syntax. </span><span class="sentence">Second, it evaluates the loop condition expression <strong>after</strong> evaluating the loop body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that the body is always evaluated at least once.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The do-while-loop condition expression <strong>must be a subtype</strong> of <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="for-loop-statement">For-loop statement</h4>
<div id="grammar-rule-forStatement-pasted-17" class="grammar-rule">
<dl>
<dt><strong><em>forStatement</em>:</strong></dt>
<dd><span class="sentence"><code>'for'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
(<em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em> | <em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em>)<br />
<em><a href="#grammar-rule-IN">IN</a></em><br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>]</span>
</dd>
</dl>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike most other languages, Kotlin does not have a free-form condition-based for loops. </span><span class="sentence">The only form of a for-loop available in Kotlin is the “foreach” loop, which iterates over lists, arrays and other data structures.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>for-loop statement</em> is a special kind of loop statement used to iterate over some data structure viewed as an iterable collection of elements. </span><span class="sentence">A for-loop statement consists of a loop body, a <strong>container expression</strong> and an <strong>iteration variable declaration</strong>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The for-loop is actually an <a href="#overloadable-operators">overloadable</a> syntax form with the following expansion:</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>for(VarDecl in C) Body</code> is the same as</span></p>
</div>
<div class="sourceCode" id="cb29"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">val</span> <span class="va">__iterator</span> = C.iterator()</a>
<a class="sourceLine" id="cb29-2" title="2"><span class="cf">while</span> (__iterator.hasNext()) {</a>
<a class="sourceLine" id="cb29-3" title="3">    <span class="kw">val</span> <span class="va">VarDecl</span> = __iterator.next()</a>
<a class="sourceLine" id="cb29-4" title="4">    &lt;... all the statements from Body&gt;</a>
<a class="sourceLine" id="cb29-5" title="5">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>iterator</code>, <code>hasNext</code>, <code>next</code> are all suitable operator functions available in the current scope. </span><span class="sentence"><code>VarDecl</code> here may be a variable name or a set of variable name as per [destructuring variable declarations][Destructuring declarations].</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the expansion is hygienic, i.e., the generated iterator variable never clashes with any other variable in the program and cannot be accessed outside the expansion.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(What about iterator value life-time and such?)</span></p>
</div>
</div>
<h3 id="code-blocks">Code blocks</h3>
<div id="grammar-rule-block-pasted-18" class="grammar-rule">
<dl>
<dt><strong><em>block</em>:</strong></dt>
<dd><span class="sentence"><code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-statements">statements</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-statements-pasted-19" class="grammar-rule">
<dl>
<dt><strong><em>statements</em>:</strong></dt>
<dd><span class="sentence">[<em><a href="#grammar-rule-statement">statement</a></em> {<em><a href="#grammar-rule-semis">semis</a></em> <em><a href="#grammar-rule-statement">statement</a></em>} [<em><a href="#grammar-rule-semis">semis</a></em>]]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>code block</em> is a sequence of zero or more statements between curly braces separated by newlines or/and semicolons. </span><span class="sentence">Evaluating a code block means evaluating all its statements in the order they appear inside of it.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin does <strong>not</strong> support code blocks as statements; a curly-braces code block in a statement position is a <a href="#lambda-literals">lambda literal</a>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>last expression</em> of a code block is the last statement in it (if any) if and only if this statement is also an expression. </span><span class="sentence">The last expressions are important when defining functions and control structure expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A code block is said to contain no last expression if it does not contain any statements or its last statement is not an expression (e.g., it is an assignment, a loop or a declaration).</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: you may consider the case of a missing last expression as if a synthetic last expression with no runtime semantics and type <code>kotlin.Unit</code> is introduced in its place.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A <em>control structure body</em> is either a single statement or a code block. </span><span class="sentence">A <em>last expression</em> of a control structure body <code>CSB</code> is either the last expression of a code block (if <code>CSB</code> is a code block) or the single statement itself (if <code>CSB</code> is an expression). </span><span class="sentence">If a control structure body is not a code block or an expression, it has no last expression.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this is equivalent to wrapping the single statement in a new synthetic code block.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In some contexts, a control structure body is expected to have a value and/or a type. </span><span class="sentence">The value of a control structure body is:</span></p>
</div>
<ul>
<li><span class="sentence">the value of its last expression if it exists;</span></li>
<li><span class="sentence">the singleton <code>kotlin.Unit</code> object otherwise.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The type of a control structure body is the type of its value.</span></p>
</div>
<h3 id="todo">TODO</h3>
<ul>
<li><span class="sentence">Labels</span></li>
<li><span class="sentence">Are declarations statements or not?</span>
<ul>
<li><span class="sentence">In the current grammar, they are</span></li>
</ul></li>
<li><span class="sentence">How expansions with new variables actually work</span></li>
</ul>
<h2 id="expressions">Expressions</h2>
<h3 id="glossary-3">Glossary</h3>
<dl>
<dt>CSB</dt>
<dd><span class="sentence"><a href="#code-blocks">Control structure body</a></span>
</dd>
</dl>
<h3 id="introduction-3">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An expression may be <em>used as a statement</em> or <em>used as an expression</em> depending on the context. </span><span class="sentence">As all expressions are valid <a href="#statements">statements</a>, free expressions may be used as single statements or inside code blocks.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An expression is used as an expression, if it is encountered in any position where a statement is not allowed, for example, as an operand to an operator or as an immediate argument for a function call. </span><span class="sentence">An expression is used as a statement if it is encountered in any position where a statement is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Some expressions are only allowed to be used as statements, if certain restrictions are met; this may affect the semantics, the compile-time type information or/and the safety of these expressions.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(strong/soft keywords?)</span></p>
</div>
</div>
<h3 id="constant-literals">Constant literals</h3>
<div class="paragraph">
<p><span class="sentence">Constant literals are expressions which describe constant values. </span><span class="sentence">Every constant literal is defined to have a single standard library type, whichever it is defined to be on current platform. </span><span class="sentence">All constant literals are evaluated immediately.</span></p>
</div>
<h4 id="boolean-literals">Boolean literals</h4>
<dl>
<dt><strong><em>BooleanLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>true</code> | <code>false</code></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">Keywords <code>true</code> and <code>false</code> denote boolean literals of the same values. </span><span class="sentence">These are strong keywords which cannot be used as identifiers unless [escaped][Escaped identifiers]. </span><span class="sentence">Values <code>true</code> and <code>false</code> always have the type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="integer-literals">Integer literals</h4>
<dl>
<dt><strong><em>IntegerLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigitNoZero</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
<dt><strong><em>HexLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em> {<em>HexDigitOrSeparator</em>} <em>HexDigit</em><br />
| <code>0</code> (<code>x</code>|<code>X</code>) <em>HexDigit</em></span>
</dd>
<dt><strong><em>BinLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em> {<em>BinDigitOrSeparator</em>} <em>BinDigit</em><br />
| <code>0</code> (<code>b</code>|<code>B</code>) <em>BinDigit</em></span>
</dd>
<dt><strong><em>DecDigitNoZero</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> - <code>0</code></span>
</dd>
<dt><strong><em>DecDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>HexDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>HexDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>BinDigitOrSeparator</em>:</strong></dt>
<dd><span class="sentence"><em>BinDigit</em> | <em>Underscore</em></span>
</dd>
<dt><strong><em>DecDigits</em>:</strong></dt>
<dd><span class="sentence"><em>DecDigit</em> {<em>DecDigitOrSeparator</em>} <em>DecDigit</em> | <em>DecDigit</em></span>
</dd>
</dl>
<h5 id="decimal-integer-literals">Decimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of decimal digit symbols (<code>0</code> though <code>9</code>) is a decimal integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike other languages, Kotlin does not support octal literals. </span><span class="sentence">Even more so, any decimal literal starting with digit <code>0</code> and containing more than 1 digit is not a valid decimal literal.</span></p>
</div>
</blockquote>
<h5 id="hexadecimal-integer-literals">Hexadecimal integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of hexadecimal digit symbols (<code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, <code>A</code> through <code>F</code>) prefixed by <code>0x</code> or <code>0X</code> is a hexadecimal integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<h5 id="binary-integer-literals">Binary integer literals</h5>
<div class="paragraph">
<p><span class="sentence">A sequence of binary digit symbols (<code>0</code> or <code>1</code>) prefixed by <code>0b</code> or <code>0B</code> is a binary integer literal. </span><span class="sentence">Digits may be separated by an underscore symbol, but no underscore can be placed before the first digit or after the last one.</span></p>
</div>
<h4 id="the-types-for-integer-literals">The types for integer literals</h4>
<div class="paragraph">
<p><span class="sentence">Any of the decimal, hexadecimal or binary literals may be suffixed by the long literal mark (symbol <code>L</code>). </span><span class="sentence">An integer literal with the long literal mark has type <code>kotlin.Long</code>. </span><span class="sentence">A literal without the mark has a special <a href="#integer-literal-types">integer literal type</a> dependent on the value of the literal:</span></p>
</div>
<ul>
<li><span class="sentence">If the value is greater than maximum <code>kotlin.Long</code> value (see <a href="#built-in-integer-types">built-in integer types</a>), it is an illegal integer literal and a compiler error;</span></li>
<li><span class="sentence">Otherwise, if the value is greater than maximum <code>kotlin.Int</code> value (see <a href="#built-in-integer-types">built-in integer types</a>), it has type <code>kotlin.Long</code>;</span></li>
<li><span class="sentence">Otherwise, it has an integer literal type containing all the built-in integer types that are guaranteed to be able to represent this value.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for example, integer literal <code>0x01</code> has value <span class="math inline">\(1\)</span> and therefore has type <span class="math inline">\(\mathtt{LTS}(\mathtt{kotlin.Byte}, \mathtt{kotlin.Short}, \mathtt{kotlin.Int}, \mathtt{kotlin.Long})\)</span>. </span><span class="sentence">Integer literal <code>70000</code> has value <span class="math inline">\(70000\)</span>, which is not representable using types <code>kotlin.Byte</code> and <code>kotlin.Short</code> and therefore has type <span class="math inline">\(\mathtt{LTS}(\mathtt{kotlin.Int}, \mathtt{kotlin.Long})\)</span>.</span></p>
</div>
</blockquote>
<h4 id="real-literals">Real literals</h4>
<dl>
<dt><strong><em>RealLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>FloatLiteral</em> | <em>DoubleLiteral</em></span>
</dd>
<dt><strong><em>FloatLiteral</em>:</strong></dt>
<dd><span class="sentence"><em>DoubleLiteral</em> (<code>f</code> | <code>F</code>) | <em>DecDigits</em> (<code>f</code> | <code>F</code>)</span>
</dd>
<dt><strong><em>DoubleLiteral</em>:</strong></dt>
<dd><span class="sentence">[<em>DecDigits</em>] <code>.</code> <em>DecDigits</em> [<em>DoubleExponent</em>] | <em>DecDigits</em> <em>DoubleExponent</em></span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>real literal</em> consists of the following parts: the whole-number part, the decimal point (ASCII period character <code>.</code>), the fraction part and the exponent. </span><span class="sentence">Unlike other languages, Kotlin real literals may only be expressed in decimal numbers. </span><span class="sentence">A real literal may also be followed by a type suffix (<code>f</code> or <code>F</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The exponent is an exponent mark (<code>e</code> or <code>E</code>) followed by an optionaly signed decimal integer (a sequence of decimal digits).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The whole-number part and the exponent part may be omitted. </span><span class="sentence">The fraction part may be omitted only together with the decimal point, if the whole-number part and either the exponent part or the type suffix are present. </span><span class="sentence">Unlike other languages, Kotlin does not support omitting the fraction part, but leaving the decimal point in.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The digits of the whole-number part or the fraction part or the exponent may be optionally separated by underscores, but an underscore may not be placed between, before, or after these parts. </span><span class="sentence">It also may not be placed before or after the exponent mark symbol.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A real literal without the type suffix has type <code>kotlin.Double</code>, a real literal with the type suffix has type <code>kotlin.Float</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means there is no special suffix associated with type <code>kotlin.Double</code>.</span></p>
</div>
</blockquote>
<h4 id="character-literals">Character literals</h4>
<dl>
<dt><strong><em>CharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>'</code> (<em>EscapeSeq</em> | <em>&lt;any character except CR, LF, <code>'</code> and <code>\</code>&gt;</em>) <code>'</code></span>
</dd>
<dt><strong><em>EscapeSeq</em>:</strong></dt>
<dd><span class="sentence"><em>UnicodeCharacterLiteral</em> | <em>EscapedCharacter</em></span>
</dd>
<dt><strong><em>UnicodeCharacterLiteral</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> <code>u</code> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em> <em>HexDigit</em></span>
</dd>
<dt><strong><em>EscapedCharacter</em>:</strong></dt>
<dd><span class="sentence"><code>\</code> (<code>t</code> | <code>b</code> | <code>r</code> | <code>n</code> | <code>'</code> | <code>&quot;</code> | <code>\</code> | <code>$</code>)</span>
</dd>
</dl>
<div class="paragraph">
<p><span class="sentence">A <em>character literal</em> defines a constant holding a unicode character value. </span><span class="sentence">A simply-formed character literal is any symbol between two single quotation marks (ASCII single quotation character <code>'</code>), excluding newline symbols (<em>CR</em> and <em>LF</em>), the single quotation mark itself and the escaping mark (ASCII backslash character <code>\</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A character literal may also contain an escaped symbol of two kinds: a simple escaped symbol or a unicode codepoint. </span><span class="sentence">Simple escaped symbols include:</span></p>
</div>
<ul>
<li><span class="sentence"><code>\t</code> — the unicode TAB symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\b</code> — the unicode BACKSPACE symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\r</code> — <em>CR</em>;</span></li>
<li><span class="sentence"><code>\n</code> — <em>LF</em>;</span></li>
<li><span class="sentence"><code>\'</code> — the unicode single quotation symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\&quot;</code> — the unicode double quotation symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\\</code> — the unicode backslash symbol symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>;</span></li>
<li><span class="sentence"><code>\$</code> — the unicode DOLLAR symbol <span><span class="TODO">(TODO())</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A unicode codepoint escaped symbol is the symbol <code>\u</code> followed by exactly four hexadecimal digits. </span><span class="sentence">It represents the unicode symbol with the codepoint equal to the number represented by these four digits.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means unicode codepoint escaped symbols support only unicode symbols in range from U+0000 to U+FFFF.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">All character literals have type <code>kotlin.Char</code>.</span></p>
</div>
<h4 id="string-literals-1">String literals</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <a href="#string-interpolation-expressions">string interpolation</a> which supersedes traditional string literals. </span><span class="sentence">For further details, please refer to the corresponding section.</span></p>
</div>
<h4 id="null-literal">Null literal</h4>
<div class="paragraph">
<p><span class="sentence">The keyword <code>null</code> denotes the <strong>null reference</strong>, which represents an absence of a value and is a valid value only for <a href="#nullable-types">nullable types</a>. </span><span class="sentence">Null reference has type <a href="#kotlin.nothing"><code>kotlin.Nothing?</code></a> and is, by definition, the only value of this type.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(rearrange these sections)</span></p>
</div>
</div>
<h3 id="try-expression">Try-expression</h3>
<div id="grammar-rule-tryExpression-pasted-20" class="grammar-rule">
<dl>
<dt><strong><em>tryExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'try'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em> ((({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-catchBlock">catchBlock</a></em>}) [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>]) | ({<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-finallyBlock">finallyBlock</a></em>))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-catchBlock-pasted-21" class="grammar-rule">
<dl>
<dt><strong><em>catchBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'catch'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'('</code><br />
{<em><a href="#grammar-rule-annotation">annotation</a></em>}<br />
<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em><br />
<code>':'</code><br />
<em><a href="#grammar-rule-type">type</a></em><br />
<code>')'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-finallyBlock-pasted-22" class="grammar-rule">
<dl>
<dt><strong><em>finallyBlock</em>:</strong></dt>
<dd><span class="sentence"><code>'finally'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-block">block</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>try-expression</em> is an expression starting with the keyword <code>try</code>. </span><span class="sentence">It consists of a <a href="#code-blocks">code block</a> (<em>try body</em>) and one or more of the following kinds of blocks: zero or more <em>catch blocks</em> and an optional <em>finally block</em>. </span><span class="sentence">A <em>catch block</em> starts with the soft keyword <code>catch</code> with a single <em>exception parameter</em>, which is followed by a <a href="#code-blocks">code block</a>. </span><span class="sentence">A <em>finally block</em> starts with the soft keyword <code>finally</code>, which is followed by a <a href="#code-blocks">code block</a>. </span><span class="sentence">A valid try-expression must have at least one catch or finally block.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The try-expression evaluation evaluates its body; if any statement in the try body throws an exception (of type <span class="math inline">\(E\)</span>), this exception, rather than being immediately propagated up the call stack, is checked for a matching catch block. </span><span class="sentence">If a catch block of this try-expression has an exception parameter of type <span class="math inline">\(T :&gt; E\)</span>, this catch block is evaluated immediately after the exception is thrown and the exception itself is passed inside the catch block as the corresponding parameter. </span><span class="sentence">If there are several catch blocks which match the exception type, the first one is picked.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Exception handling?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If there is a finally block, it is evaluated after the evaluation of all previous try-expression blocks, meaning:</span></p>
</div>
<ul>
<li><span class="sentence">If no exception is thrown during the evaluation of the try body, no catch blocks are executed, the finally block is evaluated after the try body, and the program execution continues as normal.</span></li>
<li><span class="sentence">If an exception was thrown, and one of the catch blocks matched its type, the finally block is evaluated after the evaluation of the matching catch block.</span></li>
<li><span class="sentence">If an exception was thrown, but no catch block matched its type, the finally block is evaluated before <a href="#exceptions">propagating the exception</a> up the call stack.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The value of the try-expression is the same as the value of the <a href="#code-blocks">last expression</a> of the try body (if no exception was thrown) or the value of the last expression of the matching catch block (if an exception was thrown and matched). </span><span class="sentence">All other situations mean that an exception is going to be propagated up the call stack, and the value of the try-expression becomes irrelevant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as desribed, the finally block (if present) is executed regardless, but it has no effect on the value returned by the try-expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of the try-expression is the <a href="#least-upper-bound">least upper bound</a> of the types of the last expressions of the try body and the last expressions of all the catch blocks <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules mean the try-expression always may be used as an expression, as it always has a corresponding result value.</span></p>
</div>
</blockquote>
<h3 id="conditional-expression">Conditional expression</h3>
<div id="grammar-rule-ifExpression-pasted-23" class="grammar-rule">
<dl>
<dt><strong><em>ifExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))<br />
| (<code>'if'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} [<code>';'</code>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> | <code>';'</code>))</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Conditional expressions</em> use a boolean value of one expression (<em>condition</em>) to decide which of the two <a href="#code-blocks">control structure bodies</a> (<em>branches</em>) should be evaluated. </span><span class="sentence">If the condition evaluates to <code>true</code>, the first branch (the <em>true branch</em>) is evaluated if it is present, otherwise the second branch (the <em>false branch</em>) is evaluated if it is present.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means the following branchless conditional expression, despite being of almost no practical use, is valid in Kotlin</span></p>
</div>
<div class="sourceCode" id="cb30"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb30-1" title="1"><span class="cf">if</span> (condition) <span class="cf">else</span>;</a></code></pre></div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The value of the resulting expression is the same as the value of the chosen branch.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the <a href="#least-upper-bound">least upper bound</a> of the types of two branches <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>, if both branches are present. </span><span class="sentence">If either of the branches are omitted, the resulting conditional expression has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and may used only as a statement.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the condition expression must be a subtype of <code>kotlin.Boolean</code>, otherwise it is an error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when used as expressions, conditional expressions are special w.r.t. operator precedence: they have the highest priority (the same as for all primary expressions) when placed on the right side of any binary expression, but when placed on the left side, they have the lowest priority. </span><span class="sentence">For details, see Kotlin <a href="#syntax-grammar">grammar</a>.</span></p>
</div>
</blockquote>
<h3 id="when-expression">When expression</h3>
<div id="grammar-rule-whenExpression-pasted-24" class="grammar-rule">
<dl>
<dt><strong><em>whenExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'when'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
[<code>'('</code> <em><a href="#grammar-rule-expression">expression</a></em> <code>')'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'{'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
{<em><a href="#grammar-rule-whenEntry">whenEntry</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>}}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenEntry-pasted-25" class="grammar-rule">
<dl>
<dt><strong><em>whenEntry</em>:</strong></dt>
<dd><span class="sentence">(<em><a href="#grammar-rule-whenCondition">whenCondition</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-whenCondition">whenCondition</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])<br />
| (<code>'else'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-controlStructureBody">controlStructureBody</a></em> [<em><a href="#grammar-rule-semi">semi</a></em>])</span>
</dd>
</dl>
</div>
<div id="grammar-rule-whenCondition-pasted-26" class="grammar-rule">
<dl>
<dt><strong><em>whenCondition</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-expression">expression</a></em><br />
| <em><a href="#grammar-rule-rangeTest">rangeTest</a></em><br />
| <em><a href="#grammar-rule-typeTest">typeTest</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-rangeTest-pasted-27" class="grammar-rule">
<dl>
<dt><strong><em>rangeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeTest-pasted-28" class="grammar-rule">
<dl>
<dt><strong><em>typeTest</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>When expression</em> is similar to a <a href="#conditional-expression">conditional expression</a> in that it allows one of several different <a href="#code-blocks">control structure bodies</a> (<em>cases</em>) to be evaluated, depending on some boolean conditions. </span><span class="sentence">The key difference is exactly that a when expressions may include several different conditions with their corresponding control structure bodies. </span><span class="sentence">When expression has two different forms: with bound value and without it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><strong>When expression without bound value</strong> (the form where the expression enclosed in parentheses after the <code>when</code> keyword is absent) evaluates one of the different CSBs based on its condition from the <em>when entry</em>. </span><span class="sentence">Each when entry consists of a boolean <em>condition</em> (or a special <code>else</code> condition) and its corresponding CSB. </span><span class="sentence">When entries are checked and evaluated in their order of appearance. </span><span class="sentence">If the condition evaluates to <code>true</code>, the corresponding CSB is evaluated and the value of when expression is the same as the value of the CSB. </span><span class="sentence">All remaining conditions and expressions are not evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <code>else</code> condition is a special condition which evaluates to <code>true</code> if none of the branches above it evaluated to <code>true</code>. </span><span class="sentence">The <code>else</code> condition <strong>must</strong> also be in the last when entry of when expression, otherwise it is a compile-time error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, you can always replace the <code>else</code> condition with an always-<code>true</code> condition (e.g., boolean literal <code>true</code>) with no change to the resulting semantics.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence"><strong>When expression with bound value</strong> (the form where the expression enclosed in parentheses after the <code>when</code> keyword is present) are similar to the form without bound value, but use a different syntax for conditions. </span><span class="sentence">In fact, it supports three different condition forms:</span></p>
</div>
<ul>
<li><span class="sentence"><em>Type test condition</em>: <a href="#type-checking-expression">type checking operator</a> followed by a type (<code>is T</code>). </span><span class="sentence">The resulting condition is a <a href="#type-checking-expression">type check expression</a> of the form <code>boundValue is T</code>.</span></li>
<li><span class="sentence"><em>Contains test condition</em>: <a href="#containment-checking-expression">containment operator</a> followed by an expression (<code>in Expr</code>). </span><span class="sentence">The resulting condition is a <a href="#containment-checking-expression">containment check expression</a> of the form <code>boundValue in Expr</code>.</span></li>
<li><span class="sentence"><em>Any other expression</em> (<code>Expr</code>). </span><span class="sentence">The resulting condition is an <a href="#equality-expressions">equality check</a> of the form <code>boundValue == Expr</code>.</span></li>
<li><span class="sentence">The <code>else</code> condition, which is a special condition which evaluates to <code>true</code> if none of the branches above it evaluated to <code>true</code>. </span><span class="sentence">The <code>else</code> condition <strong>must</strong> also be in the last when entry of when expression, otherwise it is a compile-time error.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the rule for “any other expression” means that if a when expression with bound value contains a boolean condition, this condition is <strong>checked for equality</strong> with the bound value, instead of being used directly for when entry selection.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The type of the resulting expression is the <a href="#least-upper-bound">least upper bound</a> of the types of all its entries <span><span class="TODO">(TODO(not that simple))</span><span class="TODO-marker">*</span></span>. </span><span class="sentence">If the when expression is not <a href="#exhaustive-when-expressions">exhaustive</a>, it has type <a href="#kotlin.unit"><code>kotlin.Unit</code></a> and may used only as a statement.</span></p>
</div>
<h4 id="exhaustive-when-expressions">Exhaustive when expressions</h4>
<div class="paragraph">
<p><span class="sentence">A when expression is called <strong><em>exhaustive</em></strong> if at least one of the following is true:</span></p>
</div>
<ul>
<li><span class="sentence">It has an <code>else</code> entry;</span></li>
<li><span class="sentence">It has a bound value and at least one of the following is true:</span>
<ul>
<li><span class="sentence">The bound expression is of type <code>kotlin.Boolean</code> and the conditions contain both:</span>
<ul>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to <code>true</code>;</span></li>
<li><span class="sentence">A [constant expression][Constant expressions] evaluating to <code>false</code>;</span></li>
</ul></li>
<li><span class="sentence">The bound expression is of a [<code>sealed class</code>][Sealed classes] type and all of its subtypes are covered using type test conditions in this expression. </span><span class="sentence">This should include checks for all direct subtypes of this sealed class. </span><span class="sentence">If any of the direct subtypes is also a sealed class, there should either be a check for this subtype or all its subtypes should be covered;</span></li>
<li><span class="sentence">The bound expression is of an <a href="#enum-class-declaration"><code>enum class</code></a> type and all its enumerated values are checked for equality using constant expression;</span></li>
<li><span class="sentence">The bound expression is of a <a href="#nullable-types">nullable type</a> <span class="math inline">\(T?\)</span> and one of the cases above is met for its non-nullable counterpart <span class="math inline">\(T\)</span> together with another condition which checks the bound value for equality with <code>null</code>.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Equality check with object behaves kinda like a type check. </span><span class="sentence">Or not.)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, an exhaustive when expression is guaranteed to evaluate one of its CSBs regardless of the specific when conditions.</span></p>
</div>
</blockquote>
<h3 id="logical-disjunction-expression">Logical disjunction expression</h3>
<div id="grammar-rule-disjunction-pasted-29" class="grammar-rule">
<dl>
<dt><strong><em>disjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-conjunction">conjunction</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'||'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-conjunction">conjunction</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>||</code> performs logical disjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">This operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>false</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Both operands of a logical disjunction expression must have a type which is a subtype of <code>kotlin.Boolean</code>, otherwise it is a type error. </span><span class="sentence">The type of logical disjunction expression is <code>kotlin.Boolean</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Types of errors? </span><span class="sentence">Compile-time, type, run-time, whatever?)</span></p>
</div>
</div>
<h3 id="logical-conjunction-expression">Logical conjunction expression</h3>
<div id="grammar-rule-conjunction-pasted-30" class="grammar-rule">
<dl>
<dt><strong><em>conjunction</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-equality">equality</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&amp;&amp;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-equality">equality</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Operator symbol <code>&amp;&amp;</code> performs logical conjunction over two values of type <code>kotlin.Boolean</code>. </span><span class="sentence">This operator is <strong>lazy</strong>, meaning that it does not evaluate the right hand side argument unless the left hand side argument evaluated to <code>true</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Both operands of a logical conjunction expression must have a type which is a subtype of <code>kotlin.Boolean</code>, otherwise it is a type error. </span><span class="sentence">The type of logical disjunction expression is <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="equality-expressions">Equality expressions</h3>
<div id="grammar-rule-equality-pasted-31" class="grammar-rule">
<dl>
<dt><strong><em>equality</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-comparison">comparison</a></em> {<em><a href="#grammar-rule-equalityOperator">equalityOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-comparison">comparison</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-equalityOperator-pasted-32" class="grammar-rule">
<dl>
<dt><strong><em>equalityOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'!='</code><br />
| <code>'!=='</code><br />
| <code>'=='</code><br />
| <code>'==='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Equality expressions are binary expressions involving equality operators. </span><span class="sentence">There are two kinds of equality operators: <em>reference equality operators</em> and <em>value equality operators</em>.</span></p>
</div>
<h4 id="reference-equality-expressions">Reference equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Reference equality expressions</em> are binary expressions which use reference equality operators: <code>===</code> and <code>!==</code>. </span><span class="sentence">These expressions check if two values are equal (<code>===</code>) or non-equal (<code>!==</code>) <em>by reference</em>: two values are equal by reference if and only if they represent the same runtime value.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For special values created without explicit constructor calls, notably, the constant literals and constant expressions composed of those literals, the following holds:</span></p>
</div>
<ul>
<li><span class="sentence">If these values are <a href="#value-equality-expressions">non-equal by value</a>, they are also non-equal by reference;</span></li>
<li><span class="sentence">Any instance of the null reference <code>null</code> is equal by reference to any other instance of the null reference;</span></li>
<li><span class="sentence">Otherwise, equality by reference is implementation-defined and must not be used as a means of comparing such values.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Reference equality expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h4 id="value-equality-expressions">Value equality expressions</h4>
<div class="paragraph">
<p><span class="sentence"><em>Value equality expressions</em> are binary expressions which use value equality operators: <code>==</code> and <code>!=</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A == B</code> is exactly the same as <code>A?.equals(B) ?: (B === null)</code> where <code>equals</code> is a valid operator function available in the current scope;</span></li>
<li><span class="sentence"><code>A != B</code> is exactly the same as <code>!(A?.equals(B) ?: (B === null))</code> where <code>equals</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: <code>kotlin.Any</code> type has a built-in open operator member function <code>equals</code>, meaning there is always at least one available overloading candidate for any value equality expression.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Value equality expressions always have type <code>kotlin.Boolean</code>. </span><span class="sentence">If the corresponding operator function <code>equals</code> has a different return type, it is a compile-time error.</span></p>
</div>
<h3 id="comparison-expressions">Comparison expressions</h3>
<div id="grammar-rule-comparison-pasted-33" class="grammar-rule">
<dl>
<dt><strong><em>comparison</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixOperation">infixOperation</a></em> [<em><a href="#grammar-rule-comparisonOperator">comparisonOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixOperation">infixOperation</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-comparisonOperator-pasted-34" class="grammar-rule">
<dl>
<dt><strong><em>comparisonOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
| <code>'&gt;'</code><br />
| <code>'&lt;='</code><br />
| <code>'&gt;='</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Comparison expressions</em> are binary expressions which use the comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A &lt; B</code> is exactly the same as <code>A.compareTo(B) [&lt;] 0</code></span></li>
<li><span class="sentence"><code>A &gt; B</code> is exactly the same as <code>0 [&lt;] A.compareTo(B)</code></span></li>
<li><span class="sentence"><code>A &lt;= B</code> is exactly the same as <code>!(A.compareTo(B) [&lt;] 0)</code></span></li>
<li><span class="sentence"><code>A &gt;= B</code> is exactly the same as <code>!(0 [&lt;] A.compareTo(B))</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>compareTo</code> is a valid operator function available in the current scope and <code>[&lt;]</code> (read “boxed less”) is a special operator unavailable in user-side Kotlin which performs integer “less-than” comparison of two integer numbers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The <code>compareTo</code> operator function must have a return type <code>kotlin.Int</code>, otherwise it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All comparison expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="type-checking-and-containment-checking-expressions">Type-checking and containment-checking expressions</h3>
<div id="grammar-rule-infixOperation-pasted-35" class="grammar-rule">
<dl>
<dt><strong><em>infixOperation</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em> {(<em><a href="#grammar-rule-inOperator">inOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvisExpression">elvisExpression</a></em>) | (<em><a href="#grammar-rule-isOperator">isOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>)}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-inOperator-pasted-36" class="grammar-rule">
<dl>
<dt><strong><em>inOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'in'</code><br />
| <em><a href="#grammar-rule-NOT_IN">NOT_IN</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-isOperator-pasted-37" class="grammar-rule">
<dl>
<dt><strong><em>isOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'is'</code><br />
| <em><a href="#grammar-rule-NOT_IS">NOT_IS</a></em></span>
</dd>
</dl>
</div>
<h4 id="type-checking-expression">Type-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A type-checking expression uses a type-checking operator <code>is</code> or <code>!is</code> and has an expression <span class="math inline">\(E\)</span> as a left-hand side operand and a type name <span class="math inline">\(T\)</span> as a right-hand side operand. </span><span class="sentence">The type <span class="math inline">\(T\)</span> must be <a href="#runtime-available-types">runtime-available</a>, otherwise it is a compiler error. </span><span class="sentence">A type-checking expression checks whether the runtime type of <span class="math inline">\(E\)</span> is a subtype of <span class="math inline">\(T\)</span> for <code>is</code> operator, or not a subtype of <span class="math inline">\(T\)</span> for <code>!is</code> operator.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Type-checking expression always has type <code>kotlin.Boolean</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the expression <code>null is T?</code> for any type <code>T</code> always evaluates to <code>true</code>, as the type of the left-hand side (<code>null</code>) is <code>kotlin.Nothing?</code>, which is a subtype of any nullable type <code>T?</code>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: type-checking expressions may create <a href="#smart-casts">smart casts</a>, for further details, refer to the corresponding section.</span></p>
</div>
</blockquote>
<h4 id="containment-checking-expression">Containment-checking expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>containment-checking expression</em> is a binary expression which uses a containment operator <code>in</code> or <code>!in</code>. </span><span class="sentence">These operators are <a href="#overloadable-operators">overloadable</a> with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A in B</code> is exactly the same as <code>B.contains(A)</code>;</span></li>
<li><span class="sentence"><code>A !in B</code> is exactly the same as <code>!(B.contains(A))</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>contains</code> is a valid operator function available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, contrary to the order of appearance in the code, the right-hand side expression of a containment-checking expression is evaluated before its left-hand side expression</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The <code>contains</code> function must have a return type <code>kotlin.Boolean</code>, otherwise it is a compile-time error. </span><span class="sentence">Containment-checking expressions always have type <code>kotlin.Boolean</code>.</span></p>
</div>
<h3 id="elvis-operator-expression">Elvis operator expression</h3>
<div id="grammar-rule-elvisExpression-pasted-38" class="grammar-rule">
<dl>
<dt><strong><em>elvisExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-elvis">elvis</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-infixFunctionCall">infixFunctionCall</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>elvis operator expression</em> is a binary expression which uses an elvis operator (<code>?:</code>). </span><span class="sentence">It checks whether the left-hand side expression is reference equal to <code>null</code>, and, if it is, evaluates and return the right-hand side expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This operator is <strong>lazy</strong>, meaning that if the left-hand side expression is not reference equal to <code>null</code>, the right-hand side expression is not evaluated.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of elvis operator expression is the <a href="#least-upper-bound">least upper bound</a> of the non-nullable variant of the type of the left-hand side expression and the type of the right-hand side expression.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(not that simple either)</span></p>
</div>
</div>
<h3 id="range-expression">Range expression</h3>
<div id="grammar-rule-rangeExpression-pasted-39" class="grammar-rule">
<dl>
<dt><strong><em>rangeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em> {<code>'..'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-additiveExpression">additiveExpression</a></em>}</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>range expression</em> is a binary expression which uses a range operator <code>..</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A..B</code> is exactly the same as <code>A.rangeTo(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>rangeTo</code> is a valid operator function available in the current scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The return type of this function is not restricted. </span><span class="sentence">A range expression has the same type as the return type of the corresponding <code>rangeTo</code> overload variant.</span></p>
</div>
<h3 id="additive-expression">Additive expression</h3>
<div id="grammar-rule-additiveExpression-pasted-40" class="grammar-rule">
<dl>
<dt><strong><em>additiveExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em> {<em><a href="#grammar-rule-additiveOperator">additiveOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-multiplicativeExpression">multiplicativeExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-additiveOperator-pasted-41" class="grammar-rule">
<dl>
<dt><strong><em>additiveOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'+'</code><br />
| <code>'-'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>additive expression</em> is a binary expression which uses the addition (<code>+</code>) or subtraction (<code>-</code>) operators. </span><span class="sentence">These are <a href="#overloadable-operators">overloadable</a> operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A + B</code> is exactly the same as <code>A.plus(B)</code></span></li>
<li><span class="sentence"><code>A - B</code> is exactly the same as <code>A.minus(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>plus</code> or <code>minus</code> is a valid operator function available in the current scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The return type of these functions is not restricted. </span><span class="sentence">An additive expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="multiplicative-expression">Multiplicative expression</h3>
<div id="grammar-rule-multiplicativeExpression-pasted-42" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-asExpression">asExpression</a></em> {<em><a href="#grammar-rule-multiplicativeOperator">multiplicativeOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asExpression">asExpression</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiplicativeOperator-pasted-43" class="grammar-rule">
<dl>
<dt><strong><em>multiplicativeOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'*'</code><br />
| <code>'/'</code><br />
| <code>'%'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>multiplicative expression</em> is a binary expression which uses the multiplication (<code>*</code>), division (<code>/</code>) or remainder (<code>%</code>) operators. </span><span class="sentence">These are <a href="#overloadable-operators">overloadable</a> operators with the following expansions:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A * B</code> is exactly the same as <code>A.times(B)</code></span></li>
<li><span class="sentence"><code>A / B</code> is exactly the same as <code>A.div(B)</code></span></li>
<li><span class="sentence"><code>A % B</code> is exactly the same as <code>A.rem(B)</code></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">where <code>times</code>, <code>div</code>, <code>rem</code> is a valid operator function available in the current scope.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as of Kotlin version 1.2.31, there exists an additional overloadable operator for <code>%</code> called <code>mod</code>, which is deprecated.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The return type of these functions is not restricted. </span><span class="sentence">A multiplicative expression has the same type as the return type of the corresponding operator function overload variant.</span></p>
</div>
<h3 id="cast-expression">Cast expression</h3>
<div id="grammar-rule-asExpression-pasted-44" class="grammar-rule">
<dl>
<dt><strong><em>asExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-prefixUnaryExpression">prefixUnaryExpression</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-asOperator">asOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]</span>
</dd>
</dl>
</div>
<div id="grammar-rule-asOperator-pasted-45" class="grammar-rule">
<dl>
<dt><strong><em>asOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'as'</code><br />
| <code>'as?'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>cast expression</em> is a binary expression which uses the cast operators <code>as</code> or <code>as?</code> and has the form <code>E as/as? T</code>, where <span class="math inline">\(E\)</span> is an expression and <span class="math inline">\(T\)</span> is a type name.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <strong><code>as</code> cast expression</strong> <code>E as T</code> is called <em>a unchecked cast</em> expression. </span><span class="sentence">This expression perform a runtime check whether the runtime type of <span class="math inline">\(E\)</span> is a <a href="#subtyping">subtype</a> of <span class="math inline">\(T\)</span> and throws an exception otherwise. </span><span class="sentence">If type <span class="math inline">\(T\)</span> is a <a href="#runtime-available-types">runtime-available</a> type without generic parameters, then this exception is thrown immediately when evaluating the cast expression, otherwise it is platform-dependent whether an exception is thrown at this point.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We need to sort out undefined/implementation-defined/platform-defined)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: even if the exception is not thrown when evaluating the cast expression, it is guaranteed to be thrown later when its result is used with any runtime-available type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">An unchecked cast expression result always has the same type as the type <span class="math inline">\(T\)</span> specified in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An <strong><code>as?</code> cast expression</strong> <code>E as? T</code> is called <em>a checked cast</em> expression. </span><span class="sentence">This expression is similar to the unchecked cast expression in that it also does a runtime type check, but does not throw an exception if the types do not match, it returns <code>null</code> instead. </span><span class="sentence">If type <span class="math inline">\(T\)</span> is not a <a href="#runtime-available-types">runtime-available</a> type, then the check is not performed and <code>null</code> is never returned, leading to potential runtime errors later in the program execution. </span><span class="sentence">This situation should be reported as a compile-time warning.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: if type <span class="math inline">\(T\)</span> is a <a href="#runtime-available-types">runtime-available</a> type <strong>with</strong> generic parameters, type parameters are <strong>not</strong> checked w.r.t. subtyping. </span><span class="sentence">This is another porentially erroneous situation, which should be reported as a compile-time warning.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The checked cast expression type is the <a href="#nullable-types">nullable</a> variant of the type <span class="math inline">\(T\)</span>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: cast expressions may create <a href="#smart-casts">smart casts</a>, for further details, refer to the corresponding section.</span></p>
</div>
</blockquote>
<h3 id="prefix-expressions">Prefix expressions</h3>
<div id="grammar-rule-prefixUnaryExpression-pasted-46" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-unaryPrefix">unaryPrefix</a></em>} <em><a href="#grammar-rule-postfixUnaryExpression">postfixUnaryExpression</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-unaryPrefix-pasted-47" class="grammar-rule">
<dl>
<dt><strong><em>unaryPrefix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-annotation">annotation</a></em><br />
| <em><a href="#grammar-rule-label">label</a></em><br />
| (<em><a href="#grammar-rule-prefixUnaryOperator">prefixUnaryOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>})</span>
</dd>
</dl>
</div>
<div id="grammar-rule-prefixUnaryOperator-pasted-48" class="grammar-rule">
<dl>
<dt><strong><em>prefixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| <code>'-'</code><br />
| <code>'+'</code><br />
| <em><a href="#grammar-rule-excl">excl</a></em></span>
</dd>
</dl>
</div>
<h4 id="annotated-and-labeled-expression">Annotated and labeled expression</h4>
<div class="paragraph">
<p><span class="sentence">Any expression in Kotlin may be prefixed with any number of <a href="#annotations">annotations</a> and [labels][Labels]. </span><span class="sentence">These do not change the value of the expression and can be used by external tools and for implementing platform-dependent features.</span></p>
</div>
<h4 id="prefix-increment-expression">Prefix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix increment</em> expression is an expression which uses the prefix form of operator <code>++</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>++A</code> is exactly the same as <code>A = A.inc(); A</code> where <code>inc</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>++A</code> assigns the result of <code>A.inc()</code> to <code>A</code> and then returns <code>A</code> as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a prefix increment expression <code>++A</code> expression <code>A</code> must be <a href="#assignments">an assignable expression</a>. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A prefix increment expression has the same type as the return type of the corresponding <code>inc</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>inc</code> is assigned to <code>A</code>, the return type of <code>inc</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="prefix-decrement-expression">Prefix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>prefix decrement</em> expression is an expression which uses the prefix form of operator <code>--</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>--A</code> is exactly the same as <code>A = A.dec(); A</code> where <code>dec</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>--A</code> assigns the result of <code>A.dec()</code> to <code>A</code> and then returns <code>A</code> as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a prefix decrement expression <code>--A</code> expression <code>A</code> must be <a href="#assignments">an assignable expression</a>. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A prefix decrement expression has the same type as the return type of the corresponding <code>dec</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>dec</code> is assigned to <code>A</code>, the return type of <code>dec</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="unary-minus-expression">Unary minus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary minus</em> expression is an expression which uses the prefix form of operator <code>-</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>-A</code> is exactly the same as <code>A.unaryMinus()</code> where <code>unaryMinus</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="unary-plus-expression">Unary plus expression</h4>
<div class="paragraph">
<p><span class="sentence">An <em>unary plus</em> expression is an expression which uses the prefix form of operator <code>+</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>+A</code> is exactly the same as <code>A.unaryPlus()</code> where <code>unaryPlus</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h4 id="logical-not-expression">Logical not expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>logical not</em> expression is an expression which uses the prefix operator <code>!</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>!A</code> is exactly the same as <code>A.not()</code> where <code>not</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">No additional restrictions apply.</span></p>
</div>
<h3 id="postfix-operator-expressions">Postfix operator expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-49" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-50" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnaryOperator-pasted-51" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'++'</code><br />
| <code>'--'</code><br />
| (<em><a href="#grammar-rule-EXCL_NO_WS">EXCL_NO_WS</a></em> <em><a href="#grammar-rule-excl">excl</a></em>)</span>
</dd>
</dl>
</div>
<h4 id="postfix-increment-expression">Postfix increment expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix increment</em> expression is an expression which uses the postfix form of operator <code>++</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A++</code> is exactly the same as <code>val $freshId = A; A = A.inc(); $freshId</code> where <code>inc</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>A++</code> stores the value of A to a temporary variable, assigns the result of <code>A.inc()</code> to <code>A</code> and then returns the temporary variable as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a postfix increment expression <code>A++</code> expression <code>A</code> must be [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A postfix increment expression has the same type as the return type of the corresponding <code>inc</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>inc</code> is assigned to <code>A</code>, the return type of <code>inc</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h4 id="postfix-decrement-expression">Postfix decrement expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>postfix decrement</em> expression is an expression which uses the postfix form of operator <code>--</code>. </span><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A--</code> is exactly the same as <code>val $freshId = A; A = A.dec(); $freshId</code> where <code>dec</code> is a valid operator function available in the current scope.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, <code>A--</code> stores the value of A to a temporary variable, assigns the result of <code>A.dec()</code> to <code>A</code> and then returns the temporary variable as the result.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For a postfix decrement expression <code>A--</code> expression <code>A</code> must be [assignable expressions][Assignable expressions]. </span><span class="sentence">Otherwise, it is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A postfix decrement expression has the same type as the return type of the corresponding <code>dec</code> overload variant.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as the result of <code>dec</code> is assigned to <code>A</code>, the return type of <code>dec</code> must be a subtype of <code>A</code>.</span></p>
</div>
</blockquote>
<h3 id="not-null-assertion-expression">Not-null assertion expression</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(We need to define what “evaluation” is)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>not-null assertion expression</em> is a postfix expression which uses an operator <code>!!</code>. </span><span class="sentence">For an expression <code>e!!</code>, if the type of <code>e</code> is nullable, a not-null assertion expression checks, whether the evaluation result of <code>e</code> is equal to <code>null</code> and, if it is, throws a runtime exception. </span><span class="sentence">If the evaluation result of <code>e</code> is not equal to <code>null</code>, the result of <code>e!!</code> is the evaluation result of <code>e</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If the type of <code>e</code> is non-nullable, not-null assertion expression <code>e!!</code> has no effect.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The type of non-null assertion expression is the <a href="#nullable-types">non-nullable</a> variant of the type of <code>e</code>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this type may be non-denotable in Kotlin and, as such, may be <a href="#type-approximation">approximated</a> in some situations with the help of <a href="#type-inference">type inference</a>.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Example)</span></p>
</div>
</div>
<h3 id="indexing-expressions">Indexing expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-52" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-53" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-indexingSuffix-pasted-54" class="grammar-rule">
<dl>
<dt><strong><em>indexingSuffix</em>:</strong></dt>
<dd><span class="sentence"><code>'['</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>']'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>indexing expression</em> is a suffix expression which uses one or more subexpression as <em>indices</em> between square brackets (<code>[</code> and <code>]</code>).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is an <a href="#overloadable-operators">overloadable</a> operator with the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>A[I_0,I_1,...,I_N]</code> is exactly the same as <code>A.get(I_0,I_1,...,I_N)</code>, where <code>get</code> is a valid operator function available in the current scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An indexing expression has the same type as the corresponding <code>get</code> expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Indexing expressions are [assignable][Assignable expressions]. </span><span class="sentence">For a corresponding assignment form, see [indexing assignment][Indexing assignment].</span></p>
</div>
<h3 id="call-and-property-access-expressions">Call and property access expressions</h3>
<div id="grammar-rule-postfixUnaryExpression-pasted-55" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnaryExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em><br />
| (<em><a href="#grammar-rule-primaryExpression">primaryExpression</a></em> (<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em> {<em><a href="#grammar-rule-postfixUnarySuffix">postfixUnarySuffix</a></em>}))</span>
</dd>
</dl>
</div>
<div id="grammar-rule-postfixUnarySuffix-pasted-56" class="grammar-rule">
<dl>
<dt><strong><em>postfixUnarySuffix</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-postfixUnaryOperator">postfixUnaryOperator</a></em><br />
| <em><a href="#grammar-rule-typeArguments">typeArguments</a></em><br />
| <em><a href="#grammar-rule-callSuffix">callSuffix</a></em><br />
| <em><a href="#grammar-rule-indexingSuffix">indexingSuffix</a></em><br />
| <em><a href="#grammar-rule-navigationSuffix">navigationSuffix</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-navigationSuffix-pasted-57" class="grammar-rule">
<dl>
<dt><strong><em>navigationSuffix</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-memberAccessOperator">memberAccessOperator</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} (<em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em> | <em><a href="#grammar-rule-parenthesizedExpression">parenthesizedExpression</a></em> | <code>'class'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-callSuffix-pasted-58" class="grammar-rule">
<dl>
<dt><strong><em>callSuffix</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] [<em><a href="#grammar-rule-valueArguments">valueArguments</a></em>] <em><a href="#grammar-rule-annotatedLambda">annotatedLambda</a></em>)<br />
| ([<em><a href="#grammar-rule-typeArguments">typeArguments</a></em>] <em><a href="#grammar-rule-valueArguments">valueArguments</a></em>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-annotatedLambda-pasted-59" class="grammar-rule">
<dl>
<dt><strong><em>annotatedLambda</em>:</strong></dt>
<dd><span class="sentence">{<em><a href="#grammar-rule-annotation">annotation</a></em>} [<em><a href="#grammar-rule-label">label</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaLiteral">lambdaLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-valueArguments-pasted-60" class="grammar-rule">
<dl>
<dt><strong><em>valueArguments</em>:</strong></dt>
<dd><span class="sentence">(<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)<br />
| (<code>'('</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-valueArgument">valueArgument</a></em>} {<em><a href="#grammar-rule-NL">NL</a></em>} <code>')'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeArguments-pasted-61" class="grammar-rule">
<dl>
<dt><strong><em>typeArguments</em>:</strong></dt>
<dd><span class="sentence"><code>'&lt;'</code><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-typeProjection">typeProjection</a></em><br />
{{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeProjection">typeProjection</a></em>}<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'&gt;'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjection-pasted-62" class="grammar-rule">
<dl>
<dt><strong><em>typeProjection</em>:</strong></dt>
<dd><span class="sentence">([<em><a href="#grammar-rule-typeProjectionModifiers">typeProjectionModifiers</a></em>] <em><a href="#grammar-rule-type">type</a></em>)<br />
| <code>'*'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-typeProjectionModifiers-pasted-63" class="grammar-rule">
<dl>
<dt><strong><em>typeProjectionModifiers</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em> {<em><a href="#grammar-rule-typeProjectionModifier">typeProjectionModifier</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-memberAccessOperator-pasted-64" class="grammar-rule">
<dl>
<dt><strong><em>memberAccessOperator</em>:</strong></dt>
<dd><span class="sentence"><code>'.'</code><br />
| <em><a href="#grammar-rule-safeNav">safeNav</a></em><br />
| <code>'::'</code></span>
</dd>
</dl>
</div>
<h4 id="navigation-operators">Navigation operators</h4>
<div class="paragraph">
<p><span class="sentence">Expressions which use the navigation binary operators (<code>.</code>, <code>.?</code> or <code>::</code>) are syntactically similar, but, in fact, may have very different semantics.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><code>a.c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><div class="paragraph">
<p><span class="sentence">A fully-qualified type, property or object name. </span><span class="sentence">The left side of <code>.</code> must be a package name, while the right side corresponds to a declaration in that package.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: qualification uses operator <code>.</code> only.</span></p>
</div>
</blockquote></li>
<li><span class="sentence">A property access. </span><span class="sentence">Here <code>a</code> is a value available in the current scope and <code>c</code> is a property name.</span></li>
<li><div class="paragraph">
<p><span class="sentence">A function call if followed by the call suffix (arguments in parentheses). </span><span class="sentence">Here <code>a</code> is a value available in the current scope and <code>c</code> is a function name. </span><span class="sentence">These expressions follow the <a href="#overload-resolution">overloading</a> rules.</span></p>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><code>a::c</code> may have one of the following semantics when used as an expression:</span></p>
</div>
<ul>
<li><span class="sentence">A <a href="#class-literals">class literal expression</a> if, instead of an identifier, <code>c</code> is the keyword <code>class</code>;</span></li>
<li><span class="sentence">A <a href="#callable-references">property reference</a>. </span><span class="sentence">Here <code>a</code> may be either a value available in the current scope or a type name, and <code>c</code> is a property name.</span></li>
<li><span class="sentence">A <a href="#callable-references">function reference</a>. </span><span class="sentence">Here <code>a</code> may be either a value available in the current scope or a type name, and <code>c</code> is a function name.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence"><code>a?.c</code> is a <em>safe navigation</em> operator, which has the following expansion:</span></p>
</div>
<ul>
<li><span class="sentence"><code>a?.c</code> is exactly the same as <code>if (a != null) a.c else null</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means the type of <code>a?.c</code> is the <a href="#nullable-types">nullable</a> variant of the type of <code>a.c</code>.</span></p>
</div>
</blockquote>
<h4 id="callable-references">Callable references</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(this is a stub)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Callable references are a special kind of expressions used to refer to callables (properties and functions) without actually calling/accessing them. </span><span class="sentence">It is not to be confused with <a href="#class-literals">class literals</a> that use similar syntax, but with the keyword <code>class</code> used instead of the identifier.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A callable reference <code>A::c</code> where <code>A</code> is a type name and <code>c</code> is a name of a callable available for type <code>A</code> is a <em>callable reference</em> for a type. </span><span class="sentence">A callable reference <code>e::c</code> where <code>e</code> is another expression and <code>c</code> is a name of a callable available for type <code>A</code> is a <em>callable reference</em> for expression <code>e</code>. </span><span class="sentence">The exact callable selected when using this syntax is based on <a href="#overload-resolution">overload resolution</a> much like when accessing the value of a property using the usual navigation syntax.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Depending on the meaning of the left-hand and right-hand sides of the expressions, the value of the expression is different:</span></p>
</div>
<ul>
<li><span class="sentence">If the left-hand side of the expression is a type, but is not a value (an example of a type which is also used as a value is an object type), while the right-hand side of the expression is resolved to refer to a property of the type on the left-hand side, then the expression is a type-property reference;</span></li>
<li><span class="sentence">If the left-hand side of the expression is a type, but is not a value (an example of a type which is also used as a value is an object type), while the right-hand side of the expression is resolved to refer to a function available for a receiver of the type on the left-hand side, then the expression is a type-function reference;</span></li>
<li><span class="sentence">If the left-hand side of the expression is a value, while the right-hand side of the expression is resolved to refer to a property of the value on the left-hand side, then the expression is a value-property reference;</span></li>
<li><span class="sentence">If the left-hand side of the expression is a value, while the right-hand side of the expression is resolved to refer to a function for the receiver being th value on the left-hand side, then the expression is a value-function reference.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The types of these expressions are implementation-defined, but the following constraints must hold:</span></p>
</div>
<ul>
<li><span class="sentence">The type of any kind of property reference is a subtype of <code>kotlin.reflect.KProperty&lt;T&gt;</code>, where the type parameter <code>T</code> is fixed to the type of the property;</span></li>
<li><span class="sentence">The type of any kind of callable reference is a subtype of <a href="#function-types">function type</a> that allows the corresponding callable to be accessed/called accordingly:</span>
<ul>
<li><span class="sentence">For a type-callable reference, it is an extension function type <code>O.(Arg0 ... ArgN) -&gt; R</code>, where <code>O</code> is a receiver type same as the left-hand type of the expression, <code>Arg0, ... , ArgN</code> are either empty (for a property reference) or are the types of function formal parameters (for a function reference) and <code>R</code> is the result type of the callable;</span></li>
<li><span class="sentence">For a value-callable reference, it is a normal function type <code>(Args) -&gt; R</code>, where <code>Arg0, ... , ArgN</code> are either empty (for a property reference) or are the types of function formal parameters (for a function reference) and <code>R</code> is the result type of the callable. </span><span class="sentence">The receiver is bound to the left-hand side expression of the reference expression.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Being of an appropriate function type also means that the values defined by these references are valid callables themselves, with an appropriate <code>operator invoke</code> overload, that allows using call syntax to evaluate the value of the callable with the appropriate arguments.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may say that any function reference is essentially the same as a lambda literal with the corresponding number of arguments, calling the callable being referenced.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(this is pretty complex, actually. </span><span class="sentence">Do we need all the K(Mutable)PropertyN business defined in the specification???) TODO(we need to update overload resolution section with these guys)</span></p>
</div>
</div>
<h4 id="class-literals">Class literals</h4>
<div class="paragraph">
<p><span class="sentence">A class literal is very similar in syntax to a callable reference, with the difference being that it uses the keyword <code>class</code> instead of the referenced identifier. </span><span class="sentence">Similar to callable references, there are two forms of class literals: with a type used as the left-hand side argument of the expression and with another expression used as such. </span><span class="sentence">This is also one of the few cases where a parameterized type may (<strong>and must</strong>) be used without its type parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All class literals have type <code>kotlin.KClass&lt;T&gt;</code> and produce a platform-defined object associated with type <code>T</code>, which, in turn, is either the type given as the left-hand side of the expression or the <a href="#runtime-type-information">runtime type</a> of the value given as the left-hand side of the expression. </span><span class="sentence">In both cases, <code>T</code> must be a <a href="#runtime-type-information">runtime-available type</a> in the current scope. </span><span class="sentence">As the runtime type of the expression is not known at compile time, the compile-time type of the expression is <code>kotlin.KClass&lt;U&gt;</code> where <span class="math inline">\(T &lt;: U\)</span> and <code>U</code> is the compile-time of the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The produced object can be used to allow access to platform-specific capabilities of the runtime type information available on particular platform, either directly or through reflection facilities.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(this is a stub)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Identifiers, paths, that kinda stuff)</span></p>
</div>
</div>
<h3 id="function-literals">Function literals</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin supports using functions as values. </span><span class="sentence">This includes, among other things, being able to use named functions (via <a href="#callable-references">function references</a>) as parts of expressions. </span><span class="sentence">Sometimes it does not make much sense to provide a separate function declaration, but rather define a function in-place. </span><span class="sentence">This is implemented using <em>function literals</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two types of function literals in Kotlin: <em>lambda literals</em> and <em>anonymous function declarations</em>. </span><span class="sentence">Both of these provide a way of defining a function in-place, but have subtle differences.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as some may consider function literals to be closely related to function declarations, <a href="#function-declaration">here</a> is the corresponding section of the specification.</span></p>
</div>
</blockquote>
<h4 id="anonymous-function-declarations">Anonymous function declarations</h4>
<div id="grammar-rule-anonymousFunction-pasted-65" class="grammar-rule">
<dl>
<dt><strong><em>anonymousFunction</em>:</strong></dt>
<dd><span class="sentence"><code>'fun'</code><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'.'</code>]<br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-functionValueParameters">functionValueParameters</a></em><br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-typeConstraints">typeConstraints</a></em>]<br />
[{<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-functionBody">functionBody</a></em>]</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Anonymous function declarations</em>, despite their name, are not declarations per se, but rather expressions which resemble function declarations. </span><span class="sentence">They have a syntax very similar to function declarations, with the following key differences:</span></p>
</div>
<ul>
<li><span class="sentence">Anonymous functions do not have a name;</span></li>
<li><span class="sentence">Anonymous functions may not have type parameters;</span></li>
<li><span class="sentence">Anonymous functions may not have default parameters;</span></li>
<li><span class="sentence">Anonymous functions may have variable argument parameters, but they are automatically decayed to non-variable argument parameters of the corresponding array type <span><span class="TODO">(TODO(how does this really work?))</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Anonymous function declaration may declare an anonymous extension function.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as anonymous functions may not have type parameters, you cannot declare an anonymous extension function on a parameterized receiver type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The type of an anonymous function declaration is the function type constructed similarly to a <a href="#function-declaration">named function declaration</a>.</span></p>
</div>
<h4 id="lambda-literals">Lambda literals</h4>
<div id="grammar-rule-lambdaLiteral-pasted-66" class="grammar-rule">
<dl>
<dt><strong><em>lambdaLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)<br />
| (<code>'{'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} [<em><a href="#grammar-rule-lambdaParameters">lambdaParameters</a></em>] {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'-&gt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-statements">statements</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'}'</code>)</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameters-pasted-67" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameters</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em> {{<em><a href="#grammar-rule-NL">NL</a></em>} <code>','</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-lambdaParameter">lambdaParameter</a></em>}</span>
</dd>
</dl>
</div>
<div id="grammar-rule-lambdaParameter-pasted-68" class="grammar-rule">
<dl>
<dt><strong><em>lambdaParameter</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-variableDeclaration">variableDeclaration</a></em><br />
| (<em><a href="#grammar-rule-multiVariableDeclaration">multiVariableDeclaration</a></em> [{<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em>])</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Lambda literals are similar to anonymous function declarations in that they define a function with no name. </span><span class="sentence">Lambda also use very different syntax, similar to control structure bodies of other expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every lambda literal consists of an optional lambda parameter list, specified before the arrow (<code>-&gt;</code>) operator and a body, which is everything after the arrow operator. </span><span class="sentence">Lambda body introduces a new statement scope.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Lambda literals has the same restrictions as anonymous function declarations, but also cannot have <code>vararg</code> parameters. </span><span class="sentence">They can, however, introduce destructuring parameters similar to destructuring property declarations.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(destructuring lambda parameters)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If a lambda expression has no parameter list, it can actually be defining an anonymous function with either zero or one parameter, the exact case dependent on the context of the usage of this expression. </span><span class="sentence">The selection of number of parameters in this case is performed during <a href="#type-inference">type inference</a>. </span><span class="sentence">Any lambda may also define either a normal function or an expansion function, the exact case also dependent on the context of the usage of lambda expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If the lambda expression has no parameter list, but has one parameter, this parameter can be accessed inside the lambda body using a special property called <code>it</code>. </span><span class="sentence">If the lambda expression defines an expansion function, the expansion receiver may be accessed using standard <code>this</code> syntax inside the lambda body.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: having no parameter list (and no arrow operator) in a lambda is different from having zero parameters (nothing preceding the arrow operator).</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Lambda literals are different from other forms of function definition in that the <code>return</code> expressions inside lambda body, unless qualified, refers to the outside non-lambda function the expression is used in rather than the lambda expression itself. </span><span class="sentence">Such returns are only allowed if the function defined by the lambda is guaranteed to be [inlined][Inlining] and are not allowed at all otherwise.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If the lambda expression is labeled, it can also be returned from using the [labeled return expression][Labeled return expression]. </span><span class="sentence">In addition to this, if the lambda expression is used as a trailing lambda parameter to a function call, the name of the function used in the call may be used instead of the label. </span><span class="sentence">If a particular labeled <code>return</code> expression is used inside multiple lambda bodies invoked during the call of the same function, this is an ambiguity and should be reported as a compile-time error.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Typing)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Any properties used in any way inside the lambda body are <strong>captured</strong> by the lambda expression and, depending on whether it is inlined or not, affect how this properties are processed by other mechanisms, e.g. <a href="#smart-casts">smart casts</a>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Rules of capturing)</span></p>
</div>
</div>
<h3 id="object-literals">Object literals</h3>
<div id="grammar-rule-objectLiteral-pasted-69" class="grammar-rule">
<dl>
<dt><strong><em>objectLiteral</em>:</strong></dt>
<dd><span class="sentence">(<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>':'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-delegationSpecifiers">delegationSpecifiers</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)<br />
| (<code>'object'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-classBody">classBody</a></em>)</span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Object literals are used to define anonymous objects in Kotlin. </span><span class="sentence">Anonymous objects are similar to regular objects, but they (obviously) have no name and thus can be used only as expressions. </span><span class="sentence">Anonymous objects, just like regular object declarations, can have at most one base class and zero or more base interfaces declared in its supertype specifiers.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The main difference between the regular object declaration and an anonymous object is its type. </span><span class="sentence">The type of an anonymous object is a special kind of type which is usable (and visible) only in the scope where it is declared. </span><span class="sentence">It is similar to a type of a regular object declaration, but, as it cannot be used outside the scope, with some interesting effects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a value of an anonymous object type escapes current scope:</span></p>
</div>
<ul>
<li><span class="sentence">If the type has only one declared supertype, it is implicitly downcasted to this declared supertype;</span></li>
<li><span class="sentence">If the type has several declared supertypes, there must be an implicit or explicit cast to any suitable type visible outside the scope, otherwise it is a compile-time error.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an implicit cast may arise, for example, from the results of the type inference.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in this context “escaping” current scope is performed immediately if the corresponding value is declared as a global- or classifier-scope property, as those are a part of package interface.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: This is more complex. </span><span class="sentence">From D.Petrov’s comment:</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This is a bit more complex for anonymous object return types of private functions and properties:</span></p>
</div>
<pre><code>class M {
private fun foo() = object {
fun bar() { println(&quot;foo.bar&quot;) }
}

fun test1() = foo().bar()
fun test2() = foo()
}

fun main() {
M().test1() // OK, prints &quot;foo.bar&quot;
M().test2().bar() // Error: Unresolved reference: bar
}</code></pre>
</blockquote>
<h3 id="this-expressions">This-expressions</h3>
<div id="grammar-rule-thisExpression-pasted-70" class="grammar-rule">
<dl>
<dt><strong><em>thisExpression</em>:</strong></dt>
<dd><span class="sentence"><code>'this'</code><br />
| <em><a href="#grammar-rule-THIS_AT">THIS_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">This-expressions are special kind of expressions used to access <a href="#receivers">receivers</a> available in current scope. </span><span class="sentence">The basic form of this expression, denoted by <code>this</code> keyword, is used to access the current implicit receiver according to the receiver overloading rules. </span><span class="sentence">In order to access other receivers, labeled <code>this</code> expressions are used. </span><span class="sentence">These may be any of the following:</span></p>
</div>
<ul>
<li><span class="sentence"><code>this@type</code>, where <code>type</code> is a name of any classifier currently being declared (that is, this-expression is located in the inner scope of the classifier declaration), refers to the implicit object of the type being declared;</span></li>
<li><span class="sentence"><code>this@function</code>, where <code>function</code> is a name of any extension function currently being declared (that is, this-expression is located in the function body), refers to the implicit receiver object of the extension function;</span></li>
<li><span class="sentence"><code>this@lambda</code>, where <code>lambda</code> is a [label][Labels] provided for a lambda literal currently being declared (that is, this-expression is located in the lambda expression body), refers to the implicit receiver object of the lambda expression.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any other form of this-expression is illegal and must be a compile-time error.</span></p>
</div>
<h3 id="super-forms">Super-forms</h3>
<div id="grammar-rule-superExpression-pasted-71" class="grammar-rule">
<dl>
<dt><strong><em>superExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'super'</code> [<code>'&lt;'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-type">type</a></em> {<em><a href="#grammar-rule-NL">NL</a></em>} <code>'&gt;'</code>] [<code>'@'</code> <em><a href="#grammar-rule-simpleIdentifier">simpleIdentifier</a></em>])<br />
| <em><a href="#grammar-rule-SUPER_AT">SUPER_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence">Super-forms are special kind of expression which can only be used as receivers in a function or property access expression. </span><span class="sentence">Any use of super-form expression in any other context is a compile-time error.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Super-forms are used in classifier declarations to access method implementations from the supertypes without invoking overriding behaviour.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(The rest…)</span></p>
</div>
</div>
<h3 id="jump-expressions">Jump expressions</h3>
<div id="grammar-rule-jumpExpression-pasted-72" class="grammar-rule">
<dl>
<dt><strong><em>jumpExpression</em>:</strong></dt>
<dd><span class="sentence">(<code>'throw'</code> {<em><a href="#grammar-rule-NL">NL</a></em>} <em><a href="#grammar-rule-expression">expression</a></em>)<br />
| ((<code>'return'</code> | <em><a href="#grammar-rule-RETURN_AT">RETURN_AT</a></em>) [<em><a href="#grammar-rule-expression">expression</a></em>])<br />
| <code>'continue'</code><br />
| <em><a href="#grammar-rule-CONTINUE_AT">CONTINUE_AT</a></em><br />
| <code>'break'</code><br />
| <em><a href="#grammar-rule-BREAK_AT">BREAK_AT</a></em></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>Jump expressions</em> are expressions which redirect the evaluation of the program to a different program point. </span><span class="sentence">All these expressions have several things in common:</span></p>
</div>
<ul>
<li><span class="sentence">They all have type <a href="#kotlin.nothing"><code>kotlin.Nothing</code></a>, meaning that they never produce any runtime value;</span></li>
<li><span class="sentence">Any code which follows such expressions is never evaluated.</span></li>
</ul>
<h4 id="throw-expressions">Throw expressions</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<a href="#exceptions">Exceptions</a> go first)</span></p>
</div>
</div>
<h4 id="return-expressions">Return expressions</h4>
<div class="paragraph">
<p><span class="sentence">A <em>return expression</em>, when used inside a function body, immediately stops evaluating the current function and returns to its caller, effectively making the function call expression evaluate to the value specified in this return expression (if any). </span><span class="sentence">A return expression with no value implicitly returns the <code>kotlin.Unit</code> object.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of return expression: a simple return expression, specified using the <code>return</code> keyword, which returns from the innermost <a href="#function-declaration">function declaration</a> (or <a href="#anonymous-function-declarations">Anonymous function declaration</a>) and a labeled return expression of the form <code>return@Context</code> where <code>Context</code> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">The name of one of the enclosing function declarations, which refers to this function. </span><span class="sentence">If several declarations match one name, it is a compile-time error;</span></li>
<li><span class="sentence">If <code>return@Context</code> is inside a lambda expression body, the name of the function <strong>using</strong> this lambda expression as its argument may be used as <code>Context</code> to refer to the lambda literal itself.</span></li>
<li><div class="TODO">
<span class="sentence">TODO(return from a labeled lambda)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules mean that a simple return expression inside a lambda expression returns <strong>from the innermost function</strong>, in which this lambda expression is defined.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If returning from the referred function is allowed in the current context, the return is performed as usual. </span><span class="sentence">If returning from the referred function is not allowed, it is a compile-time error.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(What does it mean for returns to be disallowed?)</span></p>
</div>
</div>
<h4 id="continue-expression">Continue expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>continue expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the start of the next loop iteration (aka “continue-jumps”).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of continue expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple continue expression, specified using the <code>continue</code> keyword, which continue-jumps to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">A labeled continue expression, denoted <code>continue@Loop</code>, where <code>Loop</code> is a label of a labeled loop statement <code>L</code>, which continue-jumps to the loop <code>L</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Future use: as of Kotlin 1.2.60, a simple continue expression is not allowed inside <code>when</code> expressions.</span></p>
</div>
</blockquote>
<h4 id="break-expression">Break expression</h4>
<div class="paragraph">
<p><span class="sentence">A <em>break expression</em> is a jump expression allowed only within loop bodies. </span><span class="sentence">When evaluated, this expression passes the control to the next program point immediately after the loop (aka “break-jumps”).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">There are two forms of break expressions:</span></p>
</div>
<ul>
<li><span class="sentence">A simple break expression, specified using the <code>break</code> keyword, which break-jumps to the innermost loop statement in the current scope;</span></li>
<li><span class="sentence">A labeled break expression, denoted <code>break@Loop</code>, where <code>Loop</code> is a label of a labeled loop statement <code>L</code>, which break-jumps to the loop <code>L</code>.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Future use: as of Kotlin 1.2.60, a simple break expression is not allowed inside when expressions.</span></p>
</div>
</blockquote>
<h3 id="string-interpolation-expressions">String interpolation expressions</h3>
<div id="grammar-rule-stringLiteral-pasted-73" class="grammar-rule">
<dl>
<dt><strong><em>stringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-lineStringLiteral">lineStringLiteral</a></em><br />
| <em><a href="#grammar-rule-multiLineStringLiteral">multiLineStringLiteral</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringLiteral-pasted-74" class="grammar-rule">
<dl>
<dt><strong><em>lineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-QUOTE_OPEN">QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-lineStringContent">lineStringContent</a></em> | <em><a href="#grammar-rule-lineStringExpression">lineStringExpression</a></em>} <em><a href="#grammar-rule-QUOTE_CLOSE">QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringLiteral-pasted-75" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringLiteral</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-TRIPLE_QUOTE_OPEN">TRIPLE_QUOTE_OPEN</a></em> {<em><a href="#grammar-rule-multiLineStringContent">multiLineStringContent</a></em> | <em><a href="#grammar-rule-multiLineStringExpression">multiLineStringExpression</a></em> | <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em>} <em><a href="#grammar-rule-TRIPLE_QUOTE_CLOSE">TRIPLE_QUOTE_CLOSE</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringContent-pasted-76" class="grammar-rule">
<dl>
<dt><strong><em>lineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrText">LineStrText</a></em><br />
| <em><a href="#grammar-rule-LineStrEscapedChar">LineStrEscapedChar</a></em><br />
| <em><a href="#grammar-rule-LineStrRef">LineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-lineStringExpression-pasted-77" class="grammar-rule">
<dl>
<dt><strong><em>lineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-LineStrExprStart">LineStrExprStart</a></em> <em><a href="#grammar-rule-expression">expression</a></em> <code>'}'</code></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringContent-pasted-78" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringContent</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrText">MultiLineStrText</a></em><br />
| <em><a href="#grammar-rule-MultiLineStringQuote">MultiLineStringQuote</a></em><br />
| <em><a href="#grammar-rule-MultiLineStrRef">MultiLineStrRef</a></em></span>
</dd>
</dl>
</div>
<div id="grammar-rule-multiLineStringExpression-pasted-79" class="grammar-rule">
<dl>
<dt><strong><em>multiLineStringExpression</em>:</strong></dt>
<dd><span class="sentence"><em><a href="#grammar-rule-MultiLineStrExprStart">MultiLineStrExprStart</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<em><a href="#grammar-rule-expression">expression</a></em><br />
{<em><a href="#grammar-rule-NL">NL</a></em>}<br />
<code>'}'</code></span>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="sentence"><em>String interpolation expressions</em> replace the traditional string literals and supersede them. </span><span class="sentence">A string interpolation expression consists of one or more fragments of two different kinds: string content fragments (raw pieces of string content found inside the quoted literal) and <em>interpolated expressions</em>, delimited by the special syntax using the <code>$</code> symbol. </span><span class="sentence">This syntax allows to specify such fragments by directly following the <code>$</code> symbol with either a single identifier (if the expression is a single identifier) or a control structure body. </span><span class="sentence">In either case, the interpolated value is evaluated and converted into a <code>kotlin.String</code> by a process defined below. </span><span class="sentence">The resulting value of a string interpolation expression is the joining of all fragments in the expression.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An interpolated value <span class="math inline">\(v\)</span> is converted to <code>kotlin.String</code> according to the following convention:</span></p>
</div>
<ul>
<li><span class="sentence">If it is equal to the <a href="#null-literal">null reference</a>, the result is <code>&quot;null&quot;</code>;</span></li>
<li><span class="sentence">Otherwise, the result is <span class="math inline">\(v\)</span><code>.toString()</code> where <code>toString</code> is the <code>kotlin.Any</code> member function (no overloading resolution is performed to choose the function in this context).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">There are two kinds of string interpolation expressions: line interpolation expressions and multiline (or raw) interpolation expressions. </span><span class="sentence">The difference is that some symbols (namely, newline symbols) are not allowed to be used inside line interpolation expressions and they need to be escaped (see <a href="#grammar">grammar</a> for details). </span><span class="sentence">On the other hand, multiline interpolation expressions allow such symbols inside them, but do not allow single character escaping of any kind.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: among other things, this means that the escaping of the <code>$</code> symbol is impossible in multiline strings. </span><span class="sentence">If you need an escaped <code>$</code> symbol, use an interpolation fragment instead: <code>&quot;${'$'}&quot;</code></span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">String interpolation expression always has type <code>kotlin.String</code>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(define this using actual <code>kotlin.StringBuilder</code> business?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(list all the allowed escapes here?)</span></p>
</div>
</div>
<h2 id="todos">TODOs()</h2>
<ul>
<li><span class="sentence">Class literals</span></li>
<li><span class="sentence">Smart casts vs compile-time types</span></li>
<li><span class="sentence">What does <code>decaying</code> for vararg actually mean?</span></li>
<li><span class="sentence">Where to define spread operator?</span></li>
<li><span class="sentence">Object literal types look just like restricted union types. </span><span class="sentence">Are there any traps hidden here?</span></li>
<li><span class="sentence">The last paragraph in <a href="#object-literals">object literals</a> is also pretty shady</span></li>
</ul>
<h2 id="order-of-evaluation">Order of evaluation</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="semantics">Semantics</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="control--and-data-flow-analysis">Control- and data-flow analysis</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Unreachable code w.r.t. Nothing)</span></p>
</div>
</div>
<h2 id="kotlin-type-constraints">Kotlin type constraints</h2>
<div class="paragraph">
<p><span class="sentence">Some complex tasks that need to be solved when compiling Kotlin code are formulated best using <em>constraint systems</em> on Kotlin types. </span><span class="sentence">These are solved using constraint solvers.</span></p>
</div>
<h3 id="type-constraint-definition">Type constraint definition</h3>
<div class="paragraph">
<p><span class="sentence">A <em>type constraint</em> in general is an inequation of the following form: <span class="math inline">\(T &lt;: U\)</span> where <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> are Kotlin types (see <a href="#type-system">type system</a>). </span><span class="sentence">It is important, however, that Kotlin has parameterized types and type parameters of <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> (or type parameters of their parameters, or <span class="math inline">\(T\)</span> and <span class="math inline">\(U\)</span> themselves) may be <em>type variables</em>, that are unknown types that may be substituted by any other type in Kotlin.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Please note that, in general, type variables of the constraint system are not the same as type parameters of a type or a callable. </span><span class="sentence">Some type parameters may be <em>bound</em> in the constraint system, meaning that, although they are not known yet in Kotlin code, they are not type variables and are not to be substituted.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When such an ambiguity arises, we will use the notation <span class="math inline">\(T_i\)</span> for a type variable and <span class="math inline">\(\tilde{T_i}\)</span> for a bound type parameter. </span><span class="sentence">The main difference between bound parameters and concrete types is that different concrete types may not be equal, but a bound parameter may be equal to another bound parameter or a concrete type.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Several examples of valid type constraints:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;\tilde{X}\right&gt; &lt;: \mathtt{List}\left&lt;\mathtt{List}\left&lt;\mathtt{Int}\right&gt;\right&gt;\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\widetilde{X} &lt;: Y\)</span></span></li>
</ul>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Every constraint system has implicit constraints <span class="math inline">\(\mathtt{Any} &lt;: T_j\)</span> and <span class="math inline">\(T_j &lt;: \mathtt{Nothing?}\)</span> for every type <span class="math inline">\(T_j\)</span> mentioned in constraint, including type variables.</span></p>
</div>
<h3 id="type-constraint-solving">Type constraint solving</h3>
<div class="paragraph">
<p><span class="sentence">There are two tasks that a type constraint solver may perform: checking constraint system for soundness and solving the system, e.g. inferring viable values for all the type variables that have themselves no type variables in them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Checking a constraint system for soundness can be viewed as a simpler case of solving a constraint, as if there is a solution, then the system is sound. </span><span class="sentence">It is, however, a much simpler task with only two possible outcomes. </span><span class="sentence">Solving a constraint system, on the other hand, may have several different results as there may be several valid solutions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Constraint examples that are sound yet no relevant solutions exist:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(X &lt;: Y\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\mathtt{List}\left&lt;X\right&gt; &lt;: \mathtt{Collection}\left&lt;X\right&gt;\)</span></span></li>
</ul>
</blockquote>
<h4 id="checking-constraint-system-soundness">Checking constraint system soundness</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="finding-optimal-solution">Finding optimal solution</h4>
<div class="paragraph">
<p><span class="sentence">As any constraint system may have several valid solutions, finding one that is “optimal” in some sense is not possible in general, because the notion of the best solution for a task depends on a particular use-case. </span><span class="sentence">To solve this problem, the constraint system allows two additional types of constraints:</span></p>
</div>
<ul>
<li><span class="sentence">A pull-up constraint for type variable <span class="math inline">\(T\)</span>, denoted <span class="math inline">\(\uparrow T\)</span>, signifying that when finding a substitution for this variable, the optimal solution is the least one according to subtyping relation;</span></li>
<li><span class="sentence">A push-down constraint for type variable <span class="math inline">\(T\)</span>, denoted <span class="math inline">\(\downarrow T\)</span>, signifying that when finding a substitution for this variable, the optimal solution is the biggest one according to subtyping relation.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If a variable have no constraints of these two kinds associated with it, it is assumed to have a pull-up constraint, that is, in an ambigious situation, the biggest possible type is chosen.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h4 id="the-relations-on-types-as-constraints">The relations on types as constraints</h4>
<div class="paragraph">
<p><span class="sentence">In the other chapters (see <a href="#expressions">expressions</a> and <a href="#statements">statements</a> for example) the relations between types may be expressed using the type operations found in the <a href="#type-system">type system section</a> of this document. </span><span class="sentence">Not all of these relations are easily converted into their constraint form.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The greatest lower bound of two types is converted directly, as the greatest lower bound is always an intersection type. </span><span class="sentence">The least upper bound, however, is a little bit tricky. </span><span class="sentence">If type <span class="math inline">\(T\)</span> is defined to be the least upper bound of <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> with all these types being either known, unknown or containing type variables, the following constraints are produced:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(A &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\downarrow T\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\uparrow A\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\uparrow B\)</span></span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:<br />
Let’s assume we have the following code:</span></p>
</div>
<div class="sourceCode" id="cb32"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">val</span> <span class="va">e</span> = <span class="cf">if</span>(c) a <span class="cf">else</span> b</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>a</code>, <code>b</code>, <code>c</code> are some expressions with types completely unknown (having no other type constraints besided the implicit ones). </span><span class="sentence">Let’s assume the type variables generated for them to be <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> respectively and the type variable for <code>e</code> being <span class="math inline">\(E\)</span>. </span><span class="sentence">This, according to <a href="#conditional-expression">the conditional expression chapter</a>, produces the following relations:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(C &lt;: \mathtt{kotlin.Boolean}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(E = LUB(A, B)\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These, in turn, produce the following constraints (here we omit the implicit relations of all type variables with <code>kotlin.Any?</code> and <code>kotlin.Nothing</code>):</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(C &lt;: \mathtt{kotlin.Boolean}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A &lt;: E\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B &lt;: E\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\downarrow E\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\uparrow A\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(\uparrow B\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Which, according to the semantics of additional constraints (and the default pull-up constraint for <span class="math inline">\(C\)</span>), produce the following solution:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(C \rightarrow \mathtt{kotlin.Boolean}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(A \rightarrow \mathtt{kotlin.Any?}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(B \rightarrow \mathtt{kotlin.Any?}\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(E \rightarrow \mathtt{kotlin.Any?}\)</span></span></li>
</ul>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(prove that these constraints are equivalent to LUB from type system?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(are they actually?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(does that matter?)</span></p>
</div>
</div>
<h2 id="type-inference">Type inference</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin has a concept of <em>type inference</em> for compile-time type information, meaning some type information in the code may be omitted, to be inferred by the compiler. </span><span class="sentence">There are two kinds of type inference supported by Kotlin.</span></p>
</div>
<ul>
<li><span class="sentence">Local type inference, for inferring types of expressions locally, in statement/expression scope;</span></li>
<li><span class="sentence">Function signature type inference, for inferring types of function return values and/or parameters.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: type inference is a <a href="#kotlin-type-constraints">type constraint</a> problem, and is usually solved by a type constraint solver.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(write about when type inference works and when it does not)</span></p>
</div>
</div>
<h3 id="smart-casts">Smart casts</h3>
<div class="paragraph">
<p><span class="sentence">Kotlin introduces a limited form of flow-dependent typing called <em>smart casting</em>. </span><span class="sentence">Flow-dependent typing means some expressions in the program may introduce changes to the compile-time types of variables. </span><span class="sentence">This allows one to avoid unneeded explicit casting of values in cases when their runtime types are guaranteed to conform to the expected compile-time types.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Smart casts are dependent on two main things: <em>smart cast sources</em> and <em>smart cast sink stability</em>.</span></p>
</div>
<h4 id="smart-cast-sources">Smart cast sources</h4>
<div class="paragraph">
<p><span class="sentence">There are two kinds of smart cast sources: <em>non-nullability conditions</em> and <em>type conditions</em>. </span><span class="sentence">Non-nullability conditions specify that some value is not nullable, i.e., its value is guaranteed to not be <code>null</code>. </span><span class="sentence">Type conditions specify that some value’s runtime type conforms to a constraint <span class="math inline">\(RT &lt;: T\)</span>, where <span class="math inline">\(T\)</span> is the assumed type and <span class="math inline">\(RT\)</span> is the runtime type. </span><span class="sentence">A smart cast source may be <em>negated</em>, meaning it reverses its interpretation.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: non-nullability conditions may be viewed as a special case of type conditions with assumed type <code>kotlin.Any</code>.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: we may use the terms “negated non-nullability condition” and “nullability condition” interchangeably.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">These sources influence the compile-time type of a value in some expression (called <em>smart cast sink</em>) only if the sink is <a href="#smart-cast-sink-stability"><em>stable</em></a> and if the source <a href="#source-sink-domination">dominates</a> the sink. </span><span class="sentence">The actual compile-time type of a smart casted value for most purposes (including, but not limited to, function overloading and type inference of other values) is as follows.</span></p>
</div>
<ul>
<li><span class="sentence">If the smart cast source is a non-nullability condition, the type is the [intersection][Type intersection] of the type it had before (including the results of smart casting performed for other conditions) and type <code>kotlin.Any</code>;</span></li>
<li><span class="sentence">If the smart cast source is a negated non-nullability condition, the type is the [intersection][Type intersection] of the type it had before (including the results of smart casting performed for other conditions) and type <code>kotlin.Nothing?</code>;</span></li>
<li><span class="sentence">If the smart cast source is a type condition, the type is the [intersection][Type intersection] of the type it had before (including the results of smart casting performed for other conditions) and the assumed type of the condition.</span></li>
<li><span class="sentence">If the smart cast source is a negated type condition, the type does not change.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: the most important exception to when smart casts are used in type inference is direct property declaration.</span></p>
</div>
<pre><code>fun noSmartCastInInference() {
    var a: Any? = null

    if (a == null) return

    var c = a // Direct property declaration

    c // Declared type of `c` is Any?
      // However, here it&#39;s smart casted to Any
}

fun &lt;T&gt; id(a: T): T = a

fun smartCastInInference() {
    var a: Any? = null

    if (a == null) return

    var c = id(a)

    c // Declared type of `c` is Any
}</code></pre>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Smart cast sources are introduced by:</span></p>
</div>
<ul>
<li><span class="sentence">Conditional expressions (<code>if</code> and <code>when</code>);</span></li>
<li><span class="sentence">Elvis operator (operator <code>?:</code>);</span></li>
<li><span class="sentence">Safe navigation operator (operator <code>?.</code>);</span></li>
<li><span class="sentence">Logical conjunction expressions (operator <code>&amp;&amp;</code>);</span></li>
<li><span class="sentence">Logical disjunction expressions (operator <code>||</code>);</span></li>
<li><span class="sentence">Not-null assertion expressions (operator <code>!!</code>);</span></li>
<li><span class="sentence">Direct casting expression (operator <code>as</code>);</span></li>
<li><span class="sentence">Direct assignments;</span></li>
<li><span class="sentence">Platform-specific cases: different platforms may add other kinds of expressions which introduce additional smart cast sources.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: property declarations are not listed here, as their types are derived from initializers.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Nullability and type conditions are derived in the following way.</span></p>
</div>
<ul>
<li><span class="sentence"><code>x is T</code> where <span class="math inline">\(x\)</span> is an applicable expression implies a type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><code>x !is T</code> where <span class="math inline">\(x\)</span> is an applicable expression implies a negated type condition for <span class="math inline">\(x\)</span> with assumed type <span class="math inline">\(T\)</span>;</span></li>
<li><span class="sentence"><code>x != null</code> or <code>null != x</code> where <span class="math inline">\(x\)</span> is an applicable expression implies a non-nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>x == null</code> or <code>null == x</code> where <span class="math inline">\(x\)</span> is an applicable expression implies a nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>!x</code> implies all the conditions implied by <span class="math inline">\(x\)</span>, but in negated form;</span></li>
<li><span class="sentence"><code>x &amp;&amp; y</code> implies the union of all non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><code>x || y</code> implies the union of all negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> and the intersection of all non-negated conditions implied by <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>;</span></li>
<li><span class="sentence"><code>x === y</code> or <code>y === x</code> where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is a known non-nullable value (that is, has a non-nullable compile-time type) implies the non-nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>x === y</code> or <code>y === x</code> where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is known to be null (that is, has <code>Nothing?</code> type) implies the nullability condition for <span class="math inline">\(x\)</span>;</span></li>
<li><span class="sentence"><code>x == y</code> or <code>y == x</code> where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is a known non-nullable value (that is, has a non-nullable compile-time type) implies the non-nullability condition for <span class="math inline">\(x\)</span>, but only if the corresponding <a href="#value-equality-expressions"><code>equals</code> implementation</a> is known to be equivalent to <a href="#reference-equality-expressions">reference equality check</a>.</span></li>
<li><span class="sentence"><code>x == y</code> or <code>y == x</code> where <span class="math inline">\(x\)</span> is an applicable expression and <span class="math inline">\(y\)</span> is known to be null (that is, has <code>Nothing?</code> type) implies the nullability condition for <span class="math inline">\(x\)</span>, but only if the corresponding <a href="#value-equality-expressions"><code>equals</code> implementation</a> is known to be equivalent to <a href="#reference-equality-expressions">reference equality check</a>.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(x != Nothing? </span><span class="sentence">/ x !== Nothing?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for example, generated <code>equals</code> implementation for <a href="#data-class-declaration">data classes</a> is considered to be equivalent to reference equality check.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A complete list of when <code>equals</code> is OK?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Additionally, any type condition with assumed <em>non-null</em> type also creates a non-nullability condition for its value. </span><span class="sentence">This property is used in <a href="#bound-smart-casts">bound smart casts</a>.</span></p>
</div>
<h4 id="smart-cast-sink-stability">Smart cast sink stability</h4>
<div class="paragraph">
<p><span class="sentence">A smart cast sink is <em>stable</em> for smart casting if its value cannot be changed from the smart cast source to itself; this guarantees the smart cast conditions still hold at the sink. </span><span class="sentence">This is one of the necessary conditions for smart cast to be applicable for a given source-sink pair.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Smart cast sink stability breaks in the presence of the following aspects.</span></p>
</div>
<ul>
<li><span class="sentence">concurrent writes;</span></li>
<li><span class="sentence">separate module compilation;</span></li>
<li><span class="sentence">custom getters;</span></li>
<li><span class="sentence">delegation.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: despite what it may seem at first sight, sink stability is <em>very</em> complicated for local variables.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The following smart cast sinks are considered stable.</span></p>
</div>
<ol type="1">
<li><span class="sentence">Immutable local or classifier-scope properties without delegation or custom getters;</span></li>
<li><span class="sentence">Immutable properties of stable properties without delegation or custom getters;</span></li>
<li><span class="sentence">Mutable local properties without delegation or custom getters, if the compiler can prove that they are <a href="#effectively-immutable-smart-cast-sinks">effectively immutable</a>, i.e., cannot be changed by external means from the smart cast source to the smart cast sink.</span></li>
</ol>
<h5 id="effectively-immutable-smart-cast-sinks">Effectively immutable smart cast sinks</h5>
<div class="paragraph">
<p><span class="sentence">We will call redefinition of <span class="math inline">\(P\)</span> <strong><em>direct</em></strong> redefinition, if it happens in the same declaration scope as the definition of <span class="math inline">\(P\)</span>. </span><span class="sentence">If <span class="math inline">\(P\)</span> is redefined in a nested declaration scope (w.r.t. </span><span class="sentence">its definition), this is a <strong><em>nested</em></strong> redefinition.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, a nested redefinition means the property has been captured in another scope and may be changed from that scope in a concurrent fashion.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">We define <strong><em>direct</em></strong> and <strong><em>nested</em></strong> smart cast sinks in a similar way.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb34"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">fun</span> <span class="fu">example</span>() {</a>
<a class="sourceLine" id="cb34-2" title="2">    <span class="co">// definition</span></a>
<a class="sourceLine" id="cb34-3" title="3">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="kw">null</span></a>
<a class="sourceLine" id="cb34-4" title="4"></a>
<a class="sourceLine" id="cb34-5" title="5">    <span class="cf">if</span> (x != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb34-6" title="6">        run {</a>
<a class="sourceLine" id="cb34-7" title="7">            <span class="co">// nested smart cast sink</span></a>
<a class="sourceLine" id="cb34-8" title="8">            x.inc()</a>
<a class="sourceLine" id="cb34-9" title="9"></a>
<a class="sourceLine" id="cb34-10" title="10">            <span class="co">// nested redefinition</span></a>
<a class="sourceLine" id="cb34-11" title="11">            x = ...</a>
<a class="sourceLine" id="cb34-12" title="12">        }</a>
<a class="sourceLine" id="cb34-13" title="13">        <span class="co">// direct smart cast sink</span></a>
<a class="sourceLine" id="cb34-14" title="14">        x.inc()</a>
<a class="sourceLine" id="cb34-15" title="15">    }</a>
<a class="sourceLine" id="cb34-16" title="16"></a>
<a class="sourceLine" id="cb34-17" title="17">    <span class="co">// direct redefinition</span></a>
<a class="sourceLine" id="cb34-18" title="18">    x = ...</a>
<a class="sourceLine" id="cb34-19" title="19">}</a></code></pre></div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A mutable local property <span class="math inline">\(P\)</span> defined at <span class="math inline">\(D\)</span> is considered effectively immutable for a given pair of smart cast source <span class="math inline">\(SO\)</span> and smart cast sink <span class="math inline">\(SI\)</span>, if the following properties hold.</span></p>
</div>
<ul>
<li><span class="sentence">There are no redefinitions of <span class="math inline">\(P\)</span> on any path between <span class="math inline">\(SO\)</span> and <span class="math inline">\(SI\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(SI\)</span> is a direct sink, there must be no nested redefinitions on any path between <span class="math inline">\(D\)</span> and <span class="math inline">\(SI\)</span></span></li>
<li><span class="sentence">If <span class="math inline">\(SI\)</span> is a nested sink, then</span>
<ul>
<li><span class="sentence">there must be no nested redefinitions of <span class="math inline">\(P\)</span></span></li>
<li><span class="sentence">all direct redefinitions of <span class="math inline">\(P\)</span> must precede <span class="math inline">\(SI\)</span></span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb35"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">fun</span> <span class="fu">directSinkOk</span>() {</a>
<a class="sourceLine" id="cb35-2" title="2">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="dv">42</span> <span class="co">// definition</span></a>
<a class="sourceLine" id="cb35-3" title="3">    <span class="cf">if</span> (x != <span class="kw">null</span>)   <span class="co">// smart cast source</span></a>
<a class="sourceLine" id="cb35-4" title="4">        x.inc()      <span class="co">// direct sink</span></a>
<a class="sourceLine" id="cb35-5" title="5">    run {</a>
<a class="sourceLine" id="cb35-6" title="6">        x = <span class="kw">null</span>     <span class="co">// nested redefinition</span></a>
<a class="sourceLine" id="cb35-7" title="7">    }</a>
<a class="sourceLine" id="cb35-8" title="8">}</a>
<a class="sourceLine" id="cb35-9" title="9"></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="kw">fun</span> <span class="fu">directSinkBad</span>() {</a>
<a class="sourceLine" id="cb35-11" title="11">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="dv">42</span> <span class="co">// definition</span></a>
<a class="sourceLine" id="cb35-12" title="12">    run {</a>
<a class="sourceLine" id="cb35-13" title="13">        x = <span class="kw">null</span>     <span class="co">// nested redefinition</span></a>
<a class="sourceLine" id="cb35-14" title="14">                     <span class="co">//   between a definition</span></a>
<a class="sourceLine" id="cb35-15" title="15">                     <span class="co">//   and a sink</span></a>
<a class="sourceLine" id="cb35-16" title="16">    }</a>
<a class="sourceLine" id="cb35-17" title="17">    <span class="cf">if</span> (x != <span class="kw">null</span>)   <span class="co">// smart cast source</span></a>
<a class="sourceLine" id="cb35-18" title="18">        x.inc()      <span class="co">// direct sink</span></a>
<a class="sourceLine" id="cb35-19" title="19">}</a>
<a class="sourceLine" id="cb35-20" title="20"></a>
<a class="sourceLine" id="cb35-21" title="21"><span class="kw">fun</span> <span class="fu">nestedSinkOk</span>() {</a>
<a class="sourceLine" id="cb35-22" title="22">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="dv">42</span>     <span class="co">// definition</span></a>
<a class="sourceLine" id="cb35-23" title="23">    x = getNullableInt() <span class="co">// direct redefinition</span></a>
<a class="sourceLine" id="cb35-24" title="24">    run {</a>
<a class="sourceLine" id="cb35-25" title="25">        <span class="cf">if</span> (x != <span class="kw">null</span>)   <span class="co">// smart cast source</span></a>
<a class="sourceLine" id="cb35-26" title="26">            x.inc()      <span class="co">// nested sink</span></a>
<a class="sourceLine" id="cb35-27" title="27">    }</a>
<a class="sourceLine" id="cb35-28" title="28">}</a>
<a class="sourceLine" id="cb35-29" title="29"></a>
<a class="sourceLine" id="cb35-30" title="30"><span class="kw">fun</span> <span class="fu">nestedSinkBad01</span>() {</a>
<a class="sourceLine" id="cb35-31" title="31">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="dv">42</span>     <span class="co">// definition</span></a>
<a class="sourceLine" id="cb35-32" title="32">    run {</a>
<a class="sourceLine" id="cb35-33" title="33">        <span class="cf">if</span> (x != <span class="kw">null</span>)   <span class="co">// smart cast source</span></a>
<a class="sourceLine" id="cb35-34" title="34">            x.inc()      <span class="co">// nested sink</span></a>
<a class="sourceLine" id="cb35-35" title="35">    }</a>
<a class="sourceLine" id="cb35-36" title="36">    x = getNullableInt() <span class="co">// direct redefinition</span></a>
<a class="sourceLine" id="cb35-37" title="37">                         <span class="co">//   after the nested sunk</span></a>
<a class="sourceLine" id="cb35-38" title="38">}</a>
<a class="sourceLine" id="cb35-39" title="39"></a>
<a class="sourceLine" id="cb35-40" title="40"><span class="kw">fun</span> <span class="fu">nestedSinkBad02</span>() {</a>
<a class="sourceLine" id="cb35-41" title="41">    <span class="kw">var</span> <span class="va">x</span>: <span class="kw">Int</span>? = <span class="dv">42</span>     <span class="co">// definition</span></a>
<a class="sourceLine" id="cb35-42" title="42">    run {</a>
<a class="sourceLine" id="cb35-43" title="43">        x = <span class="kw">null</span>         <span class="co">// nested redefinition</span></a>
<a class="sourceLine" id="cb35-44" title="44">                         <span class="co">//   of a nested sink</span></a>
<a class="sourceLine" id="cb35-45" title="45">    }</a>
<a class="sourceLine" id="cb35-46" title="46">    run {</a>
<a class="sourceLine" id="cb35-47" title="47">        <span class="cf">if</span> (x != <span class="kw">null</span>)   <span class="co">// smart cast source</span></a>
<a class="sourceLine" id="cb35-48" title="48">            x.inc()      <span class="co">// nested sink</span></a>
<a class="sourceLine" id="cb35-49" title="49">    }</a>
<a class="sourceLine" id="cb35-50" title="50">}</a></code></pre></div>
</blockquote>
<h4 id="source-sink-domination">Source-sink domination</h4>
<div class="paragraph">
<p><span class="sentence">A smart cast source <span class="math inline">\(SO\)</span> dominates a smart cast sink <span class="math inline">\(SI\)</span>, if <span class="math inline">\(SO\)</span> is a control-flow dominator of <span class="math inline">\(SI\)</span>. </span><span class="sentence">This is one of the necessary conditions for smart cast to be applicable for a given source-sink pair.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In the most basic case, smart cast conditions propagate as-is from sources to sinks. </span><span class="sentence">However, as a number of expressions have additional semantics, which may influence smart cast conditions, in some cases these conditions are modified along the sink-source chain. </span><span class="sentence">This means the following for different smart cast sources.</span></p>
</div>
<ul>
<li><span class="sentence">Conditional expressions (<code>if</code> and <code>when</code>):</span>
<ul>
<li><span class="sentence">Smart cast conditions derived from expression condition are active inside the true branch scope;</span></li>
<li><span class="sentence">Smart cast conditions derived from <em>negated</em> expression condition are active inside the false branch scope;</span></li>
<li><span class="sentence">If a branch is statically known to be definitely evaluated, that branch’s condition is also propagated over to its containing scope after the conditional expression;</span></li>
</ul></li>
<li><span class="sentence">Elvis operator (operator <code>?:</code>): if the right-hand side of elvis operator is unreachable, a nullability condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope;</span></li>
<li><span class="sentence">Safe navigation operator (operator <code>?.</code>) TODO()</span></li>
<li><span class="sentence">Logical conjunction expressions (operator <code>&amp;&amp;</code>): all conditions derived from the left-hand expression are applied to the right-hand expression;</span></li>
<li><span class="sentence">Logical disjunction expressions (operator <code>||</code>): all conditions derived from the left-hand expression are applied <em>negated</em> to the right-hand expression;</span></li>
<li><span class="sentence">Not-null assertion expressions (operator <code>!!</code>): a nullability condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope;</span></li>
<li><span class="sentence">Unsafe cast expression (operator <code>as</code>): a type condition for the left-hand side expression (if applicable) is introduced for the rest of the containing scope; the assumed type is the same as the right-hand side type of the cast expression;</span></li>
<li><span class="sentence">Direct assignment: if both sides of the assignment are applicable expressions, all the conditions currently applying to the right-hand side are also applied to the left-hand side of the assignment for the rest of the containing scope.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The necessity of source-sink domination also mean that smart cast sources from the loop bodies and conditions are <strong>not</strong> propagated to the containing scope, as the loop body may be evaluated zero or more times, and the corresponding conditions may or may not be true. </span><span class="sentence">However, some loop configurations, for which we can have static guarantees about source-sink domination w.r.t. the containing scope, are handled differently.</span></p>
</div>
<ul>
<li><span class="sentence">do-while loops (as their body is evaluated at least once) propagate the following to the rest of the containing scope:</span>
<ul>
<li><span class="sentence">smart cast sources from the loop body, which definitely dominate their sinks</span></li>
<li><span class="sentence">smart cast conditions arising from the <em>negated</em> loop condition, if the loop body does not contain any <code>break</code> expressions</span></li>
</ul></li>
<li><span class="sentence"><code>while (true)</code> loops propagate the following to the rest of the containing scope:</span>
<ul>
<li><span class="sentence">smart cast sources from the loop body, which definitely dominate their sinks</span></li>
</ul></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: in the second case, only the exact <code>while (true)</code> form is handled as described; e.g., <code>while (true == true)</code> does not work.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: one may extend the number of loop configurations, which are handled by smart casting, if the implementation can statically guarantee the source-sink domination.</span></p>
</div>
</blockquote>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<pre><code>fun breakFromInfiniteLoop() {
    var a: Any? = null

    while (true) {
        if (a == null) continue

        if (randomBoolean()) break
    }

    a // Smart cast to Any
}

fun doWhileAndSmartCasts() {
    var a: Any? = null

    do {
        if (a == null) continue
    } while (randomBoolean())
    
    a // Smart cast to Any
}

fun doWhileAndSmartCasts2() {
    var a: Any? = null

    do {
        sink(a)
    } while (a == null)

    a // Smart cast to Any
}</code></pre>
</blockquote>
<h4 id="bound-smart-casts">Bound smart casts</h4>
<div class="paragraph">
<p><span class="sentence">Smart casting propagates information forward on the control flow, as by the source-sink domination. </span><span class="sentence">However, in some cases it is beneficial to propagate information <em>backwards</em>, to reduce boilerplate code. </span><span class="sentence">Kotlin supports this feature by bound smart casts.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Bound smart casts apply in the following case. </span><span class="sentence">Assume we have two inter-dependent or bound values <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. </span><span class="sentence">Bound smart casts allow to apply smart cast sources for <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> or vice versa, if both values are stable.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin supports the following bound smart casts (BSC).</span></p>
</div>
<ul>
<li><span class="sentence">Non-nullability-by-equality BSC. </span><span class="sentence">If two values are known to be equal, non-nullability conditions for one are applied to the other.</span></li>
<li><span class="sentence">Non-nullability-by-safe-call BSC. </span><span class="sentence">For a safe-call property <code>o?.p</code> of a non-null type <span class="math inline">\(T\)</span>, non-nullability conditions for <code>o?.p</code> are applied to <code>o</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Two values <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are considered equals in the following cases.</span></p>
</div>
<ul>
<li><span class="sentence">there is a known equality or referential-equality condition between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span></span></li>
<li><span class="sentence"><span class="math inline">\(a\)</span> is definitely assigned <span class="math inline">\(b\)</span></span>
<ul>
<li><span class="sentence">however, in this case bound smart casts are applied only to <span class="math inline">\(b\)</span></span></li>
<li><div class="TODO">
<span class="sentence">TODO(Why?)</span>
</div></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Do we need additional condition kinds?)</span></p>
</div>
</div>
<h3 id="local-type-inference">Local type inference</h3>
<div class="paragraph">
<p><span class="sentence">Local type inference in Kotlin is the process of deducing the compile-time types of expressions, lambda expression parameters and properties. </span><span class="sentence">As mentioned above, type inference is a <a href="#kotlin-type-constraints">type constraint</a> problem, and is usually solved by a type constraint solver.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In addition to the types of intermediate expressions, local type inference also performs deduction and substitution for generic type parameters of functions and types involved in every expression. </span><span class="sentence">You can use the <a href="#expressions">Expressions</a> part of this specification as a reference point on how the types for different expressions are constructed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">However, there are some additional clarifications on how these types are constructed. </span><span class="sentence">First, the additional effects of <a href="#smart-casts">smart casting</a> are considered in local type inference, if applicable. </span><span class="sentence">Second, there are several special cases.</span></p>
</div>
<ul>
<li><span class="sentence">If a type <span class="math inline">\(T\)</span> is described as the least upper bound of types <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, it is represented as a pair of constraints <span class="math inline">\(A &lt;: T\)</span> and <span class="math inline">\(B &lt;: T\)</span>;</span></li>
<li><div class="TODO">
<span class="sentence">TODO(are there other cases?)</span>
</div></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Type inference in Kotlin is bidirectional; meaning the types of expressions may be derived not only from their arguments, but from their usage as well. </span><span class="sentence">Note that, albeit bidirectional, this process is still local, meaning it processes one statement at a time, strictly in the order of their appearance in a scope; e.g., the type of property in statement <span class="math inline">\(S_1\)</span> that goes before statement <span class="math inline">\(S_2\)</span> cannot be inferred based on how <span class="math inline">\(S_1\)</span> is used in <span class="math inline">\(S_2\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">As solving a type constraint system is not a definite process (there may be more than one valid solution for a given <a href="#type-constraint-solving">constraint system</a>), type inference in general may have several valid solutions. </span><span class="sentence">In particular, one may always derive a system <span class="math inline">\(A &lt;: T &lt;: B\)</span> for every type variable <span class="math inline">\(T\)</span>, where <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are both valid solution types. </span><span class="sentence">One of these types is always the solution in Kotlin (although from the constraint viewpoint, there are usually more solutions available), but choosing between them is done according to the following rules:</span></p>
</div>
<ul>
<li><div class="TODO">
<span class="sentence">TODO(what are the rules?)</span>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this is valid even if <span class="math inline">\(T\)</span> is a variable without any explicit constraints, as every type in Kotlin has an implicit constraint <span class="math inline">\(\mathtt{kotlin.Nothing} &lt;: T &lt;: \mathtt{kotlin.Any?}\)</span>.</span></p>
</div>
</blockquote>
<h3 id="todo-1">TODO</h3>
<ul>
<li><span class="sentence">Type approximation for public usage</span></li>
<li><span class="sentence">Ordering of lambdas (and ordering of overloading vs type inference in general)</span></li>
</ul>
<h2 id="overload-resolution">Overload resolution</h2>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>function overloading</em>, that is, the ability for several functions of the same name to coexist in the same scope, with the compiler picking the most suitable one when such a function is called. </span><span class="sentence">This section describes this mechanism in detail.</span></p>
</div>
<h3 id="intro">Intro</h3>
<div class="paragraph">
<p><span class="sentence">Unlike other object-oriented languages, Kotlin does not only have object methods, but also top-level functions, local functions, extension functions and function-like values, which complicate the overloading process quite a lot. </span><span class="sentence">Kotlin also has infix functions, operator and property overloading which all work in a similar, but subtly different way.</span></p>
</div>
<h3 id="receivers">Receivers</h3>
<div class="paragraph">
<p><span class="sentence">Every function or property that is defined as a method or an extension has one or more special parameters called <em>receiver</em> parameters. </span><span class="sentence">When calling such a callable using navigation operators (<code>.</code> or <code>?.</code>) the left hand side parameter is called an <em>explicit receiver</em> of this particular call. </span><span class="sentence">In addition to the explicit receiver, each call may indirectly access zero or more <em>implicit receivers</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Implicit receivers are available in some syntactic scope according to the following rules:</span></p>
</div>
<ul>
<li><span class="sentence">All receivers available in an outer scope are also available in the nested scope;</span></li>
<li><span class="sentence">In the scope of a classifier declaration, the following receivers are available:</span>
<ul>
<li><span class="sentence">The implicit <code>this</code> object of the declared type;</span></li>
<li><span class="sentence">The companion object (if one exists) of this class;</span></li>
<li><span class="sentence">The companion objects (if any exist) of all its superclasses;</span></li>
</ul></li>
<li><span class="sentence">If a function or a property is an extension, <code>this</code> parameter of the extension is also available inside the extension declaration;</span></li>
<li><span class="sentence">The scope of a lambda expression, if it has an extension function type, contains <code>this</code> argument of the lambda expression.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(If I’m a companion object, is a companion object of my supertype an implicit receiver for me or not?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The available receivers are prioritized in the following way:</span></p>
</div>
<ul>
<li><span class="sentence">The receivers provided in the most inner scope have higher priority;</span></li>
<li><span class="sentence">In a classifier body, the implicit <code>this</code> receiver has higher priority than any companion object receiver;</span></li>
<li><span class="sentence">Current class companion object receiver has higher priority than any of the base class companion objects.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The implicit receiver having the highest priority is also called the <em>default implicit receiver</em>. </span><span class="sentence">The default implicit receiver is available in the scope as <code>this</code>. </span><span class="sentence">Other available receivers may be accessed using <a href="#this-expressions">labeled this-expressions</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If an implicit receiver is available in a given scope, it may be used to call functions implicitly in that scope without using the navigation operator.</span></p>
</div>
<h3 id="the-forms-of-call-expression">The forms of call-expression</h3>
<div class="paragraph">
<p><span class="sentence">Any function in Kotlin may be called in several different ways:</span></p>
</div>
<ul>
<li><span class="sentence">A fully-qualified call: <code>package.foo()</code>;</span></li>
<li><span class="sentence">A call with an explicit receiver: <code>a.foo()</code>;</span></li>
<li><span class="sentence">An infix function call: <code>a foo b</code>;</span></li>
<li><span class="sentence">An overloaded operator call: <code>a + b</code>;</span></li>
<li><span class="sentence">A call without an explicit receiver: <code>foo()</code>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For each of these cases, a compiler should first pick a number of <em>overload candidates</em>, which form a set of possibly intended callables (<em>overload candidate set</em>), and then <em>choose the most specific function</em> to call based on the types of the function and the call arguments.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: the overload candidates are picked <strong>before</strong> the most specific function is chosen.</span></p>
</div>
</blockquote>
<h3 id="callables-and-invoke-convention">Callables and <code>invoke</code> convention</h3>
<div class="paragraph">
<p><span class="sentence">A <em>callable</em> <span class="math inline">\(X\)</span> for the purpose of this section is one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">Function-like callables:</span>
<ul>
<li><span class="sentence">A function named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
<li><span class="sentence">A function named <span class="math inline">\(Y\)</span> at its declaration site, but imported into the current scope using <a href="#importing">a renaming import</a> as <span class="math inline">\(X\)</span>;</span></li>
<li><span class="sentence">A constructor of the type named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
</ul></li>
<li><span class="sentence">Property-like callables, one of the following with an operator function called <code>invoke</code> available as member or extension in the current scope:</span>
<ul>
<li><span class="sentence">A property named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
<li><span class="sentence">[An object][Object declarations] named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
<li><span class="sentence">[A companion object][Companion objects] of a classifier type named <span class="math inline">\(X\)</span> at its declaration site;</span></li>
<li><span class="sentence">Any of the above named <span class="math inline">\(Y\)</span> at its declaration site, but imported into the current scope using <a href="#importing">a renaming import</a> as <span class="math inline">\(X\)</span>.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In the latter case a call <span class="math inline">\(X(Y_0,Y_1,\ldots,Y_N)\)</span> is an overloadable operator which is expanded to <span class="math inline">\(X\text{.invoke}(Y_0,Y_1,\ldots,Y_N)\)</span>. </span><span class="sentence">The call may contain type parameters, named parameters, variable argument parameter expansion and trailing lambda parameters, all of which are forwarded as-is to the corresponding <code>invoke</code> function.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The set of explicit receivers itself (denoted by a [<code>this</code>][This-expression] expression, labeled or not) may also be used as a property-like callable using <code>this</code> as the left-hand side of the call expression. </span><span class="sentence">As with normal property-like callables, <span class="math inline">\(\mathtt{this@A}(Y_0,Y_1,\ldots,Y_N)\)</span> is an overloadable operator which is expanded to <span class="math inline">\(\mathtt{this@A.invoke}(Y_0,Y_1,\ldots,Y_N)\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A <em>member callable</em> is either a member function-like callable or a member property-like callable with a member operator <code>invoke</code>. </span><span class="sentence">An <em>extension callable</em> is either an extension function-like callable, a member property-like callable with an extension operator <code>invoke</code> or an extension property-like callable with an extension operator <code>invoke</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When calculating overload candidate sets, member callables produce the following separate sets (ordered by higher priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Member function-like callables;</span></li>
<li><span class="sentence">Member property-like callables.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Extension callables produce the following separate sets (ordered by higher priority first):</span></p>
</div>
<ul>
<li><span class="sentence">Extension functions;</span></li>
<li><span class="sentence">Member property-like callables with extension invoke;</span></li>
<li><span class="sentence">Extension property-like callables with member invoke;</span></li>
<li><span class="sentence">Extension property-like callables with extension invoke.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Let us define this partition as c-level partition (callable-level partition). </span><span class="sentence">As this partition is the most fine-grained of all other steps of partitioning resolution candidates into sets, it is always performed last, after all other applicable steps.</span></p>
</div>
<h3 id="overload-resolution-for-a-fully-qualified-call">Overload resolution for a fully-qualified call</h3>
<div class="paragraph">
<p><span class="sentence">If a callable name is fully-qualified (that is, it contains a full package path), then the overload candidate set <span class="math inline">\(S\)</span> simply contains all the callables with the specified name in the specified package. </span><span class="sentence">As a package name can never clash with any other declared entity, after performing c-level partition on <span class="math inline">\(S\)</span>, the resulting sets are the only ones available for further processing.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Clear up this mess)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Example:</span></p>
</div>
<div class="sourceCode" id="cb37"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">package</span> <span class="im">a.b.c</span></a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Int</span>) {}</a>
<a class="sourceLine" id="cb37-4" title="4"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">Double</span>) {}</a>
<a class="sourceLine" id="cb37-5" title="5"><span class="kw">fun</span> <span class="fu">foo</span>(<span class="va">a</span>: <span class="dt">List</span>&lt;<span class="va">Char</span>&gt;) {}</a>
<a class="sourceLine" id="cb37-6" title="6"><span class="kw">val</span> <span class="va">foo</span> = {}</a>
<a class="sourceLine" id="cb37-7" title="7">. . .</a>
<a class="sourceLine" id="cb37-8" title="8">a.b.c.foo()</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Here the resulting overload candidate set contains all the callables named <code>foo</code> from the package <code>a.b.c</code>.</span></p>
</div>
<h3 id="a-call-with-an-explicit-receiver">A call with an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">If a function call is done via a <a href="#navigation-operators">navigation operator</a> (<code>.</code> or <code>?.</code>, not to be confused with a <a href="#overload-resolution-for-a-fully-qualified-call">fully-qualified call</a>), then the left hand side operand of the call is the explicit receiver of this call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A call of callable <code>f</code> with an explicit receiver <code>e</code> is correct if one (or more) of the following holds:</span></p>
</div>
<ol type="1">
<li><span class="sentence"><code>f</code> is a member callable of the classifier type of <code>e</code> or any of its supertypes;</span></li>
<li><span class="sentence"><code>f</code> is an extension callable of the classifier type of <code>e</code> or any of its supertypes, including local and imported extensions.</span></li>
</ol>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Important: callables for case 2 include not only top-level extension callables, but also extension callables from any of the available implicit receivers. </span><span class="sentence">For example, if class <span class="math inline">\(P\)</span> contains a member extension function for another class <span class="math inline">\(T\)</span> and an object of class <span class="math inline">\(P\)</span> is available as an implicit receiver, this extension function may be used for the call if it has a suitable type.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If a call is correct, for a callable named <code>f</code> with an explicit receiver <code>e</code> of type <code>T</code> the following sets are analyzed (in the given order):</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Sync with scopes and stuff when we have them)</span></p>
</div>
</div>
<ol type="1">
<li><span class="sentence">The sets of non-extension member callables named <code>f</code> of type <code>T</code>;</span></li>
<li><span class="sentence">The sets of local extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>, in all declaration scopes containing the current declaration scope, ordered by the size of the scope (smallest first), excluding the package scope;</span></li>
<li><span class="sentence">The sets of explicitly imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>;</span></li>
<li><span class="sentence">The sets of extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>, declared in the package scope;</span></li>
<li><span class="sentence">The sets of star-imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>;</span></li>
<li><span class="sentence">The sets of implicitly imported extension callables named <code>f</code>, whose receiver type conforms to type <code>T</code>.</span></li>
</ol>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: here type <code>U</code> conforms to type <code>T</code>, if <span class="math inline">\(T &lt;: U\)</span>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">When analyzing these sets, the <strong>first</strong> set that contains <strong>any</strong> callable with the corresponding name and conforming types is picked. </span><span class="sentence">This means, among other things, that if the set constructed on step 2 contains the overall most suitable candidate function, but the set constructed on step 1 is not empty, the functions from set 1 will be picked despite them being less suitable overload candidates.</span></p>
</div>
<h3 id="infix-function-calls">Infix function calls</h3>
<div class="paragraph">
<p><span class="sentence">Infix function calls are a special case of function calls with an explicit receiver in the left hand side position, i.e., <code>a foo b</code> may be an infix form of <code>a.foo(b)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">However, there is an important difference: during the overload candidate set construction the only functions considered for inclusion are the ones with the <code>infix</code> modifier. </span><span class="sentence">All other functions (and any properties) are not even considered for inclusion. </span><span class="sentence">Aside from this difference, candidates are selected using the same rules as for normal calls with explicit receiver.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that all properties available through the <code>invoke</code> convention are non-eligible for infix calls, as there is no way of specifying the <code>infix</code> modifier for them.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions considered as infix functions for the overload candidate set.</span></p>
</div>
<h3 id="operator-calls">Operator calls</h3>
<div class="paragraph">
<p><span class="sentence">According to <a href="#overloadable-operators">the overloadable operators section</a>, some operator expressions in Kotlin can be overloaded using specially-named functions. </span><span class="sentence">This makes operator expressions semantically equivalent to function calls with explicit receiver, where the receiver expression is selected based on the operator used. </span><span class="sentence">The selection of an exact function called in each particular case is based on the same rules as for function calls with explicit receivers, the only difference being that only functions with <code>operator</code> modifier are considered for inclusion when building overload candidate sets. </span><span class="sentence">Any properties are never considered for the overload candidate sets of operator calls.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this also means that all the properties available through the <code>invoke</code>convention are non-eligible for operator calls, as there is no way of specifying the <code>operator</code> modifier for them, even though the <code>invoke</code> callable is required to always have such modifier. </span><span class="sentence">As <code>invoke</code> convention itself is an operator call, it is impossible to use more than one <code>invoke</code> conventions in a single call.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Different platform implementations may extend the set of functions considered as operator functions for the overload candidate set.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: these rules are valid not only for dedicated operator expressions, but also for any calls arising from expanding <a href="#for-loop-statement"><code>for</code>-loop</a> iteration conventions, <a href="#assignments">assignments</a> or <a href="#delegated-property-declaration">property delegates</a>.</span></p>
</div>
</blockquote>
<h3 id="a-call-without-an-explicit-receiver">A call without an explicit receiver</h3>
<div class="paragraph">
<p><span class="sentence">A call which is performed with unqualified function name and without using a navigation operator is a call without an explicit receiver. </span><span class="sentence">It may have one or more implicit receivers or reference a top-level function.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this does not include calls using the <code>invoke</code> operator function where the left side of the call operator is not an identifier, but some other kind of expression. </span><span class="sentence">These cases are handled the same way as covered in the <a href="#operator-calls">previous section</a> and need no special treatment</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">As with function calls with explicit receiver, we should first pick a valid overload candidate set and then search this set for the <em>most specific function</em> to match the call.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For an idenitifer named <code>f</code> the following sets are analyzed (in the given order):</span></p>
</div>
<ol type="1">
<li><span class="sentence">The sets of local non-extension functions named <code>f</code> available in the current scope, in order of the scope they are declared in, smallest scope first;</span></li>
<li><span class="sentence">The overload candidate sets for each implicit receiver <code>r</code> and <code>f</code>, calculated as if <code>r</code> is the explicit receiver, in order of the receiver priority (see the <a href="#a-call-with-an-explicit-receiver">corresponding section</a>);</span></li>
<li><span class="sentence">Top-level non-extension functions named <code>f</code>, in the order of:</span>
<ol type="a">
<li><span class="sentence">Functions explicitely imported into current file;</span></li>
<li><span class="sentence">Functions declared in the same package;</span></li>
<li><span class="sentence">Functions star-imported into current file;</span></li>
<li><span class="sentence">Implicitly imported functions (either Kotlin standard library or platform-specific ones).</span></li>
</ol></li>
</ol>
<div class="paragraph">
<p><span class="sentence">When analyzing these sets, the <strong>first</strong> set which contains <strong>any</strong> function with the corresponding name and conforming types is picked.</span></p>
</div>
<h3 id="calls-with-named-parameters">Calls with named parameters</h3>
<div class="paragraph">
<p><span class="sentence">Most of the calls in Kotlin may use named parameters in call expressions, e.g., <code>f(a = 2)</code>, where <code>a</code> is a parameter specified in the declaration of <code>f</code>. </span><span class="sentence">Such calls are treated the same way as normal calls, but the overload resolution sets are filtered to only contain callables which have matching formal parameters for all named parameters from the call.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: for properties called via <code>invoke</code> convention, the named parameters must be present in the declaration of the <code>invoke</code> operator function.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Unlike positional arguments, named arguments are matched by name directly to their respective formal parameters; this matching is performed separately for each function candidate. </span><span class="sentence">While the number of defaults (see <a href="#choosing-the-most-specific-function-from-the-overload-candidate-set">the MSC selection process</a>) does affect resolution process, the fact that some argument was or was not mapped as a named argument does not affect this process in any way.</span></p>
</div>
<h3 id="calls-with-trailing-lambda-expressions">Calls with trailing lambda expressions</h3>
<div class="paragraph">
<p><span class="sentence">A call expression may have a single lambda expression placed outside of the argument list parentheses or even completely replacing them (see [this section][Call expression] for further details). </span><span class="sentence">This has no effect on the overload resolution process, aside from the argument reordering which may happen because of variable argument parameters or parameters with defaults.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Example: this means that calls <code>f(1,2) { g() }</code> and <code>f(1,2, body = { g() })</code> are completely equivalent w.r.t. the overload resolution, assuming <code>body</code> is the name of the last formal parameter of <code>f</code>.</span></p>
</div>
</blockquote>
<h3 id="calls-with-specified-type-parameters">Calls with specified type parameters</h3>
<div class="paragraph">
<p><span class="sentence">A call expression may have a type argument list explicitly specified before the argument list (see [this section][Call expression] for further details).. </span><span class="sentence">In this case all the potential overload sets only include callables which contain exactly the same number of formal type parameters at declaration site. </span><span class="sentence">In case of a property callable via <code>invoke</code> convention, type parameters must be present at the <code>invoke</code> operator function declaration.</span></p>
</div>
<h3 id="determining-function-applicability-for-a-specific-call">Determining function applicability for a specific call</h3>
<h4 id="rationale">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">A function is <em>applicable</em> for a specific call if and only if the function parameters may be assigned the values of the arguments specified at call site and all type constraints of the function hold.</span></p>
</div>
<h4 id="description">Description</h4>
<div class="paragraph">
<p><span class="sentence">Determining function applicability for a specific call is a [type constraint][Type constraints] problem. </span><span class="sentence">First, for every non-lambda argument of the function supplied in the call, type inference is performed. </span><span class="sentence">Lambda arguments are excluded, as their type inference needs the results of overload resolution to finish.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Second, the following constraint system is built:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-lambda parameter inferred to have type <span class="math inline">\(T_i\)</span>, corresponding to the function argument of type <span class="math inline">\(U_j\)</span>, a constraint <span class="math inline">\(T_i &lt;: U_j\)</span> is constructed;</span></li>
<li><span class="sentence">All declaration-site type constraints for the function are also added to the constraint system;</span></li>
<li><span class="sentence">For every lambda parameter with the number of lambda arguments known to be <span class="math inline">\(K\)</span>, corresponding to the function argument of type <span class="math inline">\(U_m\)</span>, a special constraint of the form <span class="math inline">\(R(L_1, \ldots, L_K) &lt;: U_m\)</span> is added to the constraint system, where <span class="math inline">\(R, L_1, \ldots, L_K\)</span> are fresh variables;</span></li>
<li><span class="sentence">For each lambda parameter with an unknown number of lambda arguments (that is, being equal to 0 or 1), a special constraint of the form <span class="math inline">\(kotlin.Function &lt;: U_m\)</span> is added to the constraint system, where <span class="math inline">\(kotlin.Function\)</span> is the common base of all functional types <span><span class="TODO">(TODO(what’s the spec name?))</span><span class="TODO-marker">*</span></span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If this constraint system is sound, the function is applicable for the call. </span><span class="sentence">Only applicable functions are considered for the next step: finding the most specific overload candidate from the candidate set.</span></p>
</div>
<h3 id="choosing-the-most-specific-function-from-the-overload-candidate-set">Choosing the most specific function from the overload candidate set</h3>
<h4 id="rationale-1">Rationale</h4>
<div class="paragraph">
<p><span class="sentence">The main rationale in choosing the most specific function from the overload candidate set is the following:</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">The most specific function can forward itself to any other function from the overload candidate set, while the opposite is not true.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If there are several functions with this property, none of them are the most specific and an ambiguity error should be reported by the compiler.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Consider the following example with two functions:</span></p>
</div>
<div class="sourceCode" id="cb38"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {}        <span class="co">// (1)</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="kw">fun</span> <span class="fu">f</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {} <span class="co">// (2)</span></a>
<a class="sourceLine" id="cb38-3" title="3">...</a>
<a class="sourceLine" id="cb38-4" title="4">f(<span class="dv">2</span>, <span class="st">&quot;Hello&quot;</span>)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">Both functions (1) and (2) are applicable for the call, but function (1) could easily call function (2) by forwarding both arguments into it, and the reverse is impossible. </span><span class="sentence">As a result, function (1) is more specific of the two.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The following snippet should explain this in more detail.</span></p>
</div>
<div class="sourceCode" id="cb39"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">fun</span> <span class="fu">f1</span>(<span class="va">arg</span>: <span class="dt">Int</span>, <span class="va">arg2</span>: <span class="dt">String</span>) {</a>
<a class="sourceLine" id="cb39-2" title="2">    f2(arg, arg2) <span class="co">// valid: can forward both arguments</span></a>
<a class="sourceLine" id="cb39-3" title="3">}</a>
<a class="sourceLine" id="cb39-4" title="4"><span class="kw">fun</span> <span class="fu">f2</span>(<span class="va">arg</span>: <span class="dt">Any?</span>, <span class="va">arg2</span>: <span class="dt">CharSequence</span>) {</a>
<a class="sourceLine" id="cb39-5" title="5">    f1(arg, arg2) <span class="co">// invalid: function f1 is not applicable</span></a>
<a class="sourceLine" id="cb39-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The rest of this section will try to clarify this mechanism in more detail.</span></p>
</div>
<h4 id="description-1">Description</h4>
<div class="paragraph">
<p><span class="sentence">When an overload resolution set <span class="math inline">\(S\)</span> is selected and it contains more than one callable, the next step is to choose the most appropriate candidate from these callables.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The selection process uses the [type constraint][Type constraints] system of Kotlin, in a way similar to the process of <a href="#determining-function-applicability-for-a-specific-call">determining function applicability</a>. </span><span class="sentence">For every two distinct members of the candidate set <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span>, the following constraint system is constructed and solved:</span></p>
</div>
<ul>
<li><span class="sentence">For every non-default argument of the call, the corresponding value parameter types <span class="math inline">\(X_1, X_2, X_3, \ldots, X_N\)</span> of <span class="math inline">\(F_1\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3, \ldots, Y_N\)</span> of <span class="math inline">\(F_2\)</span>, a type constraint <span class="math inline">\(X_K &lt;: Y_K\)</span> is built <strong>unless both <span class="math inline">\(X_K\)</span> and <span class="math inline">\(Y_K\)</span> are <a href="#built-in-integer-types">built-in integer types</a>.</strong> During construction of these constraints, all type parameters <span class="math inline">\(T_1, T_2, \ldots, T_M\)</span> of <span class="math inline">\(F_1\)</span> are considered bound to fresh type variables <span class="math inline">\(T^{\sim}_1, T^{\sim}_2, \ldots, T^{\sim}_M\)</span>, and all type parameters of <span class="math inline">\(F_2\)</span> are considered free;</span></li>
<li><span class="sentence">All declaration-site type constraints of <span class="math inline">\(X_1, X_2, X_3, \ldots, X_N\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3, \ldots, Y_N\)</span> are also added to the constraint system.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">If the resulting constraint system is sound, it means that <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> as an overload candidate (aka applicability criteria). </span><span class="sentence">The check is then repeated with <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> swapped. </span><span class="sentence">If <span class="math inline">\(F_1\)</span> is equally or more applicable than <span class="math inline">\(F_2\)</span> and <span class="math inline">\(F_2\)</span> is equally or more applicable than <span class="math inline">\(F_1\)</span>, this means that the two callables are equally applicable and additional decision steps are needed to choose the most specific overload candidate. </span><span class="sentence">If neither <span class="math inline">\(F_1\)</span> nor <span class="math inline">\(F_2\)</span> is equally or more applicable than its counterpart, it also means that <span class="math inline">\(F_1\)</span> and <span class="math inline">\(F_2\)</span> are equally applicable and additional decision steps are needed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">All members of the overload candidate set are ranked according to the applicability criteria. </span><span class="sentence">If there are several callables which are more applicable than all other candidates and equally applicable to each other, an additional step is performed.</span></p>
</div>
<ul>
<li><span class="sentence">Any non-generic (meaning that it does not have type parameters in its declaration) callable is a more specific candidate than any generic (containing type parameters in its declaration) callable. </span><span class="sentence">If there are several non-generic candidates, further steps are limited to those candidates;</span></li>
<li><span class="sentence">For every non-default argument of the call consider the corresponding value parameter types <span class="math inline">\(X_1, X_2, X_3, \ldots, X_N\)</span> of <span class="math inline">\(F_1\)</span> and <span class="math inline">\(Y_1, Y_2, Y_3, \ldots, Y_N\)</span> of <span class="math inline">\(F_2\)</span>. </span><span class="sentence">If, for any <span class="math inline">\(K\)</span>, both <span class="math inline">\(X_K\)</span> and <span class="math inline">\(Y_K\)</span> are different built-in integer types and one of them is <code>kotlin.Int</code>, then this parameter is preferred over the other parameter of the call. </span><span class="sentence">If all such parameters of <span class="math inline">\(F_1\)</span> are preferred based on this criteria over the parameters of <span class="math inline">\(F_2\)</span>, then <span class="math inline">\(F_1\)</span> is a more specific candidate than <span class="math inline">\(F_2\)</span>, and vice versa.</span></li>
<li><span class="sentence">For each candidate, we count the number of default parameters <em>not</em> specified in the call (i.e., the number of parameters for which we use the default value);</span></li>
<li><span class="sentence">The candidate with the least number of non-specified default parameters is a more specific candidate;</span></li>
<li><span class="sentence">If the number of non-specified default parameters is equal for several candidates, the candidate having any variable-argument parameters is less specific than any candidate without them.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: it may seem strange to process built-in integer types in a way different from other types, but it is important in cases where the actual call argument is an integer literal having an <a href="#integer-literal-types">integer literal type</a>. </span><span class="sentence">In this particular case, several functions with different built-in integer types for the corresponding parameter may be applicable, and it is preferred to have the <code>kotlin.Int</code> overload as the most specific.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">If after this additional step there are still several candidates that are equally applicable for the call, this is an <strong>overload ambiguity</strong> which must be reported as a compiler error.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: unlike the applicability test, the candidate comparison constraint system is <strong>not</strong> based on the actuall call, meaning that, when comparing two candidates, only constraints visible at <em>declaration site</em> apply.</span></p>
</div>
</blockquote>
<h3 id="about-type-inference">About type inference</h3>
<div class="paragraph">
<p><span class="sentence"><a href="#type-inference">Type inference</a> in Kotlin is a pretty complicated process, which is performed after resolving all the overload candidates. </span><span class="sentence">Due to the complexity of the process, type inference may not affect the way overload resolution candidate is picked up.</span></p>
</div>
<h4 id="todos-1">TODOs</h4>
<ul>
<li><span class="sentence">Property business</span></li>
<li><span class="sentence">Function types (type system section?)</span></li>
<li><span class="sentence">Definition of “type parameter level”</span></li>
<li><span class="sentence">Calls with trailing lambda without parameter type</span>
<ul>
<li><span class="sentence">Lambdas with parameter types seem to be covered (<strong>nope, they are not</strong>)</span></li>
</ul></li>
<li><span class="sentence">Calls with specified type parameters <code>f&lt;Double&gt;(3)</code></span></li>
<li><span class="sentence">Widen the notion of “function” and “property” during overloading</span>
<ul>
<li><span class="sentence">Constructors and companion object <code>invoke</code> (clash with functions)</span></li>
<li><span class="sentence">Singleton objects (clash with properties)</span></li>
<li><span class="sentence">Enum constants (clash with properties)</span></li>
<li><span class="sentence">Explicit <code>this</code> cannot clash with properties, but can clash with other explicit <code>this</code>, meaning it effectively overloads over all the available receivers in the scope</span></li>
<li><span class="sentence">Can <code>super</code> be overloaded? </span><span class="sentence">I suppose</span></li>
</ul></li>
</ul>
<h2 id="concurrency">Concurrency</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="coroutines">Coroutines</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(everything: state machine, context, etc.)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: as of Kotlin 1.2, the support for coroutines is experimental</span></p>
</div>
</blockquote>
<h3 id="suspending-functions">Suspending functions</h3>
<div class="paragraph">
<p><span class="sentence">Any <a href="#function-declaration">function declaration</a> or a getter/setter declaration in Kotlin may be marked <em>suspending</em> using the special <code>suspend</code> modifier. </span><span class="sentence">A function type for a particular value may also be marked suspending using the <code>suspend</code> modifier. </span><span class="sentence">Both normal functions and extension functions, top-level and member, anonymous and named, may be marked as suspending.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>suspend val</code>?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A suspending function is different from normal functions by potentially having zero or more <em>suspension points</em> — statements in its body that may pause the function execution to be resumed at a later moment in time. </span><span class="sentence">Each call to another suspending function inside the body of a suspending function is a suspension point. </span><span class="sentence">Suspension points are important because at such a point another function may start being executed in the same flow of execution, leading to potential changes in shared state in the middle of a function execution flow.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Normal functions may not call suspending functions directly, meaning they do not have suspension points. </span><span class="sentence">Suspending functions may call normal functions without any limitation, such calls are not suspension points. </span><span class="sentence">The exception for this rule are inlined lambda parameters that, if the inlined higher-order function invoking them is called from a suspending function, may also have suspension points and call other suspending functions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: suspending functions interleaving each other in this manner is not dissimilar to how functions from different threads interact on platforms that support multithreading. </span><span class="sentence">There are, however, several key differences. </span><span class="sentence">First, suspending functions may pause only at suspension points, this process cannot be paused at arbitrary execution point. </span><span class="sentence">Second, this may happen in one platform thread. </span><span class="sentence">In multithreaded environment, suspension functions may also be interleaved by the usual rules of concurrent execution on this platform, independent of the interleaving of coroutines.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">The implementation of suspending functions on a particular platform is platform-dependent. </span><span class="sentence">Please refer to the platform documentation for details.</span></p>
</div>
<h3 id="coroutine-intrinsics">Coroutine intrinsics</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Do we need them?)</span></p>
</div>
</div>
<h2 id="annotations">Annotations</h2>
<div class="paragraph">
<p><span class="sentence">Annotations are a form of syntactically-defined metadata that may be associated with different entities in a Kotlin program. </span><span class="sentence">Annotations are specified in the source code of the program and may be accessed on a particular platform using platform-specific mechanisms both by the compiler (and source-processing tools) and during runtime (using [reflection][Reflection] facilities). </span><span class="sentence">Values of annotation types cannot be created directly, but can be operated when accessed using platform-specific facilities.</span></p>
</div>
<h3 id="annotation-values">Annotation values</h3>
<div class="paragraph">
<p><span class="sentence">An annotation value is a value of a special [Annotation type][Annotation types]. </span><span class="sentence">An annotation type is a special kind of class type that is allowed to include properties of the following types:</span></p>
</div>
<ul>
<li><span class="sentence"><a href="#built-in-integer-types">Integer types</a>;</span></li>
<li><span class="sentence">String type;</span></li>
<li><span class="sentence">Other annotation types;</span></li>
<li><span class="sentence"><a href="#array-types">Arrays</a> of any type listed above.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Annotation classes are not allowed to have any member functions, constructors or mutable properties. </span><span class="sentence">They are also not allowed to have base classes besides <code>kotlin.Annotation</code>.</span></p>
</div>
<h3 id="annotation-retention">Annotation retention</h3>
<div class="paragraph">
<p><span class="sentence">The retention level of an annotation declares which compilation artifacts a particular compiler on a particular platform do retain this kind of annotation. </span><span class="sentence">There are the following types of retention available:</span></p>
</div>
<ul>
<li><span class="sentence">Source retention (accessible by source-processing tools);</span></li>
<li><span class="sentence">Binary retention (retained in compilation artifacts);</span></li>
<li><span class="sentence">Runtime retention (accessible during runtime).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">For availability and particular ways of accessing the metadata specified by these annotations please refer to the corresponding platforms’ documentation.</span></p>
</div>
<h3 id="annotation-targets">Annotation targets</h3>
<div class="paragraph">
<p><span class="sentence">The <em>targets</em> of a particular type of annotations is the kind of entity which this annotations may be placed on. </span><span class="sentence">There are the following targets available:</span></p>
</div>
<ul>
<li><span class="sentence">A <a href="#class-declaration">class declaration</a> (including annotation classes);</span></li>
<li><span class="sentence">An <a href="#annotation-class-declaration">annotation class declaration</a>;</span></li>
<li><span class="sentence">A <a href="#type-system">type</a> parameter;</span></li>
<li><span class="sentence">A <a href="#property-declaration">property declaration</a>;</span></li>
<li><span class="sentence">A property backing field;</span></li>
<li><span class="sentence">A property getter;</span></li>
<li><span class="sentence">A property setter;</span></li>
<li><span class="sentence">A local property declaration;</span></li>
<li><span class="sentence">A value parameter (<a href="#function-declaration">function</a> or <a href="#constructor-declaration">constructor</a> declaration);</span></li>
<li><span class="sentence">A <a href="#constructor-declaration">constructor</a>;</span></li>
<li><span class="sentence">A <a href="#function-declaration">function declaration</a>;</span></li>
<li><span class="sentence">A type usage;</span></li>
<li><span class="sentence">An [expression][Expression];</span></li>
<li><span class="sentence">A [Kotlin file][Kotlin file scope];</span></li>
<li><span class="sentence">A [type alias declaration][Type alias declaration].</span></li>
</ul>
<h3 id="annotation-declarations">Annotation declarations</h3>
<div class="paragraph">
<p><span class="sentence">Annotations are declared using <a href="#annotation-class-declaration">annotation class declarations</a>. </span><span class="sentence">See the corresponding section for details.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="builtin-annotations">Builtin annotations</h3>
<ul>
<li><span class="sentence">Deprecated / ReplaceWith</span></li>
<li><span class="sentence">Suppress</span></li>
<li><span class="sentence">SinceKotlin</span></li>
<li><span class="sentence">UnsafeVariance</span></li>
<li><span class="sentence">DslMarker</span></li>
<li><span class="sentence">PublishedApi</span></li>
<li><span class="sentence">Contract-related stuff???</span></li>
</ul>
<h2 id="documentation-comments">Documentation comments</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h2 id="exceptions">Exceptions</h2>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(This is a stub)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">An <em>exception</em> type declaration is any type declaration that meets the following criteria:</span></p>
</div>
<ul>
<li><span class="sentence">It is a <a href="#classifier-declaration">class or object declaration</a>;</span></li>
<li><span class="sentence">It has <code>kotlin.Throwable</code> as supertype;</span></li>
<li><span class="sentence">It has no type parameters.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Any object of an exception type may be <em>thrown</em> or <em>catched</em>.</span></p>
</div>
<h3 id="catching-exceptions">Catching exceptions</h3>
<div class="paragraph">
<p><span class="sentence">A <a href="#try-expression"><code>try</code>-expression</a> becomes <em>active</em> once the execution of the program enters it and stops being active once the execution of the program leaves it. </span><span class="sentence">If there are several active <code>try</code>-expressions, the one that became active last is <em>currently active</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If an exception is thrown while a try-expression is currently active and this try-expression has any <code>catch</code>-blocks, those <code>catch</code>-blocks are checked for applicability for this exception. </span><span class="sentence">A <code>catch</code>-block is applicable for an exception object if the runtime type of this expression object is a subtype of the bound exception parameter of this <code>catch</code>-block. </span><span class="sentence">Note that this is subject to Kotlin <a href="#runtime-type-information">runtime type information</a> limitations and may be dependent on the platform implementation of runtime type information, as well as the implementation of exception classes.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a <code>catch</code>-block is applicable for the exception thrown, the code inside the block is evaluated and the value of the block is returned as the value of a <code>try</code>-expression. </span><span class="sentence">If this <code>try</code>-expression contains a <code>finally</code>-block, the body of this block is evaluated after the body of the selected <code>catch</code> block. </span><span class="sentence">The <code>try</code>-expression itself is not considered active inside its own <code>catch</code> and <code>finally</code> blocks. </span><span class="sentence">If this results in throwing other exceptions (including the one caught by the <code>catch</code>-block), they are propagated as normal.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If none of the <code>catch</code>-blocks of the currently active <code>try</code>-expression are applicable for the exception, the <code>finally</code> block (if any) is still evaluated and the exception is propagated, meaning that the next active <code>try</code>-expression becomes currently active and is checked for applicability.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If there is not a single active <code>try</code>-block, the execution of the program finishes, signaling that the exception has reached top level.</span></p>
</div>
<h3 id="throwing-exceptions">Throwing exceptions</h3>
<div class="paragraph">
<p><span class="sentence">Throwing an exception object is performed using <code>throw</code>-expression. </span><span class="sentence">A valid throw expression <code>throw e</code> requires that:</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is a value of <a href="#runtime-available-types">a runtime-available type</a>;</span></li>
<li><span class="sentence"><code>e</code> is a value of an exception type (see above).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Throwing an exception results in checking active <code>try</code>-blocks as described above.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin does not specify whether throwing exceptions involves construction of a program stack trace and how the actual exception handling is performed internally. </span><span class="sentence">This is a platform-dependent mechanism.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: control flow?</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: concurrency?</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: write it better</span></p>
</div>
</div>
</body>
</html>
