<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Untitled</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../assets/css/main.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="../assets/js/tests-integration.js"></script>
</head>
<body>










<h2 id="declarations">Declarations</h2>
<h3 id="glossary">Glossary</h3>
<dl>
<dt>Entity</dt>
<dd><span class="sentence">A distinguishable part of a program</span>
</dd>
<dt>Path</dt>
<dd><span class="sentence">A sequence of names which identifies a program entity</span>
</dd>
</dl>
<h3 id="identifiers-names-and-paths">Identifiers, names and paths</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Explain paths)</span></p>
</div>
</div>
<h3 id="introduction">Introduction</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Declarations in Kotlin are used to introduce entities (values, types, etc.); most declarations are <em>named</em>, i.e. they also assign an identifier to their own entity, however, some declarations may be <em>anonymous</em>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Every declaration is accessible in a particular <em>scope</em>, which is dependent both on where the declaration is located and on the declaration itself.</span></p>
</div>
<h3 id="classifier-declaration">Classifier declaration</h3>
<strong>Id grammar-rule-classDeclaration not found</strong>
<strong>Id grammar-rule-objectDeclaration not found</strong>
<div class="paragraph">
<p><span class="sentence">Classifier declarations introduce new types to the program, of the forms described [here][Classifier types]. </span><span class="sentence">There are three kinds of classifier declarations:</span></p>
</div>
<ul>
<li><span class="sentence">class declarations;</span></li>
<li><span class="sentence">interface declarations;</span></li>
<li><span class="sentence">object declarations.</span></li>
</ul>
<h4 id="class-declaration">Class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A simple class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span>;</span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span>;</span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span>;</span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following:</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span>;</span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span>;</span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span>;</span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span>;</span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span>;</span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span>.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a simple classifier type <span class="math inline">\(c : S_1, \ldots, S_s\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Supertype specifiers are used to create inheritance relation between the declared type and the specified supertype. </span><span class="sentence">You can use classes and interfaces as supertypes, but not objects.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">It is allowed to inherit from a single class only, i.e., multiple class inheritance is not supported. </span><span class="sentence">Multiple interface inheritance is allowed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Instance initialization block describes a block of code which should be executed during <a href="#classifier-initialization">object creation</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Property and function declarations in the class body introduce their respective entities in this class’ scope, meaning they are available only on an entity of the corresponding class.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Companion object declaration <code>companion object CO { ... }</code> for class <code>C</code> introduces an object, which is available under this class’ name or under the path <code>C.CO</code>. </span><span class="sentence">Companion object name may be omitted, in which case it is considered to be equal to <code>Companion</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Nested classifier declarations introduce new classifiers, available under this class’ path for all nested classifiers except for inner classes. </span><span class="sentence">Inner classes are available only on the corresponding class’ entities. </span><span class="sentence">Further details are available [here][Inner and nested classes].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Examples)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized class declaration consists of the following parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(c\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">primary constructor declaration <span class="math inline">\(ptor\)</span></span></li>
<li><span class="sentence">supertype specifiers <span class="math inline">\(S_1, \ldots, S_s\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span>, which may include the following</span>
<ul>
<li><span class="sentence">secondary constructor declarations <span class="math inline">\(stor_1, \ldots, stor_c\)</span></span></li>
<li><span class="sentence">instance initialization block <span class="math inline">\(init\)</span></span></li>
<li><span class="sentence">property declarations <span class="math inline">\(prop_1, \ldots, prop_p\)</span></span></li>
<li><span class="sentence">function declarations <span class="math inline">\(md_1, \ldots, md_m\)</span></span></li>
<li><span class="sentence">companion object declaration <span class="math inline">\(companionObj\)</span></span></li>
<li><span class="sentence">nested classifier declarations <span class="math inline">\(nested\)</span></span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple class declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h5 id="constructor-declaration">Constructor declaration</h5>
<div class="paragraph">
<p><span class="sentence">There are two types of class constructors in Kotlin: primary and secondary.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A primary constructor is a concise way of describing class properties together with constructor parameters, and has the following form</span></p>
</div>
<div class="paragraph">
<p><span class="sentence"><span class="math display">\[ptor : (p_1, \ldots, p_n)\]</span></span></p>
</div>
<div class="paragraph">
<p><span class="sentence">where each of <span class="math inline">\(p_i\)</span> may be one of the following:</span></p>
</div>
<ul>
<li><span class="sentence">regular constructor parameter <span class="math inline">\(name: type\)</span>;</span></li>
<li><span class="sentence">read-only property constructor parameter <span class="math inline">\(\mathtt{val} name: type\)</span>;</span></li>
<li><span class="sentence">mutable property constructor parameter <span class="math inline">\(\mathtt{val} name: type\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Property constructor parameters, together with being regular constructor parameters, also declare class properties of the same name and type. </span><span class="sentence">One can consider them to have the following syntactic expansion.</span></p>
</div>
<div class="sourceCode" id="cb1"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="kw">val</span> <span class="va">d</span>: <span class="dt">Double</span>, <span class="kw">var</span> <span class="va">s</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d</span>, <span class="va">s</span>) {}</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">class</span> Foo(<span class="va">i</span>: <span class="dt">Int</span>, <span class="va">d_</span>: <span class="dt">Double</span>, <span class="va">s_</span>: <span class="dt">String</span>) : <span class="dt">Super</span>(<span class="va">i</span>, <span class="va">d_</span>, <span class="va">s_</span>) {</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">val</span> <span class="va">d</span> = d_</a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">var</span> <span class="va">s</span> = s_</a>
<a class="sourceLine" id="cb1-6" title="6">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">When accessing property constructor parameters inside the class body, one works with their corresponding properties; however, when accessing them in the supertype specifier list (e.g., as an argument to a superclass constructor invocation), we see them as actual parameters, which cannot be changed.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class declaration has a primary constructor and also includes a class supertype specifier, that specifier must represent a valid invocation of the supertype constructor.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A secondary constructor describes an alternative way of creating a class instance and has only regular constructor parameters. </span><span class="sentence">If a class has a primary constructor, any secondary constructor must delegate to either the primary constructor or to another secondary constructor via <code>this(...)</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a class does not have a primary constructor, its secondary constructors must delegate to either the superclass constructor via <code>super(...)</code> (if the superclass is present in the supertype specifier list) or to another secondary constructor via <code>this(...)</code>. </span><span class="sentence">If the only superclass is <code>kotlin.Any</code>, delegation is optional.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In all cases, it is forbidden if two or more secondary constructors form a delegation loop.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(elaborate this <code>this(...)</code> and <code>super(...)</code> business)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(default values in constructors???)</span></p>
</div>
</div>
<h5 id="nested-and-inner-classifiers">Nested and inner classifiers</h5>
<div class="paragraph">
<p><span class="sentence">If a classifier declaration <span class="math inline">\(ND\)</span> is <em>nested</em> in another classifier declaration <span class="math inline">\(PD\)</span>, it creates a nested classifier type — a classifier type available under the path <span class="math inline">\(PD.ND\)</span>. </span><span class="sentence">In all other aspects, nested classifiers are equivalent to regular ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Inner classes are a special kind of nested classifiers, which introduce types of objects associated (linked) with other (parent) objects. </span><span class="sentence">An inner class declaration <span class="math inline">\(ID\)</span> nested in another classifier declaration <span class="math inline">\(PD\)</span> may reference an <em>object</em> of type <span class="math inline">\(ID\)</span> associated with it.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">This association happens when instantiating an object of type <span class="math inline">\(ID\)</span>, as its constructor may be invoked only when a receiver of type <span class="math inline">\(PD\)</span> is available, and this receiver becomes associated with the new instantiated object of type <span class="math inline">\(ID\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h5 id="inheritance-delegation">Inheritance delegation</h5>
<div class="paragraph">
<p><span class="sentence">In a classifier (an object or a class) <span class="math inline">\(C\)</span> declaration any supertype <span class="math inline">\(I\)</span> inheritance may be <em>delegated to</em> an arbitrary value <span class="math inline">\(v\)</span> if:</span></p>
</div>
<ul>
<li><span class="sentence">The supertype <span class="math inline">\(I\)</span> is an interface type;</span></li>
<li><span class="sentence"><span class="math inline">\(v\)</span> has type <span class="math inline">\(T\)</span> such that <span class="math inline">\(T &lt;: I\)</span>.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">The inheritance delegation uses a syntax similar to [property delegation][Property delegation] using the <code>by</code> keyword, but is specified in the classifier declaration header and is a very different concept. </span><span class="sentence">If inherited using delegation, each method <span class="math inline">\(M\)</span> of <span class="math inline">\(I\)</span> (whether they have a default implementation or not) is delegated to the corresponding method of <span class="math inline">\(v\)</span> as if it was overriden in <span class="math inline">\(C\)</span> with all the parameter values directly passed to the corresponding method in <span class="math inline">\(v\)</span>, unless the body of <span class="math inline">\(C\)</span> itself has a suitable override of <span class="math inline">\(M\)</span> (see the method overriding <span><span class="TODO">(TODO: link)</span><span class="TODO-marker">*</span></span> section).</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The particular means on how <span class="math inline">\(v\)</span> is stored inside the classifier object is platform-defined.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Due to the <a href="#classifier-initialization">initialization order of a classifier object</a>, the expression used to construct <span class="math inline">\(v\)</span> can not access any of the classifier object properties or methods excluding the parameters of the primary constructor.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="data-class-declaration">Data class declaration</h4>
<div class="paragraph">
<p><span class="sentence">A data class <span class="math inline">\(dataClass\)</span> is a special kind of class, which represents a product type constructed from a number of data properties <span class="math inline">\((dp_1, \ldots, dp_m)\)</span>, described in its primary constructor. </span><span class="sentence">As such, it allows Kotlin to reduce the boilerplate and generate a number of additional data-relevant functions. </span><span class="sentence">Each one of these functions is generated if and only if a matching signature function is not present in the class body.</span></p>
</div>
<ul>
<li><span class="sentence"><code>equals() / hashCode() / toString()</code> functions compliant with their contracts:</span>
<ul>
<li><span class="sentence"><code>equals(that)</code> returns true iff:</span>
<ul>
<li><span class="sentence"><code>that</code> has the same runtime type as <code>this</code>;</span></li>
<li><span class="sentence"><code>this.prop.equals(that.prop)</code> returns <code>true</code> for every data property <code>prop</code>;</span></li>
</ul></li>
<li><span class="sentence"><code>hashCode()</code> returns different numbers for objects <code>A</code> and <code>B</code> if they do not equal by the generated <code>equals</code>;</span></li>
<li><span class="sentence"><code>toString</code> returns a string representations which is guaranteed to include the class name along with all the data properties’ string representations.</span></li>
<li><div class="TODO">
<span class="sentence">TODO(Be more specific?).</span>
</div></li>
</ul></li>
<li><span class="sentence">A <code>copy()</code> function for shallow object copying with the following properties:</span>
<ul>
<li><span class="sentence">It has the same number of parameters as the primary constructor with the same names and types;</span></li>
<li><span class="sentence">It calls the primary constructor with the corresponding parameters at the corresponding positions;</span></li>
<li><span class="sentence">It has defaults for all the parameters defaulting to the value of the corresponding property in <code>this</code> object.</span></li>
</ul></li>
<li><span class="sentence">A number of <code>componentN()</code> functions for destructive declaration:</span>
<ul>
<li><span class="sentence">For the data property at position <span class="math inline">\(N\)</span> (<strong>starting with 1</strong>), the generated <code>component</code><span class="math inline">\(N\)</span> function has the same type as this property and returns the value of this property;</span></li>
<li><span class="sentence">It has an <code>operator</code> modifier, allowing it to be used in [destructuring declarations][Destructuring declaration];</span></li>
<li><span class="sentence">The number of these functions is the same as the number of data properties.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">These generated declarations of <code>equals</code>, <code>hashCode</code> and <code>toString</code> may be overriden the same way they may be overriden in normal classes. </span><span class="sentence">The overriding version is preferred, as normally. </span><span class="sentence">In addition, for every other function, if any of the base types provide an open function with a matching signature, it is automatically overriden by the generated function as if it was generated with an <code>override</code> modifier.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: base classes may also have functions that are either not open or have a conflicting signature with the same function name. </span><span class="sentence">As expected, these cases result in override or overload conflicts the same way they would do with a normal class declaration.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">All these functions consider only data properties <span class="math inline">\(\{dp_i\}\)</span>; e.g., your data class may include regular property declarations in its body, however, they will <em>not</em> be considered in the <code>equals()</code> implementation or have a <code>componentN()</code> generated for them.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Data classes have the following restrictions:</span></p>
</div>
<ul>
<li><span class="sentence">Data classes are final and cannot be inherited from;</span></li>
<li><span class="sentence">Data classes must have a primary constructor with only property constructor parameters, which become data properties for the data class;</span></li>
<li><span class="sentence">There must be at least one data property in the primary constructor.</span></li>
</ul>
<h5 id="data-class-generation">Data class generation</h5>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Do we really need this?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(A more detailed explaination)</span></p>
</div>
</div>
<h4 id="enum-class-declaration">Enum class declaration</h4>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(grammar reference)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Use “enumeration” instead of “enum”?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Enum class is a special kind of class with the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">It has a number of predefined values that are declared in the class itself (<em>enum entries</em>);</span></li>
<li><span class="sentence">No other values of this class can be constructed;</span></li>
<li><span class="sentence">It implicitly inherits the built-in class <code>kotlin.Enum</code> (and cannot have any other base classes);</span></li>
<li><span class="sentence">It it implicitly final and cannot be inherited from;</span></li>
<li><span class="sentence">It has special syntax to accommodate for the properties described above.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Enum class body uses special kind of syntax (see grammar) to declare enum entries in addition to all other declarations inside the class body. </span><span class="sentence">Enum entries have their own bodies that may contain their own declarations, similar to <a href="#object-declaration">object declarations</a>.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: an enum class can have zero enum entries. </span><span class="sentence">This makes objects of this class impossible to construct.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">In addition to this, every enum class has an implicit companion object declaration with the following member functions (in addition to the ones the object declaration specified explicitly has):</span></p>
</div>
<ul>
<li><span class="sentence"><code>valueOf(value: String)</code> returning an object corresponding to the entry with the name equal to <code>value</code> parameter of the call;</span></li>
<li><span class="sentence"><code>values()</code> returning an [array][Array types] of all the possible enum values. </span><span class="sentence">Every invocation of this function returns a new array to disallow changing its contents.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Kotlin standard library introduces another function to access all enum values for a specific enum class called <code>kotlin.enumValues&lt;T&gt;</code>. </span><span class="sentence">Please refer to the standard library documentation for details.</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>kotlin.Comparable</code> generation?)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="annotation-class-declaration">Annotation class declaration</h4>
<div class="paragraph">
<p><span class="sentence">Annotations class is a special kind of class that is used to declare [annotations][Annotations]. </span><span class="sentence">Annotation classes have the following properties:</span></p>
</div>
<ul>
<li><span class="sentence">They cannot have any secondary constructors;</span></li>
<li><span class="sentence">All the primary constructor parameters must use the property syntax;</span></li>
<li><span class="sentence">They implicitly inherit <code>kotlin.Annotation</code> class (and cannot have any other base classes);</span></li>
<li><span class="sentence">They cannot implement interfaces;</span></li>
<li><span class="sentence">They are implicitly final and cannot be inherited from;</span></li>
<li><span class="sentence">They may not have any member functions, properties not declared in the primary constructor or any overriding declarations;</span></li>
<li><span class="sentence">They cannot have companion objects;</span></li>
<li><span class="sentence">They cannot have nested classes;</span></li>
<li><span class="sentence">The types of primary constructor parameters are limited to:</span>
<ul>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
<li><span class="sentence"><code>kotlin.KClass</code>;</span></li>
<li><span class="sentence">[Built-in number types][Built-in types];</span></li>
<li><span class="sentence">Other annotation types;</span></li>
<li><span class="sentence">Arrays of any other allowed type.</span></li>
</ul></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Annotation classes cannot be constructed directly, but their primary constructors are used when specifying [code annotations][Annotations] for other entities.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(…)</span></p>
</div>
</div>
<h4 id="interface-declaration">Interface declaration</h4>
<div class="paragraph">
<p><span class="sentence">Interfaces differ from classes in that they cannot be directly instantiated in the program, they are meant as a way of describing a contract which should be satisfied by the interface’s subtypes. </span><span class="sentence">In other aspects they are similar to classes, therefore we shall specify their declarations by specifying their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An interface cannot have a class as its supertype;</span></li>
<li><span class="sentence">An interface cannot have a constructor;</span></li>
<li><span class="sentence">Interface properties cannot have initializers or backing fields;</span></li>
<li><span class="sentence">An interface cannot have inner classes (but can have nested classes and companion objects);</span></li>
<li><span class="sentence">An interface and all its members are implicitly open;</span></li>
<li><span class="sentence">All interface member properties and functions are implicitly public;</span>
<ul>
<li><span class="sentence">Trying to declare a non-public member property or function in an interface is an error.</span></li>
</ul></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<h4 id="object-declaration">Object declaration</h4>
<div class="paragraph">
<p><span class="sentence">Object declarations are used to support a singleton pattern and, thus, do two things at the same time. </span><span class="sentence">One, they (just like class declarations) introduce a new type to the program. </span><span class="sentence">Two, they create a singleton-like object of that type.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(do we really need this ironic-ish statement about doing two things at the same time?)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">Similarly to interfaces, we shall specify object declarations by highlighting their differences from class declarations.</span></p>
</div>
<ul>
<li><span class="sentence">An object type cannot be used as a supertype for other types;</span></li>
<li><span class="sentence">An object cannot have a constructor;</span></li>
<li><span class="sentence">An object cannot have a companion object;</span></li>
<li><span class="sentence">An object may not have inner classes;</span></li>
<li><span class="sentence">An object cannot be parameterized, i.e., cannot have type parameters.</span></li>
</ul>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Something else?)</span></p>
</div>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this section is about declaration of <em>named</em> objects. </span><span class="sentence">Kotlin also has a concept of <em>anonymous</em> objects, or object literals, which are similar to their named counterparts, but are expressions rather than declarations and, as such, are described in the [corresponding section][Object literals].</span></p>
</div>
</blockquote>
<h4 id="classifier-initialization">Classifier initialization</h4>
<div class="paragraph">
<p><span class="sentence">When creating a class or object instance via one of its constructors <span class="math inline">\(ctor\)</span>, it is initialized in a particular order, which we describe here.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">First, a supertype constructor corresponding to <span class="math inline">\(ctor\)</span> is called with its respective parameters.</span></p>
</div>
<ul>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a primary constructor, a corresponding supertype constructor is the one from the supertype specifier list;</span></li>
<li><span class="sentence">If <span class="math inline">\(ctor\)</span> is a secondary constructor, a corresponding supertype constructor is the one ending the constructor delegation chain of <span class="math inline">\(ctor\)</span>;</span></li>
<li><span class="sentence">If an explicit supertype constructor is not available, <code>Any()</code> is implicitly used.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">After the supertype initialization is done, we continue the initialization by processing each inner declaration in its body, <em>in the order of their inclusion in the body</em>. </span><span class="sentence">If any initialization step creates a loop, it is considered an undefined behavior.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">When a classifier type is initialized using a particular secondary constructor <span class="math inline">\(ctor\)</span> delegated to primary constructor <span class="math inline">\(pctor\)</span> which, in turn, is delegated to the superclass constructor <span class="math inline">\(sctor\)</span>, the following happens, in this order:</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(pctor\)</span> is invoked using the specified parameters, initializing all the properties declared by its property parameters in the order they appear in the constructor declaration;</span></li>
<li><span class="sentence">The superclass object (if any) is initialized as if created by invoking <span class="math inline">\(sctor\)</span> with the specified parameters;</span></li>
<li><span class="sentence">Interface delegation expressions (if any) are invoked and the result of each is stored in the object to allow for interface delegation, in the order of appearance of delegation declarations in the classifier header;</span></li>
<li><span class="sentence">All the properties’ initialization code as well as all the initialization blocks in the class body get initialized in the order of appearance in the class body;</span></li>
<li><span class="sentence"><span class="math inline">\(ctor\)</span> body is invoked using the specified parameters.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that if an <code>init</code>-block appears between two property declarations in the class body, its body is invoked between the initialization code of these two properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">This order stays the same if any of the entities involved are omitted, omitting the corresponding step (e.g. if there is no primary constructor, it is not invoked, and if the object is created using primary constructor, the body of the secondary one is not invoked, etc.), but performing all others. </span><span class="sentence">If any of the properties of the object are accessed before they are initialized in this order (for example, if a method called in an initialization block accesses a property that is mention after the block), the value of the property is undefined.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this can happen if a property is captured in a lambda expression that is used in some way during other initialization phases</span></p>
</div>
</blockquote>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(This needs thorough testing)</span></p>
</div>
</div>
<h3 id="function-declaration">Function declaration</h3>
<strong>Id grammar-rule-functionDeclaration not found</strong>
<strong>Id grammar-rule-functionBody not found</strong>
<div class="paragraph">
<p><span class="sentence">Function declarations assign names to functions — blocks of code which may be called by passing them a number of arguments. </span><span class="sentence">Functions have special <em>function types</em> which are covered in more detail [here][Function types].</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A simple function declaration consists of four main parts:</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and creates a function type <span class="math inline">\(f : (P_1, \ldots, P_n) \rightarrow R\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span> describes function parameters — inputs needed to execute the declared function. </span><span class="sentence">Each parameter <span class="math inline">\(p_i: P_i = v_i\)</span> introduces <span class="math inline">\(p_i\)</span> as a name of value with type <span class="math inline">\(P_i\)</span> available inside function body <span class="math inline">\(b\)</span>; therefore, parameters are final and cannot be changed inside the function. </span><span class="sentence">A function may have zero or more parameters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A parameter may include a default value <span class="math inline">\(v_i\)</span>, which is used if the corresponding argument is not specified in function invocation; <span class="math inline">\(v_i\)</span> should be an expression which evaluates to type <span class="math inline">\(V &lt;: P_i\)</span>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Return type <span class="math inline">\(R\)</span> is optional, if function body <span class="math inline">\(b\)</span> is present and may be inferred to have a valid type <span class="math inline">\(B : B \not \equiv kotlin.Nothing\)</span>, in which case <span class="math inline">\(R \equiv B\)</span>. </span><span class="sentence">In other cases return type <span class="math inline">\(R\)</span> must be specified explicitly.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">As type <span class="math inline">\(kotlin.Nothing\)</span> has a [special meaning][<code>kotlin.Nothing</code>] in Kotlin type system, it must be specified explicitly, to avoid spurious <span class="math inline">\(kotlin.Nothing\)</span> function return types.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Function body <span class="math inline">\(b\)</span> is optional; if it is ommited, a function declaration creates an <em>abstract</em> function, which does not have an implementation. </span><span class="sentence">This is allowed only inside an <a href="#classifier-declaration">abstract classifier declaration</a>. </span><span class="sentence">If a function body <span class="math inline">\(b\)</span> is present, it should evaluate to type <span class="math inline">\(B\)</span> which should satisfy <span class="math inline">\(B &lt;: R\)</span>.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: <code>expect</code> and <code>external</code> functions also do not have implementations</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">A parameterized function declaration consists of five main parts.</span></p>
</div>
<ul>
<li><span class="sentence">name <span class="math inline">\(f\)</span></span></li>
<li><span class="sentence">type parameter list <span class="math inline">\(T_1, \ldots, T_m\)</span></span></li>
<li><span class="sentence">parameter list <span class="math inline">\((p_1: P_1 = v_1, \ldots, p_n: P_n = v_n)\)</span></span></li>
<li><span class="sentence">return type <span class="math inline">\(R\)</span></span></li>
<li><span class="sentence">body <span class="math inline">\(b\)</span></span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">and extends the rules for a simple function declaration w.r.t. type parameter list. </span><span class="sentence">Further details are described <a href="#declarations-with-type-parameters">here</a>.</span></p>
</div>
<h4 id="named-positional-and-default-parameters">Named, positional and default parameters</h4>
<div class="paragraph">
<p><span class="sentence">Kotlin supports <em>named</em> parameters out-of-the-box, meaning one can bind an argument to a parameter in function invocation not by its position, but by its name, which is equal to the argument name.</span></p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span>, <span class="va">b</span>: <span class="dt">Double</span>, <span class="va">s</span>: <span class="dt">String</span>): <span class="dt">Double</span> = a + b + s.toDouble()</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb2-4" title="4">    println(bar(b = <span class="fl">42.0</span>, a = <span class="dv">5</span>, s = <span class="st">&quot;13&quot;</span>))</a>
<a class="sourceLine" id="cb2-5" title="5">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(Argument names are resolved in compile time)</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">If one wants to mix named and positional arguments, the argument list must conform to the following form: <span class="math inline">\(P_1, \ldots, P_M, N_1, \ldots, N_Q\)</span>, where <span class="math inline">\(P_i\)</span> is a positional argument, <span class="math inline">\(N_j\)</span> is a named argument; i.e., positional arguments must precede all of the named ones.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Kotlin also supports <em>default</em> parameters — parameters which have a default value used in function invocation, if the corresponding argument is missing. </span><span class="sentence">Note that default parameters cannot be used to provide a value for positional argument <em>in the middle</em> of the positional argument list; allowing this would create an ambiguity of which argument for position <span class="math inline">\(i\)</span> is the correct one: explicit one provided by the developer or implicit one from the default value.</span></p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">fun</span> <span class="fu">bar</span>(<span class="va">a</span>: <span class="dt">Int</span> = 1, <span class="va">b</span>: <span class="dt">Double</span> = 42.0, <span class="va">s</span>: <span class="dt">String</span> = <span class="st">&quot;Hello&quot;</span>): <span class="dt">Double</span> =</a>
<a class="sourceLine" id="cb3-2" title="2">    a + b + s.toDouble()</a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="co">// Valid call, all default parameters used</span></a>
<a class="sourceLine" id="cb3-6" title="6">    println(bar())</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="co">// Valid call, defaults for `b` and `s` used</span></a>
<a class="sourceLine" id="cb3-8" title="8">    println(bar(<span class="dv">2</span>))</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="co">// Valid call, default for `b` used</span></a>
<a class="sourceLine" id="cb3-10" title="10">    println(bar(<span class="dv">2</span>, s = <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="co">// Invalid call, default for `b` cannot be used</span></a>
<a class="sourceLine" id="cb3-13" title="13">    println(bar(<span class="dv">2</span>, <span class="st">&quot;Me&quot;</span>))</a>
<a class="sourceLine" id="cb3-14" title="14">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">In summary, argument list should have the following form:</span></p>
</div>
<ul>
<li><span class="sentence">Zero or more positional arguments;</span></li>
<li><span class="sentence">Zero or more named arguments.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">Missing arguments are bound to their default values, if they exist.</span></p>
</div>
<h4 id="variable-length-parameters">Variable length parameters</h4>
<div class="paragraph">
<p><span class="sentence">One of the parameters may be designated as being variable length (aka <em>vararg</em>). </span><span class="sentence">A parameter list <span class="math inline">\((p_1, \ldots, \text{vararg }p_i: P_i = v_i, \ldots, p_n)\)</span> means a function may be called with any number of arguments in the i-th position. </span><span class="sentence">These arguments are represented inside function body <span class="math inline">\(b\)</span> as a value <span class="math inline">\(p_i\)</span> of type, which is the result of [<em>array type specialization</em>][Array types] of type <code>Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter is not last in the parameter list, all subsequent arguments in the function invocation should be specified as named arguments.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">If a variable length parameter has a default value, it should be an expression which evaluates to a value of type, which is the result of [<em>array type specialization</em>][Array types] of type <code>Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">An array of type <code>Array&lt;Q&gt;</code><span class="math inline">\(\: &lt;: \:\)</span><code>ATS(Array&lt;out</code><span class="math inline">\(P_i\)</span><code>&gt;)</code> may be <em>unpacked</em> to a variable length parameter in function invocation using [spread operator][Spread operator]; in this case array elements are considered to be separate arguments in the variable length parameter position.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: this means that, for variable length parameters corresponding to specialized array types, unpacking is possible only for these specialized versions; for a variable length parameter of type <code>Int</code>, for example, unpacking is valid only for <code>IntArray</code>, and not for <code>Array&lt;Int&gt;</code>.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">A function invocation may include several spread operator expressions corresponding to the vararg parameter.</span></p>
</div>
<h4 id="extension-function-declaration">Extension function declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension function declaration</em> is similar to a standard function declaration, but introduces an additional special function parameter, the <em>receiver parameter</em>. </span><span class="sentence">This parameter is designated by specifying the receiver type (the type before <code>.</code> in function name), which becomes the type of this receiver parameter. </span><span class="sentence">This parameter is not named and must always be supplied (either explicitly or implicitly), e.g. it cannot be a variable-argument parameter, have a default value, etc.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Calling such a function is special because the receiver parameter is not supplied as an argument of the call, but as the [<em>receiver</em>][Receivers] of the call, be it implicit or explicit. </span><span class="sentence">This parameter is available inside the scope of the function as the implicit receiver or <code>this</code>-expression, while nested scopes may introduce additional receivers that take precedence over this one. </span><span class="sentence">See [the receiver section][Receivers] for details. </span><span class="sentence">This receiver is also available (as usual) in nested scope using labeled <code>this</code> syntax using the name of the declared function as the label.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">For more information on how a particular receiver for each call is chosen, please refer to the [overloading section][Overload resolution].</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension functions inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested functions</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension functions are not different from non-extension functions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb4"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span> + <span class="dv">1</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="fl">2.f</span>oo() <span class="co">// prints &quot;3&quot;</span></a>
<a class="sourceLine" id="cb4-5" title="5">}</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="kw">fun</span> <span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Bar</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">fun</span> <span class="fu">Int</span>.<span class="fu">foo</span>() { println(<span class="kw">this</span>) } <span class="co">// this has type Int</span></a>
<a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div>
<h3 id="property-declaration">Property declaration</h3>
<strong>Id grammar-rule-propertyDeclaration not found</strong>
<div class="paragraph">
<p><span class="sentence">Property declarations are used to create read-only (<code>val</code>) or mutable (<code>var</code>) entities in their respective scope. </span><span class="sentence">Properties may also have custom getter or setter — functions which are used to read or write the property value.</span></p>
</div>
<h4 id="read-only-property-declaration">Read-only property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration <code>val x: T = e</code> introduces <code>x</code> as a name of the result of <code>e</code>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A read-only property declaration may include a custom <a href="#getters-and-setters">getter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb5"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">val</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="kw">get</span>() { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation. </span><span class="sentence">Both the right-hand value <code>e</code>, the type <code>T</code> and the getter are optional, however, at least one of them must be specified. </span><span class="sentence">More so, if both the type of <code>e</code> and the return type of the getter cannot be [inferred][Type inference] (or, in case of the getter, specified explicitely), the type <code>T</code> must be specified explicitly. </span><span class="sentence">In case both <code>e</code> and <code>T</code> are specified, the type of <code>e</code> must be a subtype of <code>T</code> (see [subtyping][Subtyping] for more details).</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO: we never actually say how getters are similar/different to normal functions and, henceworth, how the inference works</span></p>
</div>
</div>
<div class="paragraph">
<p><span class="sentence">The initializer expression <code>e</code>, if given, serves as the starting value for the property backing field (see <a href="#getters-and-setters">getters and setters section</a> for details) and is evaluated when the property is created. </span><span class="sentence">Properties that are not allowed to have backing fields (see <a href="#getters-and-setters">getters and setters section</a> for details) are also not allowed to have initializer expressions.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: although a property with an initializer expression looks similar to an [assignment][Assignments], it is different in several key ways: first, a read-only property cannot be assigned, but may have an initializer expression; second, the initializer expression never invokes the property setter, but assigns the property backing field value directly.</span></p>
</div>
</blockquote>
<h4 id="mutable-property-declaration">Mutable property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration <code>var x: T = e</code> introduces <code>x</code> as a name of a mutable variable with type <code>T</code> and initial value equals to the result of <code>e</code>. </span><span class="sentence">The rules regarding the right-hand value <code>e</code> and the type <code>T</code> match those of a read-only property declaration.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">A mutable property declaration may include a custom <a href="#getters-and-setters">getter</a> and/or custom <a href="#getters-and-setters">setter</a> in the form of</span></p>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">set</span>(value: TS) { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">in which case <code>x</code> is used as a synonym to the getter invocation when read from and to the setter invocation when written to.</span></p>
</div>
<h4 id="delegated-property-declaration">Delegated property declaration</h4>
<div class="paragraph">
<p><span class="sentence">A delegated read-only property declaration <code>val x: T by e</code> introduces <code>x</code> as a name for the <em>delegation</em> result of property <code>x</code> to the entity <code>e</code>. </span><span class="sentence">One may view these properties as regular properties with a special <em>delegating</em> <a href="#getters-and-setters">getters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">In case of a delegated read-only property, every access to such property (<code>x</code> in this case) becomes an [overloadable][Operator overloading] form which is expanded into the following:</span></p>
</div>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">e<span class="op">.</span>getValue(thisRef, property)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the [receiver][Receivers] object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details).</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">A delegated mutable property declaration <code>var x: T by e</code> introduces <code>x</code> as a name of a mutable entity with type <code>T</code>, access to which is <em>delegated</em> to the entity <code>e</code>. </span><span class="sentence">As before, one may view these properties as regular properties with special <em>delegating</em> <a href="#getters-and-setters">getters and setters</a>.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read access is handled the same way as for a delegated read-only property. </span><span class="sentence">Any write access to <code>x</code> (using, for example, an assignment operator <code>x = y</code>) becomes an overloadable form with the following expansion:</span></p>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">e<span class="op">.</span>setValue(thisRef, property, y)</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where</span></p>
</div>
<ul>
<li><span class="sentence"><code>e</code> is the delegating entity; the compiler needs to make sure that this is accessible in any place <code>x</code> is accessible;</span></li>
<li><span class="sentence"><code>getValue</code> is a suitable operator function available on <code>e</code>;</span></li>
<li><span class="sentence"><code>thisRef</code> is the [receiver][Receivers] object for the property. </span><span class="sentence">This argument is <code>null</code> for local properties;</span></li>
<li><span class="sentence"><code>property</code> is an object of the type <code>kotlin.KProperty&lt;*&gt;</code> that contains information relevant to <code>x</code> (for example, its name, see standard library documentation for details);</span></li>
<li><span class="sentence"><code>y</code> is the value <code>x</code> is assigned to. </span><span class="sentence">In case of complex assignments (see the [assignment][Assignments] section), as they are all overloadable forms, first the assignment expansion is performed, and after that, the expansion of the delegated property using normal assignment.</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">An example on how the delegation expansion may be actually implemented by the compiler is as follows.</span></p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb9-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co"> * Actual code</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="kw">var</span> <span class="va">prop</span>: Type <span class="kw">by</span> DelegateExpression</a>
<a class="sourceLine" id="cb9-6" title="6">}</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="co">/*</span></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="co"> * Expanded code</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">class</span> C {</a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="kw">private</span> <span class="kw">val</span> <span class="va">prop</span>$delegate = DelegateExpression</a>
<a class="sourceLine" id="cb9-13" title="13">    <span class="kw">var</span> <span class="va">prop</span>: Type</a>
<a class="sourceLine" id="cb9-14" title="14">        <span class="kw">get</span>() = prop$delegate.getValue(<span class="kw">this</span>, <span class="kw">this</span>::prop)</a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="kw">set</span>(value: Type) = prop$delegate.setValue(<span class="kw">this</span>, <span class="kw">this</span>::prop, value)</a>
<a class="sourceLine" id="cb9-16" title="16">}</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">The type of a delegated property may be omitted at the declaration site, meaning that it may be [inferred][Type inference] from the delegating function itself. </span><span class="sentence">If this type is omitted, it is inferred as if it was assigned the value of its expansion. </span><span class="sentence">If this inference fails, it is a compile-time error.</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(provideDelegate)</span></p>
</div>
</div>
<h4 id="local-property-declaration">Local property declaration</h4>
<div class="paragraph">
<p><span class="sentence">If a property declaration is local, it creates a local entity which follows most of the same rules as the ones for regular property declarations. </span><span class="sentence">However, local property declarations cannot have custom getters or setters.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Local property declarations also support <em>destructive</em> declaration in the form of</span></p>
</div>
<div class="sourceCode" id="cb10"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">val</span> (<span class="va">a</span>: T, b: U, c: V, ...) = e</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">which is a syntactic sugar for the following expansion</span></p>
</div>
<div class="sourceCode" id="cb11"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">val</span> <span class="va">a</span>: T = e.component1()</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">val</span> <span class="va">b</span>: U = e.component2()</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">val</span> <span class="va">c</span>: V = e.component3()</a>
<a class="sourceLine" id="cb11-4" title="4">...</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">where <code>componentN()</code> should be a valid operator function available on the result of <code>e</code>. </span><span class="sentence">Each individual component property follows the rules for regular local property declaration.</span></p>
</div>
<h4 id="getters-and-setters">Getters and setters</h4>
<div class="paragraph">
<p><span class="sentence">As mentioned before, a property declaration may include a custom getter and/or custom setter (together called <em>accessors</em>) in the form of</span></p>
</div>
<div class="sourceCode" id="cb12"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">get</span>(): TG { ... }</a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="kw">set</span>(anyValidArgumentName: TS): RT { ... }</a></code></pre></div>
<div class="paragraph">
<p><span class="sentence">These functions have the following requirements</span></p>
</div>
<ul>
<li><span class="sentence"><span class="math inline">\(TG \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(TS \equiv T\)</span>;</span></li>
<li><span class="sentence"><span class="math inline">\(RT \equiv \mathtt{kotlin.Unit}\)</span>;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Types <span class="math inline">\(TG\)</span>, <span class="math inline">\(TS\)</span> and <span class="math inline">\(RT\)</span> are optional and may be omitted from the declaration;</span></p>
</div></li>
<li><span class="sentence">Read-only properties may have a custom getter, but not a custom setter;</span></li>
<li><div class="paragraph">
<p><span class="sentence">Mutable properties may have any combination of a custom getter and a custom setter</span></p>
</div></li>
<li><div class="paragraph">
<p><span class="sentence">Setter argument may have any valid identifier as argument name.</span></p>
</div></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: Regular coding convention recommends <code>value</code> as the name for the setter argument</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">One can also ommit the accessor body, in which case a <em>default</em> implementation is used (also known as default accessor).</span></p>
</div>
<div class="sourceCode" id="cb13"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">var</span> <span class="va">x</span>: T = e</a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="kw">get</span></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="kw">set</span></a></code></pre></div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">This notation is usually used if you need to change some aspects of an accessor (i.e., its visibility) without changing the default implementation.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow one to customize how the property is accessed, and may need access to the property’s <em>backing field</em>, which is responsible for actually storing the property data. </span><span class="sentence">It is accessed via the special <code>field</code> property available inside accessor body, which follows these conventions</span></p>
</div>
<ul>
<li><span class="sentence">For a property declaration of type <code>T</code>, <code>field</code> has the same type <code>T</code></span></li>
<li><span class="sentence"><code>field</code> is read-only inside getter body</span></li>
<li><span class="sentence"><code>field</code> is mutable inside setter body</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">However, the backing field is created for a property only in the following cases</span></p>
</div>
<ul>
<li><span class="sentence">A property has no custom accessors;</span></li>
<li><span class="sentence">A property has a default accessor;</span></li>
<li><span class="sentence">A property has a custom accessor, and it uses <code>field</code> property;</span></li>
<li><span class="sentence">A mutable property has a custom getter or setter, but not both/</span></li>
</ul>
<div class="paragraph">
<p><span class="sentence">In all other cases a property has no backing field. </span><span class="sentence">Properties without backing fields are not allowed to have initializer expressions.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Read/write access to the property is replaced with getter/setter invocation respectively.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Getters and setters allow for some modifiers available for function declarations (for example, they may be declared <code>inline</code>, see grammar for details).</span></p>
</div>
<h4 id="extension-property-declaration">Extension property declaration</h4>
<div class="paragraph">
<p><span class="sentence">An <em>extension property declaration</em> is similar to a standard property declaration, but, very much alike an <a href="#extension-function-declaration">extension function</a>, introduces an additional parameter to the property called <em>the receiver parameter</em>. </span><span class="sentence">This is different from usual property declarations, that do not have any parameters. </span><span class="sentence">There are other differences from standard property declarations:</span></p>
</div>
<ul>
<li><span class="sentence">Extension properties cannot have initializers;</span></li>
<li><span class="sentence">Extension properties cannot have backing fields;</span></li>
<li><span class="sentence">Extension properties cannot have default accessors.</span></li>
</ul>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: informally, on can say that extension properties have no state of their own. </span><span class="sentence">Only properties that use other objects’ storage facilities and/or uses constant data can be extension properties.</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">Aside from these differences, extension properties are similar to regular properties, but, when accessing such a property one always need to supply a [<em>receiver</em>][Receivers], implicit or explicit. </span><span class="sentence">Also, unlike regular properties, the type of the receiver must be a subtype of the receiver parameter, and the value that is supplied as the receiver is bound to the receiver parameter. </span><span class="sentence">For more information on how a particular receiver for each access is chosen, please refer to the [overloading section][Overload resolution].</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">The receiver parameter can be accessed inside getter and setter scopes of the property as the implicit receiver or <code>this</code>. </span><span class="sentence">It may also be accessed inside nested scopes using [labeled <code>this</code> syntax][This-expressions] using the name of the property declared as the label. </span><span class="sentence">For delegated properties, the value passed into the operator functions <code>getValue</code> and <code>setValue</code> as the receiver is the value of the receiver parameter, rather than the value of the outer classifier. </span><span class="sentence">This is also true for local extension properties: while regular local properties are passed <code>null</code> as the first argument of these operator functions, local extension properties are passed the value of the receiver argument instead.</span></p>
</div>
<blockquote>
<div class="paragraph">
<p><span class="sentence">Note: when declaring extension properties inside classifier declarations, this receiver takes precedence over the classifier object, which is usually the current receiver inside nested properties</span></p>
</div>
</blockquote>
<div class="paragraph">
<p><span class="sentence">For all other purposes, extension properties are not different from non-extension properties.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">Examples:</span></p>
</div>
<div class="sourceCode" id="cb14"><pre class="sourceCode kotlin"><code class="sourceCode kotlin"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">val</span> <span class="va">Int</span>.foo: <span class="kw">Int</span> <span class="kw">get</span>() = <span class="kw">this</span> + <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">fun</span> <span class="fu">main</span>(<span class="va">args</span>: <span class="dt">Array</span>&lt;<span class="va">String</span>&gt;) {</a>
<a class="sourceLine" id="cb14-4" title="4">    println(<span class="fl">2.f</span>oo.foo) <span class="co">// prints &quot;4&quot;</span></a>
<a class="sourceLine" id="cb14-5" title="5">}</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="kw">class</span> Bar {</a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="kw">val</span> <span class="va">foo</span> <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Bar</span></a>
<a class="sourceLine" id="cb14-9" title="9">    <span class="kw">val</span> <span class="va">Int</span>.foo <span class="kw">get</span>() = <span class="kw">this</span> <span class="co">// returns type Int</span></a>
<a class="sourceLine" id="cb14-10" title="10">}</a></code></pre></div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(More examples (delegation, at least))</span></p>
</div>
</div>
<h4 id="property-initialization">Property initialization</h4>
<div class="paragraph">
<p><span class="sentence">All non-abstract properties must be definitely initialized before their first use. </span><span class="sentence">To guarantee this, Kotlin compiler uses a number of analyses which are described in more detail [here][Control- and data-flow analysis].</span></p>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(maybe it makes more sense to write all the initialization business right here)</span></p>
</div>
</div>
<h4 id="constant-properties">Constant properties</h4>
<div class="paragraph">
<p><span class="sentence">A property may be declared <strong>constant</strong>, meaning that its value is known during compilation, by using the special <code>const</code> modifier. </span><span class="sentence">In order to be declared <code>const</code>, a property must meet the following requirements:</span></p>
</div>
<ul>
<li><span class="sentence">Its type is one of the following:</span>
<ul>
<li><span class="sentence">One of the [the built-in integral types][Built-in integer types];</span></li>
<li><span class="sentence"><code>kotlin.Boolean</code>;</span></li>
<li><span class="sentence"><code>kotlin.Char</code>;</span></li>
<li><span class="sentence"><code>kotlin.String</code>;</span></li>
</ul></li>
<li><span class="sentence">It is declared in the top-level scope or inside [an object declaration][Object declarations];</span></li>
<li><span class="sentence">It has an initializer expression and this initializer expression may be evaluated in the compile-time. </span><span class="sentence">Integer literals and string interpolation expressions without evaluated expressions, as well as builtin arithmetic/comparison operations and string concatenation operations on those are such expressions, but it is implementation-defined which other expressions qualify for this;</span></li>
<li><span class="sentence">It does not have getters, setters or delegation specifiers.</span></li>
</ul>
<h3 id="type-alias">Type alias</h3>
<strong>Id grammar-rule-typeAlias not found</strong>
<div class="paragraph">
<p><span class="sentence">Type alias introduces an alternative name for the specified type and supports both simple and parameterized types. </span><span class="sentence">If type alias is parameterized, its type parameters must be [unbounded][Type parameters]. </span><span class="sentence">Another restriction is that recursive type aliases are forbidden — the type alias name cannot be used in its own right-hand side.</span></p>
</div>
<div class="paragraph">
<p><span class="sentence">At the moment, Kotlin supports only top-level type aliases. </span><span class="sentence">The scope where it is accessible is defined by its [<em>visibility modifiers</em>][Visibility].</span></p>
</div>
<h3 id="declarations-with-type-parameters">Declarations with type parameters</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO()</span></p>
</div>
</div>
<h3 id="declaration-modifiers">Declaration modifiers</h3>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(declaration scope)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>open</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>abstract</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>lateinit</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(<code>const</code>)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(overriding vs overloading vs shadowing)</span></p>
</div>
</div>
<div class="TODO">
<div class="paragraph">
<p><span class="sentence">TODO(visibility)</span></p>
</div>
</div>
</body>
</html>
